#define MonteCarloPhylogenyFunctions#include "MonteCarloPhylogenyFunctions.h"#include "matrixchange.h"#include "matrixreading.h"#include "memory.h"#include "minmax.h"#include "Probability.h"//#include "CompatibilityFunctions.h"#include <stdlib.h>#include <stdio.h>#include <time.h>#include <math.h>#include <string.h>/* EvolveTreeVenn - Evolves a paleontological tree, with notu taxa sampled over time/* Requires:	notu - # of sampled taxa/*				MU - Speciation rate/*				LAMBDA - Extinction rate/*				FREQRAT - Preservation rate/*				FOSSILS - (1) fossils sampled, (0) no fossils sampled/*				SPECIATION - (1) bifurcation (0) budding cladogenesis/* Bifurcation routine modified 02/04/03******************************************************************************************************/long **EvolveTree(int notu, int MU, int LAMBDA, int FREQRAT, int VARR, int FOSSILS, int SPECIATION){long	attempts;int		a, b, c, d, ee, charstandard, ch, latest, MaxDiv=6, chucks, brats;int		pred, clade, OTU, OTU2, sampled, initdiv, standingdiv, cumulativediv, stage, newby;int		species, anc, speciate, extinct, change, find, testnode, plesion, HTU;int		sampledanc, reboot;int		sp, sp2, sp3, nodes, found, distance, sistersp, grandma, greatgrandma;int		MaxTaxa, MaxStanding;int		*available, *f1, **forefathers, *ancestor, *MS;int		*extant, *observed, *unsampled, *commonanc, *divers, *TrPD;int		*FA, *LA, *DBas;double	*TO, *TE;long	**tree;double	v, x, y, z, xx, yy, MOD;x=MU;x=x/1000;xx=1-x;y=FREQRAT;y=y/1000;yy=1-y;v=z=0;for (a=1; a<100; ++a)	{	z=x;	xx=1;	for (b=1; b<a; ++b)	xx=xx*(1-x);	z=x*xx;						/* gives proportion living a stages */	y=(1-pow(yy,a));			/* gives the probability of being sampled 1+ times over a stages */	v=v+(z*y);					/* gives the proportion being sampled */	}v=1/v;v=v*5;MaxTaxa=10*v*notu;MaxStanding=3*notu;/* tree matrix - rows 0...(notu-1) rows are for possible nodes	*//*		row notu is for species branch lengths					*//*		row notu+1 is for nodal branch lengths					*//*		row notu+2 is for species FAs							*//*		row notu+3 is for species LAs							*//*		the first cell of rows 0É(notu-1) give # branches		*//*			(i.e., 2 for bifurcation w. no sampled ancestor)	*/tree=lmatrix(notu+3,notu+1);clearlmatrix(tree,notu+3,notu+1,-1);/* arrays for observed taxa - set to notu*/observed=ivector(notu);unsampled=ivector(notu);commonanc=ivector(notu);divers=ivector(notu);FA=ivector(notu);LA=ivector(notu);DBas=ivector(notu);/* array for all elements of the tree */TrPD=ivector(2*notu);/* array for standing taxa - set to MaxStanding*/extant = ivector(MaxStanding);/* arrays for sampled and unsampled taxa - set to MaxTaxa */ancestor=ivector(MaxTaxa);	/* ancestor of each taxon */available=ivector(MaxTaxa);f1=ivector(MaxTaxa);		/* number of descendants for each taxon */MS=ivector(MaxTaxa);		/* branch length of each taxon */TO=dvector(MaxTaxa);		/* true origination - this is a real number */TE=dvector(MaxTaxa);		/* true extinction - this is a real number */reboot=0;a=b=c=d=ee=anc=0;charstandard = 1; /*charbase/100;*/sp = ch = change = find = 0;clearivector(observed,notu,-1);clearivector(unsampled,notu,-1);clearivector(ancestor,MaxTaxa,-1);clearivector(MS,MaxTaxa,1);clearivector(extant,MaxStanding,-1);latest = -1;attempts = initdiv = standingdiv = cumulativediv = stage = extant[0] = sampled = 0;while (sampled < notu)	{	initdiv = standingdiv+1;	for (sp=0; sp<=standingdiv && sp<notu; ++sp)	{	/********************************************/	/*			Does Lineage Speciate?			*/	/********************************************/		if (sp<0 || sp>=MaxStanding)	{			printf("ERROR 113: %d is the wrong number of species!\n", sp);			exit(0);			}		species = extant[sp];		TE[species]=stage+1;				if (f1[species]<MaxDiv)	speciate = (((unsigned int) rand())%1000);		else					speciate = 1000;		MOD=MU;		if (sp>=initdiv)			MOD=((stage+1)-TO[species])*MOD;				if (speciate <= MOD && standingdiv<MaxStanding)		{			brats=1;			if (SPECIATION==1)	brats=2;			else	{				y=LAMBDA;				y=y/1000;				if (TO[species]>stage)	v=(stage+1)-TO[species];				else					v=1;				x=Poisson(y, v, 2);				if (speciate<x*1000)	brats=2;				}			/* go through each descendant */			for (a=0; a<brats; ++a)	{				++standingdiv;				MS[++cumulativediv]=1;				extant[standingdiv] = cumulativediv;				if (cumulativediv > MaxTaxa)	{					printf("ERROR Evolve 142 - In replication XXX");					printf(", more than %3d species were generated.  \n",MaxTaxa);					sampled=notu;					exit(0);						}				if (standingdiv<0 || standingdiv>=MaxStanding)	{					printf("ERROR 148:  Standing diversity too high at %2d\n",standingdiv);					sampled=notu;					exit(0);						}							if (cumulativediv<0 || cumulativediv>=MaxTaxa || species<0 || species>=MaxTaxa)	{					printf("ERROR 153 - ancestor index out of range at %d and %d\n",species,cumulativediv);					sampled=notu;					exit(0);						}				ancestor[cumulativediv] = species;				anc = species;				++f1[anc];						/*******************************************************************************/		/* Ancestors become pseudo-extinct at bifurcation if that is what is happening */		/*******************************************************************************/				if (SPECIATION==1 && a==1)	{					TE[anc]=TO[cumulativediv]=TO[cumulativediv-1];					}				else	{					/* TO must be after ancestor's TO */					if (TO[anc]>stage)	v=((stage+1)-TO[anc])*1000;					else				v=1000;					b=v;					y = (((unsigned int) rand())%b);					if (TO[anc]<=stage)	TO[cumulativediv]=stage+(y/1000);					else				TO[cumulativediv]=TO[anc]+(y/1000);					}				}			}		if (FOSSILS==0 && standingdiv>=notu-1)	sp = initdiv;	/* quit if enough taxa are alive */		}	/****  End Speciation Round ****/ 				if (FOSSILS==1)	{		/********************************************/		/*				 Do Sampling				*/		/*  Separated from Speciation Loop 1/3/97   */		/********************************************/		if (sampled < notu)	{			for (sp=0; sp<=standingdiv; ++sp)	{				species = extant[sp];								/* Raw Species Number */				find = (((unsigned int) rand())%1000)+1;				if (f1[species]>=3 || cumulativediv>=(3*MaxStanding))	find = 0;				MOD=FREQRAT;				if (sp>=initdiv)				MOD=((stage+1)-TO[species])*MOD;				/* this applies only to ancestors that become pseudo-extinct */				else if (TE[species]<stage+1)	{					/* if anagenetic ancestor appeared before stage */					if (TO[species]<=stage)	MOD=(TE[species]-stage)*MOD;					/* if anagenetic ancestor appeared during stage */					else					MOD=(TE[species]-TO[species])*MOD;					}												if (find <= MOD)	{					newby = 0;					/** First sampled species goes straight into the array **/					if (sampled==0)	{						observed[sampled]=species;						FA[sampled]=LA[sampled]=stage;						++sampled;						}					/** Test whether a sampled species had gone unsampled **/					else	{						for (OTU = 0; OTU < sampled;  ++OTU)	{							if (observed[OTU] == species)	{								newby = 1;								LA[OTU]=stage;								OTU = sampled;								}							}						if (newby == 0 && sampled < notu)	{							/* sort species as you go */							a=sampled-1;							while (observed[a]>species && a>=0)	{								observed[a+1]=observed[a];								FA[a+1]=FA[a];								LA[a+1]=LA[a];								--a;								}							observed[a+1] = species;							FA[a+1]=LA[a+1]=stage;							++sampled;							if (sampled<0 || sampled>notu)	{								printf("ERROR 189: You somehow sampled %d\n",sampled);								exit(0);								}							if (sampled==notu)		sp = standingdiv;							}						}					latest = observed[sampled-1];					}	/* End Tallying of Sampled Horizon	*/				}	/*  End Sampling for Each Horizon	*/			}		}			else {		sampled = standingdiv;		/* if there are no fossils, "present" is when									   notu taxa evolve */		if (sampled==notu-1)	for (sp=0; sp<notu; ++sp)	observed[sp]=extant[sp];		}	if (sampled>=notu)	break;	/* don't bother with the rest if done */				/********************************************/		/*				Do Extinction				*/		/********************************************/	for (a=standingdiv; a>=0; --a)	{		/* sp = extant but not nec. sampled species */		extinct = (((unsigned int) rand())%1000);		MOD=LAMBDA;		sp=extant[a];		if (TE[sp]<(stage+1))	extinct=0;		if (TO[sp]>stage)		MOD=((stage+1)-TO[sp])*MOD;		//		if (f1[extant[sp]]>=3)	extinct = 0;		if (extinct < MOD)	{			/*  REMOVE SPECIES FROM EXTANT LIST */			for (b = a; b <= standingdiv; ++b)	extant[b] = extant[b+1];			extant[standingdiv] = -1;			--standingdiv;			if (sp<-1)	{				printf("ERROR 224 - you have more extinctions than species\n");				exit(0);				}			}		}	/*  End Extinction Simulation */	initdiv=standingdiv;				/****** REBOOT ROUTINE ******/	if (standingdiv < 0/* || (sampled>=1 && observed[0]==0)*/)	{		latest = -1;		for (sp=0; sp<notu; ++sp)	{			extant[sp]=observed[sp]=ancestor[sp]=-1;			TO[sp]=FA[sp]=LA[sp]=f1[sp]=0;			}		standingdiv = initdiv = cumulativediv = extant[0] = sampled = 0;		stage = 0;		++attempts;/*		if ((attempts%5)==0)	printf ("%2d tries and counting.\n",attempts); */		}				/** Reboot simulation **/	else	{		if (sampled < notu)	++stage;		/*  All notu species found	*/		else if (FOSSILS==0 && cumulativediv==((2*notu)-2))	{			for (sp=0; sp<=cumulativediv; ++sp)		MS[sp]=1;			for (sp=0; sp<=standingdiv; ++sp)		observed[sp] = extant[sp];			sampled = notu;			reboot=1;			}		/* if species index is out of range, then reboot the whole thing */		}	}for (a=cumulativediv+1; a<MaxTaxa; ++a)	f1[a]=ancestor[a]=MS[a]=0;if (observed[0]==-1)	{	printf("Taxa lost by line 257\a\n");	exit(0);	}/*********************************************************************************//*								Store True Phylogeny							 *//*********************************************************************************//**** LIST ANCESTORS OF EACH OBSERVED SPECIES ****/chucks=0;for (a=0; a<species; ++a)	if (f1[a]>0)	++chucks;forefathers=imatrix(notu,chucks);for (sp = 0; sp<notu; ++sp)	{	f1[observed[sp]]=0;	for (sp2 = 0; sp2<chucks; ++sp2)	forefathers[sp][sp2] = -1;	}ancestor[0]=-1;species=observed[0];if (species==0)	{	forefathers[0][1] = -1;	forefathers[0][2] = -1;	unsampled[0] = 0;	}else	{	forefathers[0][1] = anc = ancestor[species];	pred = 1;	while (anc>0)	{		anc = ancestor[anc];		++pred;		forefathers[0][pred] = anc;		if (pred>=notu)	{			printf("Hey, taxon %2d has too many predecessors in run X X XX\a\a\n",anc);			for (a=0; a<pred; ++a)	printf("%d\t",forefathers);				exit(0);			}		}	forefathers[0][pred+1]=-1;	unsampled[0] = pred;	}	for (OTU = 1; OTU<notu; ++OTU)	{	sampledanc = 0;	unsampled[OTU] = 0;	species = observed[OTU];	anc = ancestor[species];	for (pred=0; pred<OTU; ++pred)	{	/* Ancestor must be of lower number after sort */		if (observed[pred] == anc)	{			forefathers[OTU][1] = anc;			forefathers[OTU][2] = -1;			sampledanc = 1;			pred = OTU;				/* Terminate Loop if Ancestor is Observed */			++f1[anc];			}		}	pred = 0;	while (sampledanc == 0)	{		++pred;		if (pred>cumulativediv)	{			printf("ERROR 775:  pred = %2d with %3d total for species %1d[%1d] in replication XXX\a\a\n",pred,cumulativediv,OTU,species);			for (a=1; a<=pred; ++a)	{				if ((a%10)==0)	printf("%3d\n",forefathers[OTU][a]);				else			printf("%3d  ",forefathers[OTU][a]);				}			exit(0);		}		sp2 = anc;		anc = ancestor[sp2];		if (sp2 == 0)	{			forefathers[OTU][pred] = 0;			forefathers[OTU][pred+1] = -1;			unsampled[OTU] = pred+1;			sampledanc = 1;			++f1[sp2];			break;			}		forefathers[OTU][pred] = sp2;		for (sp = 0; sp < OTU; ++sp)	{  /* Ancestors must be a lower number after sort */			if (observed[sp] == sp2)	{				sampledanc = 1;				forefathers[OTU][pred+1] = -1;				unsampled[OTU] = pred+1;				sp = OTU;				++f1[sp2];				}			}		}	}/*****  Find Observed Species with Observed Immediate Ancestors *****/grandma = nodes = 0;for (OTU = notu-1; OTU>=1; --OTU)	{	species = observed[OTU];	if (unsampled[OTU] == 0)	{		anc = ancestor[species];		for (b=0; b<OTU; ++b)	{			if (anc == observed[b])	{				grandma = b;				/*  Ancestor Found */				b = OTU;					/*   Stop Search   */				}			}		sampledanc = 0;		for (b=0; b<nodes; ++b)	{			if (grandma == tree[b][1])	{				if (divers[b]==0)	divers[b] = 2;				else				divers[b] = divers[b]+1;				for (c=divers[b]-1; c>=1; --c)	{					if (OTU<tree[b][c])	tree[b][c+1] = tree[b][c];					else	{						tree[b][c+1] = OTU;						c = 1;						}					}				sampledanc = 1;				b = nodes;				}			}		if (sampledanc == 0 && grandma != -1)	{			tree[nodes][1] = grandma;			tree[nodes][divers[nodes]=2] = OTU;			if (nodes>notu || nodes < 0)		printf("ERROR 835 - nodes = %1d\n",nodes);			if (grandma>notu || grandma < 0)	printf("ERROR 836 - grandma = %1d\n",nodes);			commonanc[nodes] = observed[grandma]; /* Use True rather than Observed Number */			++nodes;			}		}	}		/*****  Routine for Species without Observed Immediate Ancestors *****/for (OTU = notu-1; OTU>=1; --OTU)	{	while ((unsampled[OTU]<1) && OTU > 0)	--OTU;	if (OTU<0)								break;	found = 0;	if (OTU==0)	{			/* if OTU 0 is the ultimate ancestor, then set it up at the base	*/		for (clade=0; clade<nodes; ++clade)			if (tree[clade][1]==0 && commonanc[clade]<=0)	found = 1;		if (found==0 && observed[OTU]==0) 	{			for (clade=0; clade<nodes; ++clade)	if (tree[clade][1]==0 && tree[clade][2]==1)	found = 1;			if (found==1)			break;			tree[nodes][1] = 0;			tree[nodes][2] = 1;			divers[nodes] = 2;			for (clade=1; clade<=unsampled[2]; ++clade)	{				sp = forefathers[1][clade];				if (sp == observed[0])	{					commonanc[nodes] = sp;					clade = unsampled[1];					}				else	{					for (c=1; c<=unsampled[0]; ++c)	{						if (sp == forefathers[0][c])	{							commonanc[nodes] = sp;							c = unsampled[0];							clade = unsampled[1];							}						}					}				}			++nodes;			}		/* if it is not, then look for the closest relatives linking the base of the tree	*/		else if (found==0)	{			for (sp=1; sp<notu; ++sp)	{				/* look for something with unsampled ancestors predating OTU	*/				if (unsampled[sp]>0 && forefathers[sp][unsampled[sp]-1]<observed[0])	{					tree[nodes][1]=0;					tree[nodes][divers[nodes]=2]=sp;					commonanc[nodes]=forefathers[sp][unsampled[sp]-1];					++nodes;					}				}			}		}	/* end routine for OTU 0	*/	else	{			/** OTU greater than 0 **/		sampledanc = found = 0;		for (pred=1; pred<=unsampled[OTU]; ++pred)	{			/** pred is the jth ancestor of OTU **/			anc = forefathers[OTU][pred];			sampledanc = 0;			/**** Test One - Is the "Grand"-Ancestor Sampled? ****/			if (pred>1)	{		/* routine for examining grandparent taxa */				for (sp=OTU-1; sp>=0; --sp)	{					/*** sp is possible ancestor ***/					if (anc == observed[sp])	{						/***  ancestor is observed  ***/						for (testnode=0; testnode<nodes; ++testnode)	{							if (anc == commonanc[testnode])	{								ee = 0;								for (d=1; d<=divers[testnode]; ++d)									if (tree[testnode][d]==OTU)	ee = 1;								if (ee==0)	{									++divers[testnode];									for (ee=divers[testnode]-1; ee>=1; --ee)	{										if (tree[testnode][ee]>OTU)											tree[testnode][ee+1] = tree[testnode][ee];										else	{											tree[testnode][ee+1] = OTU;											ee = 1;											}										}									sampledanc = 1;									pred = unsampled[OTU];									sp = 0;									testnode = nodes;									}	/* species isn't already in the node */								}							}						if (sampledanc == 0)	{							if (sp<OTU)	{								tree[nodes][1] = sp;								tree[nodes][divers[nodes]=2] = OTU;								}							else	{								tree[nodes][1] = OTU;								tree[nodes][divers[nodes]=2] = sp;								}							pred = unsampled[OTU];							sp = 0;							sampledanc = 1;							commonanc[nodes] = anc;		/* Label Common Ancestor */							++nodes;							}						}					}				}	/** End Search for sampled Grandparent species */					/*** Test Two - Routine for True Sister Species ***/		/** first examine whether species is the descendant of a known common ancestor 			or a member of an already found clade with an unsampled ancestor **/			if (sampledanc == 0)	{			/** clade is new **/				distance = cumulativediv;				for (OTU2=OTU-1; OTU2>=0; --OTU2)	{    /*** OTU2 might be sister species ***/					for (d=1; d<=unsampled[OTU2]; ++d)	{						if (forefathers[OTU2][d] == anc)	{							if (d <= distance)	{	/* replace with lowest of same distance */								distance = d;		   /* find LCA closest to observed */								sistersp = OTU2;		   /* sistersp used below */								found = 1;								d = unsampled[OTU2];	   /** End Loop Now **/								/*if (distance == 1)	OTU2=1;	*/								}							}						}					}				if (found==1)	{				/* Test for Polytomy by examining all other nodes for common anc */				/*  this should link only clades with unobserved common ancestors */  					for (HTU=0; HTU<nodes; ++HTU)	{						ee = 0;						if (anc == commonanc[HTU])	{							/* look at OTU & sister species;  make sure that OTU hasn't							   already been added to the clade */							for (a=1; a<=2; ++a)	{								if (a==1)	sp3 = OTU;								else		sp3 = sistersp;								for (sp=divers[HTU]; sp>=1; --sp)	{									if ((sp3 < tree[HTU][sp]) && (sp3 > tree[HTU][sp-1]))	{										for (d=divers[HTU]; d>=sp; --d)											tree[HTU][d+1]=tree[HTU][d];										tree[HTU][sp] = sp3;										++divers[HTU];										}									}								}							sampledanc = 1;							pred = unsampled[OTU];	   	/** End Loop Now **/							}						}					if (sampledanc == 0)	{						if (sistersp<OTU)	{							tree[nodes][1] = sistersp;							tree[nodes][divers[nodes]=2] = OTU;							}						else	{							tree[nodes][1] = OTU;							tree[nodes][divers[nodes]=2] = sistersp;							}						sampledanc = 1;						commonanc[nodes] = anc;						pred = unsampled[OTU];	   	/** End Loop Now **/						++nodes;						}					}				}			}		}	}/*** Consolidate any nodes with the same unsampled common ancestor ***/for (testnode=0; testnode<nodes-1; ++testnode)	{	for (clade=testnode+1; clade<nodes; ++clade)	{		if (commonanc[testnode]==commonanc[clade])	{			for (c=1; c<=divers[clade]; ++c)	{				found = 0;				for (d=1; d<=divers[testnode]; ++d)	if (tree[testnode][d]==tree[clade][c])	found = 1;				if (found == 0)	{					++divers[testnode];					tree[testnode][divers[testnode]] = tree[clade][c];					/*** SORT NEW ENTRY ***/					for (d=divers[testnode]; d>1; --d)	{						if (tree[testnode][d] < tree[testnode][d-1])	{							ee = tree[testnode][d];							tree[testnode][d] = tree[testnode][d-1];							tree[testnode][d-1] = ee;							}						}					}				}			for (c=clade; c<nodes-1; ++c)	{				for (d=1; d<=notu; ++d)	{					if (d<=divers[c+1])	tree[c][d] = tree[c+1][d];					else				tree[c][d] = 0;					}				divers[c] = divers[c+1];				commonanc[c] = commonanc[c+1];				}			for (c=1; c<=divers[nodes]; ++c)	tree[nodes][c] = 0;			divers[nodes] = commonanc[nodes] = 0;			--nodes;			clade = nodes;			}		}	}MaxDiv=maxiarray(divers,nodes);	/*****  Sort Clades by Last Common Ancestor	*****/for (testnode=0; testnode<nodes; ++testnode)	{	d=commonanc[c=testnode];	ee=divers[testnode];	for (clade=testnode+1; clade<nodes; ++clade)		if (commonanc[clade] <= d) d=commonanc[c=clade];	if (c != testnode)	{		commonanc[c]=commonanc[testnode];		commonanc[testnode]=d;		divers[testnode] = divers[c];		divers[c] = ee;		for (sp=0; sp<=MaxDiv; ++sp)	{			d=tree[testnode][sp];			tree[testnode][sp]=tree[c][sp];			tree[c][sp]=d;			}		}	}/*** Write Out Whole Tree ***/for (testnode=nodes-1; testnode>0; --testnode)	{	found = 0;	anc = ancestor[commonanc[testnode]];	while (found==0)	{		for (plesion=testnode-1; plesion>=0; --plesion)	{			if (commonanc[plesion]<anc)		plesion = -1;	/* too low, try again */			else if (commonanc[plesion]==anc)	{	/* ancestral clade found */				for (sp=1; sp<=divers[plesion]; ++sp)	{					for (sp2=1; sp2<=divers[testnode]; ++sp2)	{						if (tree[plesion][sp]==tree[testnode][sp2])	{							/* matching member found */							/* replace it with HTU # (testnode+notu) */							a = sp;							while (tree[plesion][a+1]<testnode+notu && a<divers[plesion])	{								tree[plesion][a] = tree[plesion][a+1];								++a;								}							tree[plesion][a] = testnode+notu;							found = 1;							sp2 = divers[testnode];							sp = divers[plesion];							plesion = 0;							}						}					}				if (found==0)	{	/* complex case;  look for species in clades above */					for (sp=1; sp<=divers[plesion]; ++sp)	{						for (a=testnode+1; a<nodes; ++a)	{							for (b=1; b<=divers[a]; ++b)	{								if (tree[a][b]==tree[plesion][sp])	{									/* daughter clade found!! */									c=sp;									while (tree[plesion][c+1]<a+notu && c<divers[plesion])	{										tree[plesion][c] = tree[plesion][c+1];										++c;										}									tree[plesion][c] = testnode+notu;									found = 1;									plesion = 0;									b = divers[a];									a = nodes;									sp = divers[plesion];									}								}							}						}					}				/* must belong in clade somewhere - put it at the end	*/				if (found==0)	{					a = tree[plesion][++divers[plesion]] = testnode+notu;					b = divers[plesion];					found=1;					while(a<tree[plesion][b-1])	{						tree[plesion][b] = tree[plesion][b-1];						tree[plesion][b-1]=a;						--b;						}					}					}			}		if (found==0)	{			anc = ancestor[anc];			if (anc<-1 || anc>=(3*MaxStanding))	{				found=2;				testnode = 0;				}			}		}	}	/* end search of testnodes */							/************************  Determine Branch Lengths  ************************/for (a=0; a<notu; ++a)					TrPD[a] = MS[observed[a]];for (a=notu; a<(notu+nodes); ++a)		TrPD[a] = 0;/***   Species Subsume the Apomorphies of their Unsampled Immediate Ancestors   ***/ for (sp=notu-1; sp>=0; --sp)	{	while ((unsampled[sp] == 0) && sp > 0)	--sp;	if (sp < 1)	break;	found = 0;	for (b=1; b<=unsampled[sp]; ++b)	{		anc = forefathers[sp][b];		for (c=0; c<nodes; ++c)			if (anc == commonanc[c])				found = 1;			/* cease subsuming if ancestor is a common ancestor */									/* common ancestors are added to node lengths below */		if (found == 0)				TrPD[sp] = TrPD[sp]+MS[anc];	/* "unique" ancestor */		/* stop once common ancestor is found */		if (found == 1)				b=unsampled[sp];				/* common ancestor - quit now */		}	}		/***    Replace Apomorphies from 			Ancestors to Branch Lengths    ***/ for (b=0; b<nodes; ++b)	{	anc = tree[b][1];	if (commonanc[b] == observed[anc])	{		grandma = tree[b][1];		TrPD[b+notu] = TrPD[grandma];		TrPD[grandma] = 0;		}	}		/***   Nodes Subsume the Apomorphies of their 				Unsampled Immediate Ancestors   ***/ for (clade=nodes-1; clade>=0; --clade)	{	found = 0;	sp = tree[clade][1];	if (sp<=notu)	{		sp2 = observed[sp];		anc = commonanc[clade];		if (sp2==anc)	grandma=-1;		else	{			anc = commonanc[clade];		/* new 1/23/98 */			grandma = ancestor[anc];			}		}	else	{		anc = commonanc[clade];		grandma = ancestor[anc];		}	while (grandma>=0)	{		TrPD[clade+notu] = MS[anc]+TrPD[clade+notu];		greatgrandma = ancestor[grandma];		for (b=nodes-1; b>=0; --b)	{	/* b is possible sister clade */			found = 0;			if (grandma==commonanc[b])	{ /* grandancestor is common ancestor of clade */				found=1;				b=0;		/* loop no longer needed - kill it */				grandma = -1;				}			}		if (found==0)	{			anc = grandma;			grandma = greatgrandma;			}		}	}for (a=0; a<nodes; ++a)	{	tree[a][0]=divers[a];	}tree[nodes][0]=0;/* add branch lengths to tree  */for (a=0; a<notu; ++a)	tree[notu-1][a]=TrPD[a];for (b=0; b<nodes; ++b)	{	a=notu+b;	tree[notu][b]=TrPD[a];	}for (a=0; a<notu; ++a)	{	tree[notu+1][a]=FA[a];	tree[notu+2][a]=LA[a];	}//tree=CladeMember(tree, notu, nodes);free_ivector(observed);free_ivector(unsampled);free_ivector(commonanc);free_ivector(divers);free_ivector(FA);free_ivector(LA);free_ivector(TrPD);free_ivector(extant);free_ivector(ancestor);free_ivector(available);free_ivector(f1);free_ivector(MS);free_ivector(DBas);	free_dvector(TO);free_dvector(TE);return tree;}/* Returns a matrix for notu taxa with nchars characters.  Gaps and missing are kept in place *//* Requires:   tree - a matrix containing members of each node, with daughter nodes given a number of OTUs+node#;		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[notu-1]) gives it for species;			the second line (tree[notu]) gives it for internal nodes;	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	TTLSTP - the number of changes for the matrix;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************/long **EvolveMatrix(long **tree, int notu, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, int TTLSTP, int UNKNOWN, int INAP){int		a, b, c, d, br, ch, st, sc, DELTAS, MxDel, TtlBr;int		flip, sp, sp2, nodes, used, mxst;int		u, best, close;int		*available, *branches, *unord, *undum, *steps, *TrPD, *apo, *aptaxa;int		**taxachange, **invmatrix, **DescNodes;	/* for debugging */long	**nodestates;/* find the number of nodes and their diversities */mxst=nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}MxDel=0;for (c=0; c<nchars; ++c)	{	if (nstates[c]>mxst)	mxst=nstates[c];	if (maxch[c]>MxDel)		MxDel=maxch[c];	}apo=ivector(nodes+notu);TrPD=ivector(nodes+notu);steps=ivector(nchars);unord=ivector(mxst);undum=ivector(mxst);DescNodes=DescendantNodes(tree,notu);nodestates=lmatrix(nodes,nchars);TrPD[notu]=TtlBr=0;for (sp=0; sp<notu; ++sp)	{	TrPD[sp]=tree[notu-1][sp];		/* array tree[notu-1] gives branch lengths of species */	TtlBr=TtlBr+TrPD[sp];	}for (sp=1; sp<nodes; ++sp)	{	TrPD[sp+notu]=tree[notu][sp];	/* array tree[notu] gives branch lengths of ancestors */	TtlBr=TtlBr+TrPD[sp+notu];	}/* allocate memory for arrays containing branches needing changes */available=ivector(TtlBr);branches=ivector(TtlBr);taxachange=imatrix(nchars, MxDel);	/* gives taxa that change for character */invmatrix=imatrix(nchars, notu);aptaxa=applicabletaxa(matrix, nchars, notu, INAP);/* BEGIN HERE 5/18/01 describe each clade in terms of all species within it *//******* CHARACTER EVOLUTION - REWRITTEN 3/31/01 TO DO TOTAL TREE LENGTH ********/	DELTAS=0;/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */b=0;for (a=1; a<nodes; ++a)	{	for (c=0; c<TrPD[a+notu]; ++c)	{		available[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<TrPD[a]; ++c)	{		available[b]=a;		++b;		}	}	/* clear matrix */for (ch=0; ch<nchars; ++ch)	{	for (a=0; a<notu; ++a)	{		if (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN)	{			matrix[a][ch]=0;			}		invmatrix[ch][a]=matrix[a][ch];	/* for debugging */		}	}/* Step 1: Make sure each state is derived for each character */for (ch=0; (ch<nchars && DELTAS<TTLSTP); ++ch)	{	while (maxch[ch]==0)	++ch;	if (ch>=nchars)			break;	steps[ch]=st=0;	for (a=0; a<MxDel; ++a)		taxachange[ch][a]=-1;			/* make sure that inapplicable characters have at least one taxon that can be changed */	if (aptaxa[ch]<notu)	{		/* count unknowns - these will be put back in later */		u=0;		for (a=0; a<notu; ++a)	if (matrix[a][ch]==UNKNOWN)	++u;		/* now find a node that has similar diversity */		close=RAND_MAX;				/* start from the bottom if most taxa are scored */		if (aptaxa[ch]>(notu/2))	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==(notu-aptaxa[ch]))	{					best=br;					br=nodes;					close=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs((notu-aptaxa[ch])-tree[br][0]);					if (a<close)	{						close=a;						best=br;						}					else if (a==close && tree[br][0]>tree[best][0])	best=br;					}				}			}		/* start from the top otherwise */		else	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==aptaxa[ch])	{					best=br;					br=nodes;					close=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs(aptaxa[ch]-tree[br][0]);					if (a<close)	{						close=a;						best=br;						}					else if (a==close && tree[br][0]>tree[best][0])	best=br;					}				}			}				for (sp=0; sp<notu; ++sp)	{			if (aptaxa[ch]>(notu/2))	matrix[sp][ch]=0;			else						matrix[sp][ch]=INAP;			}		for (a=1; a<tree[best][0]; ++a)	{			sp=tree[best][a];			matrix[sp][a]=0;			}		}	/* end initial creation of inapplicable character */		/* make autapomorphic characters change on one species only */	/* invariants do not change at all */	for (ch=ch; maxch[ch]<=1; ++ch)	{		/* skip invariants and make autapomorphies autapomorphic */		if	(maxch[ch]==1)	{/*			sp=((int) (notu * rand() / RAND_MAX));*/			c=a=0;			clearivector(branches,TtlBr,0);			for (sp=0; sp<notu; ++sp)	if (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP)	{				branches[a]=sp;				++a;				if (TrPD[sp]>0)	++c;				}			/* if only cells belong to species with 0 length branches */			if (c==0)	{				sp=branches[0];				while (TrPD[sp]==0)	{					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);					}				b=(int)((double)rand() / ((double)RAND_MAX + 1) * a);				d=branches[b];				invmatrix[ch][d]=matrix[d][ch]==INAP;				invmatrix[ch][sp]=matrix[sp][ch]=1;				taxachange[ch][0]=sp;				}			else	{				sp=branches[b];				while (TrPD[sp]==0 || (matrix[sp][ch]==UNKNOWN || matrix[sp][ch]==INAP))	{					b=(int)((double)rand() / ((double)RAND_MAX + 1) * a);					sp=branches[b];					}				matrix[sp][ch]=1;				invmatrix[ch][a]=taxachange[ch][0]=sp;				}			steps[ch]=1;			++DELTAS;			st=1;			++apo[sp];			}		}	/* this should leave us with a character that needs to be changed OR out of characters */	if (ch>=nchars)	break;			used=0;	/* this tells how many branches are discarded; used > steps IF there are absents */	/* branch length is taken into account by TrPD */	for (sp=0; sp<TtlBr; ++sp)		branches[sp]=available[sp];		/* Binary && unordered multistate is Easy */		/* for normal character, have it change until all X states are realized */		/*	while (st<(nstates[ch]-1))	{	*/	if (nstates[ch]==2 || ctype[ch]==1)	{		for (st=0; st<nstates[ch]-1; st=st)	{			/* There are TtlBr-used branches that could change *///			br = ((int) ((TtlBr-used) * rand() / RAND_MAX));			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (TtlBr-used));			sp = branches[br];						/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (TrPD[sp]==0 || br>=(TtlBr-used))	{//				br = ((int) ((TtlBr-used) * rand() / RAND_MAX));				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (TtlBr-used));				sp = branches[br];				}			taxachange[ch][steps[ch]]=sp;			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				st=invmatrix[ch][sp]=matrix[sp][ch]=st+1;				++apo[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++DELTAS;				}			else if (sp>notu)	{				b=0;				for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					/* only change if the state is 0 */					if (matrix[sp2][ch]==0 && sp2<notu)	{						invmatrix[ch][sp2]=matrix[sp2][ch]=st+1;						b=1;						}					}				if (b==1)	{					++apo[sp];					taxachange[ch][steps[ch]]=sp;					++steps[ch];					++DELTAS;					++st;					}				}			used=used+TrPD[sp];			/* remove branches from possible change list (but only if more changes must be made)*/			if (steps[ch]<(nstates[ch]-1))	{				for (a=0; a<TtlBr; ++a)	{					if (branches[a]==sp)	{						for (b=a; b<TtlBr-used; ++b)	branches[b]=branches[b+TrPD[sp]];						branches[TtlBr-used]=-1;						a=TtlBr;						}					}				}	/* end elimination of used branches */							if (used<steps[ch])	{				printf("ERROR LINE 954 - there are more changes than deleted branches for Ch%dÉ\n",ch+1);				}							}	/*end derivation of state */		}	/* end loop for binary / unordered characters */		/* Ordered Multistates are tougher */	else if (nstates[ch]>2 && ctype[ch]==0)	{		used=0;		for (st=0; (st<nstates[ch]-1 && steps[ch]<MxDel); st=st)	{			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (TtlBr-used));			sp=branches[br];			/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (TrPD[sp]==0 || br>=(TtlBr-used))	{/*				br = ((int) ((TtlBr-used) * rand() / RAND_MAX));*/				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (TtlBr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				matrix[sp][ch]=multi(matrix[sp][ch],nstates[ch],bias[ch]);				if (matrix[sp][ch]<0)	{					for (c=0; c<notu; ++c)	{						if (matrix[c][ch]!=UNKNOWN && matrix[c][ch]!=INAP)	{							++matrix[c][ch];							++invmatrix[ch][c];	/* for debugging */							}						}					}								taxachange[ch][steps[ch]]=sp;				++steps[ch];				++apo[sp];				++DELTAS;				invmatrix[ch][sp]=matrix[sp][ch];	/* for debugging */				}							else if (sp>notu)	{				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])	flip=1;				else				flip=-1;				for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					b=0;					if (matrix[sp2][ch]!=INAP && matrix[sp2][ch]!=UNKNOWN)	{						matrix[sp2][ch]=matrix[sp2][ch]+flip;						if (matrix[sp2][ch]>=nstates[ch])	matrix[sp2][ch]=nstates[ch]-2;						/* if -1 evolves, move everything so -1->0, 0->1, etc. */						else if (matrix[sp2][ch]<0)	{							for (c=0; c<notu; ++c)								if (matrix[c][ch]!=UNKNOWN && matrix[c][ch]!=INAP)	{									++matrix[c][ch];									++invmatrix[ch][c];	/* for debugging */									}							}						b=1;						invmatrix[ch][sp2]=matrix[sp2][ch];	/* for debugging */						}					}				/* if there was a change, then tally it */				if (b==1)	{					taxachange[ch][steps[ch]]=sp;					++steps[ch];					++apo[sp];					++DELTAS;					}				}			/* check if all states have been derived */			/* note: this is needed only for ordered multistates */			if (steps[ch]>=nstates[ch]-1)	{				for(a=0; a<notu; ++a)	{					if (matrix[a][ch]>st && (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN))						st=matrix[a][ch];					}				}			used=used+TrPD[sp];			/* remove branches from possible change list (but only if more changes must be made)*/			if (st<(nstates[ch]-1))	{				for (a=0; a<TtlBr; ++a)	{					if (branches[a]==sp)	{						for (b=a; b<TtlBr-used; ++b)	branches[b]=branches[b+TrPD[sp]];						branches[TtlBr-used]=0;						a=TtlBr;						}					}				}	/* end extraction of changed branches */			if (used<steps[ch])	{				printf("ERROR LINE 1036 - there are more changes than deleted branches for Ch%dÉ\n",ch+1);				}			}		}	/* end loop for ordered multistates */	}	/* end derivation of all character states *//* Step #2: make sure that each apomorphic species has a derivation */for (sp=0; (sp<notu+nodes && DELTAS<TTLSTP); ++sp)	{	if (apo[sp]==0 && TrPD[sp]>0)	{		while (apo[sp]==0)	{/*			ch = ((int) (nchars * rand() / RAND_MAX));*/			ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));			while ((ch>=nchars || ch<0) || steps[ch]>=maxch[ch])				ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));/*				ch = ((int) (nchars * rand() / RAND_MAX));	*/						if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				if (nstates[ch]==2)						invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);				else if (ctype[ch]==1)					invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);				else if (ctype[ch]==0)					invmatrix[ch][sp]=matrix[sp][ch]=multi(matrix[sp][ch],nstates[ch],bias[ch]);								/* make sure no negative numbers are kept! */				if (matrix[sp][ch]<0)	invmatrix[ch][sp]=matrix[sp][ch]=1;									taxachange[ch][steps[ch]]=sp;				++steps[ch];				apo[sp]=1;				++DELTAS;				}						else if (sp>notu)	{				/* flip is used only for multistates */				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])	flip=1;				else				flip=-1;								/* make sure that not all descendants have already changed! */				b=d=0;				for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;					else	{						for (c=0; c<steps[ch]; ++c)	{							if (taxachange[ch][c]==sp2)	{								++d;								c=steps[ch];								}							}						}					}				/* if d is less than clade diversity, then proceed with change */				if (d<tree[sp-notu][0])	{					/* if character is an unordered multistate, then we need an array	*/					/* that tells how each state changed withing the clade				*/					if (ctype[ch]==1 && nstates[ch]>2)	{						/* create an array showing into which state each state will transform */						for (a=0; a<nstates[ch]; ++a)	undum[a]=a;												/* now come up with new transitions for this clade */						for (a=0; a<nstates[ch]; ++a)	{/*							b = ((int) ((nstates[ch]-a) * rand() / RAND_MAX));	*/							b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[ch]-a));							unord[a]=undum[b];							/* do not let unord[a]==a */							while (unord[a]==a || a>=nstates[ch])	{/*								b = ((int) ((nstates[ch]-a) * rand() / RAND_MAX));	*/								b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[ch]-a));								unord[a]=undum[b];								}							/* unord[0] cannot be a (otherwise we wouldn't have this problem */							/* therefore, flip-flop unord[0] and unord[a] */							if (unord[a]==a && a==(nstates[ch]-1))	{								unord[a]=unord[0];								unord[0]=a;								}															/* remove assigned state from possibilities */							for (c=b; c<nstates[ch]; ++c)								undum[c]=undum[c+1];							/* reboot if the final possible state matches original */							if (a==(nstates[ch]-2) && (a+1)==undum[0])	{								a=-1;	/* will increment to 0*/								for (b=0; b<nstates[ch]; ++b)	undum[b]=b;								}							}						}					b=0;					for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{						sp2=tree[sp-notu][sc];												if (matrix[sp2][ch]!=UNKNOWN && matrix[sp2][ch]!=INAP)	{							b=1;							if (nstates[ch]==2)									invmatrix[ch][sp2]=matrix[sp2][ch]=swap(matrix[sp2][ch]);							/* routine for ordered multistate characters */								else if (ctype[ch]==0)	{								invmatrix[ch][sp2]=matrix[sp2][ch]=matrix[sp2][ch]+flip;								if (matrix[sp2][ch]==-1)				invmatrix[ch][sp2]=matrix[sp2][ch]=1;								else if (matrix[sp2][ch]>=nstates[ch])	invmatrix[ch][sp2]=matrix[sp2][ch]=nstates[ch]-2;								}							else if (ctype[ch]==1)	{								c=matrix[sp2][ch];								invmatrix[ch][sp2]=matrix[sp2][ch]=unord[c];								}							}						}	/* end changing of descendant states */					}	/* end conditional loop */				if (b==1)	{					taxachange[ch][steps[ch]]=sp;					++steps[ch];					apo[sp]=1;					++DELTAS;					}	/* add changes if there actually was a change */				}			}					}	}	/* end derivation for each apomorphic branch *//* Step #3: DO ADDITIONAL STEPS NOW */for (DELTAS=DELTAS; DELTAS < TTLSTP; DELTAS=DELTAS)	{/*	for (a=0; a<notu; ++a)		invmatrix[ch][a]=matrix[a][ch];	/* first choose a character *//*	ch = ((int) (nchars * rand() / RAND_MAX));	*/	ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	while ((ch>=nchars || ch<0) || steps[ch]>=maxch[ch])			ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	/********/	/* do not change the character on a branch where it already has changed */	for (br=0; br<TtlBr; ++br)	branches[br]=available[br];		used=0;	/* used will tally the number of deleted branches */	for (d=0; d<steps[ch]; ++d)	{		for (c=0; c<(TtlBr-used); ++c)	{			/* if branch with change is found, delete it from possible changes */			if (branches[c]==taxachange[ch][d])	{				for (a=c; a<TtlBr-1; ++a)	branches[a]=branches[a+1];				/* some taxa will be in 2+ times - step back to delete them all */				--c;				branches[TtlBr-(used+1)]=-1;				++used;				}			}		}	/* choose a branch from one available */	/* used will be equal to or greater than steps[ch] (due to long branches) *//*	br = ((int) ((TtlBr-used) * rand() / RAND_MAX));	*/	br=(int)((double)rand() / ((double)RAND_MAX + 1) * (TtlBr-used));	sp = branches[br];	/* this shouldn't be necessary, but occassionaly the random number generator */	/* produces a number outside of the proscribed limits */	while (TrPD[sp]==0 || br>=(TtlBr-used))	{/*		br = ((int) ((TtlBr-used) * rand() / RAND_MAX));	*/		br=(int)((double)rand() / ((double)RAND_MAX + 1) * (TtlBr-used));		sp = branches[br];		}	if (nstates[ch]==2)	{		/* routine for binary characters */		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);			++DELTAS;			taxachange[ch][steps[ch]]=sp;			++steps[ch];			}		else if (sp>=notu)	{			b=0;			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				invmatrix[ch][sp2]=matrix[sp2][ch]=swap(matrix[sp2][ch]);				if (matrix[sp2][ch]==0 || matrix[sp2][ch]==1)	b=1;				}			/* if there has been a change, note it */			if (b==1)	{				++DELTAS;				taxachange[ch][steps[ch]]=sp;				++steps[ch];				}			}		}	/* Ordered Multistates */	/* routine to ensure no sub-zero values modified 4/2002 */	else if (ctype[ch]==0)	{		flip = ((int) (100 * rand() / RAND_MAX));		if (flip<bias[ch])						flip=1;		else									flip=-1;				if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp][ch]+flip;			if (matrix[sp][ch]>=nstates[ch])	invmatrix[ch][sp]=matrix[sp][ch]=nstates[ch]-2;			else if (matrix[sp][ch]<0)			invmatrix[ch][sp]=matrix[sp][ch]=1;			++DELTAS;			taxachange[ch][steps[ch]]=sp;			++steps[ch];			}				else if (sp>=notu)	{			/* make sure that not all descendants have already changed! */			b=d=0;			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;				else	{					for (c=0; c<steps[ch]; ++c)	{						if (taxachange[ch][c]==sp2)	{							++d;							c=steps[ch];							}						}					}				}			if (d<tree[sp-notu][0])	{				for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (matrix[sp2][ch]!=UNKNOWN && matrix[sp2][ch]!=INAP)	{						b=1;						invmatrix[ch][sp2]=matrix[sp2][ch]=matrix[sp2][ch]+flip;						if (matrix[sp2][ch]>=nstates[ch])	invmatrix[ch][sp2]=matrix[sp2][ch]=nstates[ch]-2;						else if (matrix[sp2][ch]<0)			invmatrix[ch][sp2]=matrix[sp2][ch]=1;						}					}				}			/* if there has been a change, note it */			if (b==1)	{				++DELTAS;				taxachange[ch][steps[ch]]=sp;				++steps[ch];				}			}	/* end routine for clade */		}	/** END ROUTINE FOR ORDERED MULTISTATES **/	/* Unordered Multistate Characters */	else if (ctype[ch]==1)	{		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);			++DELTAS;			taxachange[ch][steps[ch]]=sp;			++steps[ch];			}					else if (sp>notu)	{			/* create an array showing into which state each state will transform */			for (a=0; a<nstates[ch]; ++a)	undum[a]=a;						/* now come up with new transitions for this clade */			for (a=0; a<nstates[ch]; ++a)	{				b = (int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[ch]-a));				unord[a]=undum[b];				/* do not let unord[a]==a */				while (unord[a]==a || a>=nstates[ch])	{/*					b = ((int) ((nstates[ch]-a) * rand() / RAND_MAX));	*/					b = (int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[ch]-a));					unord[a]=undum[b];					}				/* unord[0] cannot be a (otherwise we wouldn't have this problem */				/* therefore, flip-flop unord[0] and unord[a] */				if (unord[a]==a && a==(nstates[ch]-1))	{					unord[a]=unord[0];					unord[0]=a;					}									/* remove assigned state from possibilities */				for (c=b; c<nstates[ch]; ++c)					undum[c]=undum[c+1];				/* reboot if the final possible state matches original */				if (a==(nstates[ch]-2) && (a+1)==undum[0])	{					a=-1;	/* will increment to 0*/					for (b=0; b<nstates[ch]; ++b)	undum[b]=b;					}				}			b=0;			/* now, go through each member of the clade and shift states in particular way */			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				if (matrix[sp2][ch]!=INAP && matrix[sp2][ch]!=UNKNOWN)	{					c=matrix[sp2][ch];					invmatrix[ch][sp2]=matrix[sp2][ch]=unord[c];					b=1;					}				}			/* if change is made, tally */			if (b==1)	{				++DELTAS;				taxachange[ch][steps[ch]]=sp;				++steps[ch];				}			}	/* end unordered change for a clade */		}	/* end unordered change */	}	/* end additional steps */free_ivector(apo);free_ivector(TrPD);free_ivector(steps);free_ivector(available);free_ivector(branches);free_ivector(unord);free_ivector(undum);free_ivector(aptaxa);free_imatrix(DescNodes,nodes,nodes);free_imatrix(taxachange,nchars,MxDel);free_imatrix(invmatrix,nchars, notu);free_lmatrix(nodestates,notu,nchars);return matrix;}/* Evolves a single character given a rate, a tree and a matrix, leaving the rest of the matrix in tact/* Returns a matrix for notu taxa with nchars characters.  Gaps and missing are kept in place./* Requires:	CH - the character in question.	PI - the per branch rate of character change (a real number).	tree - a matrix containing members of each node (with ALL species belonging to the clade);		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[notu-1]) gives it for species;			the second line (tree[notu]) gives it for internal nodes;	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************/long **EvolveCharacterRate(int CH, double PI, long **tree, int notu, long **matrix, int *nstates, int *ctype, int *bias, int UNKNOWN, int INAP){int		a, b, c, d, st, sc, TtlBr;int		flip, sp, sp2, nodes, branches;int		*available, *unord, *undum, *TrPD, *change;long	*character;/* find the number of nodes and their diversities */nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}/* allocate memory for branch lengths */TrPD=ivector(nodes+notu);/* allocate memory for arrays to be used for unordered multistates */unord=ivector(nstates[CH]);undum=ivector(nstates[CH]);TrPD[notu]=TtlBr=0;for (sp=0; sp<notu; ++sp)	{	TrPD[sp]=tree[notu-1][sp];		/* array tree[notu-1] gives branch lengths of species */	TtlBr=TtlBr+TrPD[sp];	}for (sp=1; sp<nodes; ++sp)	{	TrPD[sp+notu]=tree[notu][sp];	/* array tree[notu] gives branch lengths of ancestors */	TtlBr=TtlBr+TrPD[sp+notu];	}/* allocate memory for arrays containing branches needing changes */available=ivector(TtlBr);/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */b=0;for (a=1; a<nodes; ++a)	{	for (c=0; c<TrPD[a+notu]; ++c)	{		available[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<TrPD[a]; ++c)	{		available[b]=a;		++b;		}	}/* allocate memory for branches that do change */change=ivector(b);branches=0;for (a=0; a<b; ++a)	{	c=(int)((double)rand() / ((double)RAND_MAX + 1) * 10000);	if (c<(PI*10000))	{		change[branches]=available[a];		++branches;		}	}/* allocate character array and clear it */character=lvector(notu);for (a=0; a<notu; ++a)	{	if (matrix[a][CH]!=INAP && matrix[a][CH]!=UNKNOWN)	{		character[a]=0;		}	else	character[a]=matrix[a][CH];	}/* now, make changes */for (d=0; d<branches; ++d)	{	sp=change[d];	/* routine for binary characters */	if (nstates[CH]==2)	{		/* routine for species */		if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{			if (character[sp]==0)	character[sp]=1;			else					character[sp]=0;			}	/* end binary change for species */		/* routine for clade */		else	{			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))	{					if (character[sp]==0)	character[sp2]=1;					else					character[sp2]=0;					}				}	/* end binary change for species within clade */			}	/* end binary change for clade */		}	/* end routine for binary characters */			/** routine for unordered multistate **/	else if (ctype[CH]==1)	{		/* routine for species */		if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{			for (b=character[sp]; b==character[sp]; b=b)	{				b=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates[CH]);				}			character[sp]=b;			}	/* end unordered multistate change for species */		/* routine for clade */		else	{			/* first create an array stating which states change to which 	*/			for (a=0; a<nstates[CH]; ++a)	undum[a]=0;			/* now come up with new transitions for this clade 				*/			for (a=0; a<nstates[CH]; ++a)	{				b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[CH]-a));				unord[a]=undum[b];				/* do not let unord[a]==a */				while (unord[a]==a || a>=nstates[CH])	{					b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[CH]-a));					unord[a]=undum[b];					}				/* unord[0] cannot be a (otherwise we wouldn't have this problem */				/* therefore, flip-flop unord[0] and unord[a] */				if (unord[a]==a && a==(nstates[CH]-1))	{					unord[a]=unord[0];					unord[0]=a;					}									/* remove assigned state from possibilities */				for (c=b; c<nstates[CH]; ++c)					undum[c]=undum[c+1];				/* reboot if the final possible state matches original */				if (a==(nstates[CH]-2) && (a+1)==undum[0])	{					a=-1;	/* will increment to 0*/					for (b=0; b<nstates[CH]; ++b)	undum[b]=b;					}				}	/* end assignment of state changes */						/* now make changes */			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))					character[sp2]=unord[character[sp2]];				}	/* end unordered multistate change for species within clade */			}	/* end unordered multistate change within clade */		}	/* end routine for unordered multistate characters */			/** routine for ordered multistate **/	else if (ctype[CH]==0)	{		/* determine whether state increases or decreases */		for (flip=-1; flip<0 || flip>99; flip=flip)	{			flip=(int)((double)rand() / ((double)RAND_MAX + 1) * 100);			}		if (flip<bias[CH])	flip=1;		else				flip=-1;		/* routine for species */		if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{			character[sp]=character[sp]+flip;			}	/* end ordered multistate change for species */		/* routine for clade */		else	{			/* now make changes */			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))					character[sp2]=character[sp2]+flip;				}	/* end ordered multistate change for species within clade */			}	/* end ordered multistate change within clade */				/* Now, make sure that the lowest value is 0, not -1 or 1 */		st=nstates[CH];		for (a=0; a<notu; ++a) {			if (character[a]<st)	st=character[a];			}		if (st!=0)	{			for (a=0; a<notu; ++a) {				character[a]=character[a]-st;				}			}		}	/* end routine for ordered multistate characters */	}for (sp=0; sp<notu; ++sp)	matrix[sp][CH]=character[sp];free_ivector(TrPD);free_ivector(available);free_ivector(unord);free_ivector(undum);free_ivector(change);free_lvector(character);return matrix;}/* Evolves a single character given a number of stpes, a tree and a matrix, leaving the rest of the matrix in tact/* Returns a matrix for notu taxa with nchars characters.  Gaps and missing are kept in place./* Requires:	CH - the character in question.	PI - the per branch rate of character change (a real number).	tree - a matrix containing members of each node (with ALL species belonging to the clade);		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[notu-1]) gives it for species;			the second line (tree[notu]) gives it for internal nodes;	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************/long **EvolveCharacterSteps(int CH, int PI, long **tree, int notu, long **matrix, int *nstates, int *ctype, int *bias, int UNKNOWN, int INAP){int		a, b, c, d, st, sc, TtlBr;int		flip, sp, sp2, nodes, branches;int		*available, *unord, *undum, *TrPD, *change;long	*character;/* find the number of nodes and their diversities */nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}/* allocate memory for branch lengths */TrPD=ivector(nodes+notu);/* allocate memory for arrays to be used for unordered multistates */unord=ivector(nstates[CH]);undum=ivector(nstates[CH]);TrPD[notu]=0;for (sp=0; sp<notu; ++sp)	{	TrPD[sp]=tree[notu-1][sp];		/* array tree[notu-1] gives branch lengths of species */	}for (sp=1; sp<nodes; ++sp)	{	TrPD[sp+notu]=tree[notu][sp];	/* array tree[notu] gives branch lengths of ancestors */	}/* allocate memory for arrays containing branches needing changes */TtlBr=branchnumber(tree,notu);available=ivector(TtlBr);/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */b=0;for (a=1; a<nodes; ++a)	{	for (c=0; c<TrPD[a+notu]; ++c)	{		available[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<TrPD[a]; ++c)	{		available[b]=a;		++b;		}	}/* allocate memory for branches that do change */change=ivector(PI);branches=0;for (a=0; a<PI; ++a)	{	c=(int)((double)rand() / ((double)RAND_MAX + 1) * (TtlBr-a));	change[branches]=available[c];	++branches;	}/* allocate character array and clear it */character=lvector(notu);for (a=0; a<notu; ++a)	{	if (matrix[a][CH]!=INAP && matrix[a][CH]!=UNKNOWN)	{		character[a]=0;		}	else	character[a]=matrix[a][CH];	}/* now, make changes */for (d=0; d<PI; ++d)	{	sp=change[d];	/* routine for binary characters */	if (nstates[CH]==2)	{		/* routine for species */		if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{			character[sp]=swap(character[sp]);			}	/* end binary change for species */		/* routine for clade */		else	{			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))	{					character[sp2]=swap(character[sp2]);					}				}	/* end binary change for species within clade */			}	/* end binary change for clade */		}	/* end routine for binary characters */			/** routine for unordered multistate **/	else if (ctype[CH]==1)	{		/* routine for species */		if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{			for (b=character[sp]; b==character[sp]; b=b)				b=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates[CH]);			character[sp]=b;			}	/* end unordered multistate change for species */		/* routine for clade */		else	{			/* first create an array stating which states change to which 	*/			for (a=0; a<nstates[CH]; ++a)	undum[a]=a;			/* now come up with new transitions for this clade 				*/			for (a=0; a<nstates[CH]; ++a)	{				b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[CH]-a));				unord[a]=undum[b];				/* do not let unord[a]==a */				while (unord[a]==a || a>=nstates[CH])	{					b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[CH]-a));					unord[a]=undum[b];					}				/* unord[0] cannot be a (otherwise we wouldn't have this problem */				/* therefore, flip-flop unord[0] and unord[a] */				if (unord[a]==a && a==(nstates[CH]-1))	{					unord[a]=unord[0];					unord[0]=a;					}									/* remove assigned state from possibilities */				for (c=b; c<nstates[CH]; ++c)					undum[c]=undum[c+1];				/* reboot if the final possible state matches original */				if (a==(nstates[CH]-2) && (a+1)==undum[0])	{					a=-1;	/* will increment to 0*/					for (b=0; b<nstates[CH]; ++b)	undum[b]=b;					}				}	/* end assignment of state changes */						/* now make changes */			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))					character[sp2]=unord[character[sp2]];				}	/* end unordered multistate change for species within clade */			}	/* end unordered multistate change within clade */		}	/* end routine for unordered multistate characters */			/** routine for ordered multistate **/	else if (ctype[CH]==0)	{		/* determine whether state increases or decreases */		for (flip=-1; flip<0 || flip>99; flip=flip)	{			flip=(int)((double)rand() / ((double)RAND_MAX + 1) * 100);			}		if (flip<bias[CH])	flip=1;		else				flip=-1;		/* routine for species */		if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{			character[sp]=character[sp]+flip;			}	/* end ordered multistate change for species */		/* routine for clade */		else	{			/* now make changes */			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))					character[sp2]=character[sp2]+flip;				}	/* end ordered multistate change for species within clade */			}	/* end ordered multistate change within clade */				/* Now, make sure that the lowest value is 0, not -1 or 1 */		st=nstates[CH];		for (a=0; a<notu; ++a) {			if (character[a]<st)	st=character[a];			}		if (st!=0)	{			for (a=0; a<notu; ++a) {				character[a]=character[a]-st;				}			}		}	/* end routine for ordered multistate characters */	}for (sp=0; sp<notu; ++sp)	matrix[sp][CH]=character[sp];free_ivector(TrPD);free_ivector(available);free_ivector(unord);free_ivector(undum);free_ivector(change);free_lvector(character);return matrix;}/* Initialize and return an array giving the maximum changes per character. *//* Requires:	matrix - character matrix	nchars - number of characters	notu - number of taxa;	nstates - number of states per character;*******************************************************************************************************************************************/int *MaximumChanges(long **matrix, int *minst, int nchars, int notu, int *nstates, int INAP, int UNKNOWN){int	c, s, t, ch, max;int *maxchanges;maxchanges=(int *)malloc(nchars*sizeof(int));/*	Determine the maximum number of changes per character	*/for (c=0; c<nchars; ++c)	{	max=0;	maxchanges[c]=notu;	for (t=0; t<notu; ++t)	if (matrix[t][c]==INAP || matrix[t][c]==UNKNOWN)	--maxchanges[c];	for (s=minst[c]; s<=minst[c]+nstates[c]; ++s)	{		ch=0;		for (t=0; t<notu; ++t)			if (matrix[t][c]==s)	++ch;		if (ch>max)	max=ch;		if (max>=(notu/2))	s=minst[c]+nstates[c];		}	maxchanges[c]=maxchanges[c]-max;	}return maxchanges;}/* Turns 0 to 1 and 1 to 0; leaves anything else (? or -, hopefully) alone./* Requires:/*	c - the number to swap;/* Returns:/*	c - the new number.*******************************************************************************************************************************************/long swap(long c){if (c==0)		c=1;else if (c==1)	c=0;return c;}/* Turns c to any number from 0 to X (unordered character change)/* Requires:	c - the number to swap;	X - the number of states;*******************************************************************************************************************************************/long mswap(long c, int X){int	i;/*i=((int) ((X-1) * rand() / RAND_MAX));	*/i = (int)((double)rand() / ((double)RAND_MAX + 1) * (X-1));if (i>=c && i<(X-1))	++i;else if (i==(X-1))		i=0;c=i;return c;}/* Turns c to c-1 or c+1 (ordered character change)/* Requires:	c - the number to swap;	X - the number of states;	bias - bias increase/decrease;	this can return -1, so make sure you either want that OR can correct for it!*******************************************************************************************************************************************/long multi(long c,int X, int bias){int	i;if (c==(X-1))	--c;else	{	i=((int) (100 * rand() / RAND_MAX));	if (i<bias)	++c;	else		--c;	}return c;}/* Create a cladistic phylogeny, with no extinction/* Requires:	notu: number of taxa;	tree; the matrix of phylogenetic information;/* Each tree[x][0] gives the number of species in that node;/* Each tree[x][1]..tree[x][i] gives species 1...i in that node, with numbers >=notu being nodes.		Thus, taxon notu is the basal node./* tree[notu-1][0Énotu] gives the branch length of each observed taxon /* tree[notu][0Énotu] gives the branch length of each ancestral taxon*******************************************************************************************************************************************/long **EvolveCladogram(int notu, long **tree){int	a, b, c, sp, nodes;tree[nodes=0][0]=2;tree[nodes][1]=0;tree[nodes][2]=1;for (sp=2; sp<notu; ++sp)	{	a = (int)((double)rand() / ((double)RAND_MAX + 1) * sp);	for (b=0; b<=nodes; ++b)	{		for (c=1; c<=tree[b][0]; ++c)	{			if (a==tree[b][c])	{				++nodes;				tree[b][c]=nodes+notu;				c=tree[nodes][0]=2;				tree[nodes][1]=a;				tree[nodes][2]=sp;				b=nodes;				}			}		}	}for (sp=0; sp<notu; ++sp)	tree[notu-1][sp]=1;for (sp=0; sp<nodes; ++sp)	tree[notu][sp]=1;return tree;}double MinRate(int notu){int	a;double	x, R;x=5*notu;R=1/x;x=1000*R;a=x;x=a;R=x/1000;return R;}double MaxRate(int notu, int MXST){int	a;double	x, y, R;y=3*MXST;x=5*notu;R=y/x;x=1000*R;a=x;x=a;R=x/1000;return R;}/* Routine to count the number of non-zero length branches on a simulated tree/*/*	tree: phylogeny/*	notu: number of species*******************************************************************************************************************************************/int branchnumber(long **tree, int notu){int	sp,nodes,TtlBr;/* find the number of nodes and their diversities */nodes=0;for (sp=0; sp<notu; ++sp)	{	if (tree[sp][0]>1)	++nodes;	else				sp=notu;	}/* find the number of non-zero length branches */TtlBr=0;for (sp=0; sp<notu; ++sp)	{	TtlBr=TtlBr+tree[notu-1][sp];	/* array tree[notu-1] gives branch lengths of species */	}for (sp=1; sp<nodes; ++sp)	{	TtlBr=TtlBr+tree[notu][sp];		/* array tree[notu] gives branch lengths of ancestors */	}return TtlBr;}/* EvolveAdditiveDependent - a routine for evolving a dependent color (e.g., feather color) given an independent/*		character (e.g., feathers present) by first evolving a dependent character with as many "presents"/*		as there are taxa for which the dependent character is applicable/* Requires:/*		CH - the characer number/*		PI - number of changes (NOTE: this can be Zero!/*		tree - matrix[i][j] gives the jth member of the ith node/*		notu - number of observed taxa/*		matrix - character state for taxon i, character j/*		nstates - number of states for character k/*		ctype - type (ordered, unordered) for charcter k/*		bias - biased transition for character k/*		UNKNOWN - matrix code for "?"/*		APS - number of otus for which character CH is applicable/* Returns:/*		matrix - original matrix with new character modified.  /************************************************************************************************************/long **EvolveAdditiveDependent(int CH, int PI, long **tree, int notu, long **matrix, int *nstates, int *ctype, int *bias, int UNKNOWN, int INAP, int APS){int		a, b, c, d, der, st, sc, br, TtlBr, TtlAp, delta;int		flip, sp, sp2, nodes, used;int		*available, *branches, *unord, *undum, *TrPD, *change, *derivation, **DescNodes;long	*character, *independent, *nodestate, *nodedepnd;/* evolve an independent character that will yield the same number of dependents as real data */nodes=number_of_nodes(tree,notu);TrPD=ivector(notu+nodes);for (sp=0; sp<notu; ++sp)	{	TrPD[sp]=tree[notu-1][sp];		/* array tree[notu-1] gives branch lengths of species */	}for (sp=1; sp<nodes; ++sp)	{	TrPD[sp+notu]=tree[notu][sp];	/* array tree[notu] gives branch lengths of ancestors	*/	}TtlBr=0;for (sp=0; sp<(notu+nodes); ++sp)	TtlBr=TtlBr+TrPD[sp];available=ivector(TtlBr);branches=ivector(TtlBr);independent=lvector(notu);nodestate=lvector(nodes);nodedepnd=lvector(nodes);DescNodes=DescendantNodes(tree,notu);character=lvector(notu);/* allocate memory for arrays to be used for unordered multistates */unord=ivector(nstates[CH]);undum=ivector(nstates[CH]);/* determine how many branches are available for each taxon and node */a=0;for (sp=0; sp<nodes; ++sp)	{	for (b=0; b<TrPD[sp+notu]; ++b)	{		branches[a]=available[a]=sp+notu;		++a;		}	}	for (sp=0; sp<notu; ++sp)	{	for (b=0; b<TrPD[sp]; ++b)	{		branches[a]=available[a]=sp;		++a;		}	}	derivation=ivector(APS);change=ivector(APS);/* Now, sample from available until APS is reached 						*//* first we will do this with no changes for the dependent character 	*//* a is the number of species changed (reversals, too 					*/delta=used=a=0;for (a=0; a!=APS; a=a)	{	/* if one short, grab a species at random until one can gain in parallel */	if (a==APS-1)	{		b=0;		sp=notu;		/* put something in here to make sure that it does not get stuck */		d=0;		while ((b==0 && sp>=notu) && d<2*notu)	{			sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);			++d;			if (TrPD[sp]>0 && independent[sp]==0)	{				b=1;				/* make sure that the species has not already changed */				for (c=0; c<delta; ++c)	{					if (sp==change[c])	{						c=delta;						b=0;						}					}				}			else	sp=notu;			}	/* end search for single species to change */		for (br=0; sp!=branches[br]; ++br);		}	/* if one too many, grab a species at random until one can be reversed  */	else if (a==APS+1)	{		b=0;		sp=notu;		/* put something in here to make sure that it does not get stuck */		d=0;		while ((b==0 && sp>=notu) && d<2*notu)	{			sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);			++d;			if (TrPD[sp]>0 && independent[sp]==1)	{				b=1;				/* make sure that the species has not already changed */				for (c=0; c<delta; ++c)	{					if (sp==change[c])	{						c=delta;						b=0;						}					}				}			else	sp=notu;			}	/* end search for single species to change */		for (br=0; sp!=branches[br]; ++br);		}		else	{		br=TtlBr+1;		while (br<0 || br>=TtlBr)			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (TtlBr-used));		sp=branches[br];		/* convert random number to a species */		}		used=used+TrPD[sp];		/* change the number of taxa from which to sample */		/* remove species (all entries) from possible changes */	for (b=br; b<TtlBr-used; ++b)	{		branches[b]=branches[b+TrPD[sp]];		}	branches[b]=-1;		/* make note */	change[delta]=sp;	++delta;	/* if a node, change species within the node */	if (sp>=notu)	{		/* first, modify the node's state - if it goes from 0->1, its a new derivation */		nodestate[sp-notu]=swap(nodestate[sp-notu]);		/* second, update descendant clades of the node (if any) */		for (b=1; b<=DescNodes[sp-notu][0]; ++b)	{			sp2=DescNodes[sp-notu][b];			nodestate[sp2]=swap(nodestate[sp2]);			}				/* third, change states of species within node */		for (b=1; b<=tree[sp-notu][0]; ++b)	{			sp2=tree[c=sp-notu][b];			independent[sp2]=swap(independent[sp2]);			}		}	/* if a species, then just change the species */	else		independent[sp]=swap(independent[sp]);	/* now find out how many derivations there are */	der=0;	for (b=0; b<delta; ++b)	{		sp=change[b];		if ((sp>=notu && nodestate[sp-notu]==1) || (sp<notu && independent[sp]==1))	{			derivation[der]=sp;			++der;			}		}			/* calculate the number of species that will have secondary traits */	a=0;	for (b=0; b<notu; ++b)	a=a+independent[b];		/* if incorrect number of derived taxa are produced, then try again 			*/	/* if correct number but too few derivations to get # of states, also try again	*/	if ((a>APS || delta==(APS-1)) || (a==APS && der<(nstates[CH]-PI)))	{		for (b=0; b<TtlBr; ++b)	branches[b]=available[b];		independent=clearlvector(independent,notu,0);		nodestate=clearlvector(nodestate,nodes,0);		derivation=clearivector(derivation,APS,0);		change=clearivector(change,APS,0);		a=used=c=delta=der=0;		clearivector(branches,TtlBr,0);		for (sp=0; sp<TtlBr; ++sp)			branches[sp]=available[sp];		}	}	/* end derivation of independent character */	for (sp=0; sp<notu; ++sp)	character[sp]=INAP;for (sp=0; sp<nodes; ++sp)	nodedepnd[sp]=INAP;/* make each derivation its own state	*/for (st=0; st<der; ++st)	{	sp=derivation[st];	/* simple for species */	if (sp<notu)	{		if (st<nstates[CH])	character[sp]=st;		else				character[sp]=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates[CH]);		}	/* go through clade - but some species might have lost independent character */	else	{		if (st<nstates[CH])	nodedepnd[sp-notu]=st;		else				nodedepnd[sp-notu]=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates[CH]);		for (sp2=1; sp2<=tree[sp-notu][0]; ++sp2)	{			a=tree[sp-notu][sp2];			if (independent[a]==1)	{				if (st<nstates[CH])					character[sp2]=st;				else					character[sp2]=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates[CH]);				}			}		}	}if (PI>0)	{	/* redo the available species */	clearivector(available,TtlBr,0);	clearivector(branches,TtlBr,0);	/* Now separate branches for change */	/* make sure that it is not one of the derivation branches */	TtlAp=0;	for (sp=0; sp<nodes; ++sp)	{		/* include nodes that have independent states */		if (nodestate[sp]==1)	{			c=0;			/* der gives the number of derivations */			/* exclude branches where independent kicks in */			for (sp2=0; sp2<der; ++sp2)	{				if ((sp+notu)==derivation[sp2])	{					c=1;					sp2=der;					}				}			if (c==0)	{				for (b=0; b<TrPD[sp+notu]; ++b)	{					branches[TtlAp]=available[TtlAp]=sp+notu;					++TtlAp;					}				}			}	/* End test of node with derived condition */		}		/* Now do this for OTUs */	for (sp=0; sp<notu; ++sp)	{		/* include otus that have independent states */		if (independent[sp]==1)	{			c=0;			/* der gives the number of derivations */			/* exclude branches where independent kicks in */			for (sp2=0; sp2<der; ++sp2)	{				if (sp==derivation[sp2])	{					c=1;					sp2=der;					}				}			/* if c=0 then the character can change on this branch */			if (c==0)	{				for (b=0; b<TrPD[sp]; ++b)	{					branches[TtlAp]=available[TtlAp]=sp;					++TtlAp;					}				}			}	/* End test of species with derived condition */		}	free_ivector(change);	change=ivector(PI);	used=0;	for (st=0; st<PI; ++st)	{		br=-1;		for (br=-1; br<0 || br>=TtlAp; br=br)			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (TtlAp-used));		sp=change[st]=branches[br];		used=used+TrPD[sp];		for (b=br; b<TtlAp-used; ++b)	branches[b]=branches[b+TrPD[sp]];		}/* now make changes */	for (d=0; d<PI; ++d)	{		sp=change[d];		/* routine for binary characters */		if (nstates[CH]==2)	{			/* routine for species */			if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{				if (character[sp]==0)	character[sp]=1;				else					character[sp]=0;				}	/* end binary change for species */			/* routine for clade */			else	{				/* first change node */				if (nodedepnd[sp-notu]==0)	nodedepnd[sp-notu]=1;				else						nodedepnd[sp-notu]=0;				/* now change descendants */				for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))	{						if (character[sp]==0)	character[sp2]=1;						else					character[sp2]=0;						}					else if (sp2>=notu)	{						if (nodedepnd[sp-notu]==0)	nodedepnd[sp2-notu]=1;						else						nodedepnd[sp2-notu]=0;						}					}	/* end binary change for species within clade */				}	/* end binary change for clade */			}	/* end routine for binary characters */					/** routine for unordered multistate **/		else if (ctype[CH]==1)	{			/* routine for species */			if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{				for (b=character[sp]; b==character[sp]; b=b)					b=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates[CH]);				character[sp]=b;				}	/* end unordered multistate change for species */			/* routine for clade */			else	{				/* first create an array stating which states change to which 	*/				for (a=0; a<nstates[CH]; ++a)	undum[a]=a;				/* now come up with new transitions for this clade 				*/				for (a=0; a<nstates[CH]; ++a)	{					b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[CH]-a));					unord[a]=undum[b];					/* do not let unord[a]==a */					while (unord[a]==a || a>=nstates[CH])	{						b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[CH]-a));						unord[a]=undum[b];						}					/* unord[0] cannot be a (otherwise we wouldn't have this problem */					/* therefore, flip-flop unord[0] and unord[a] */					if (unord[a]==a && a==(nstates[CH]-1))	{						unord[a]=unord[0];						unord[0]=a;						}											/* remove assigned state from possibilities */					for (c=b; c<nstates[CH]; ++c)						undum[c]=undum[c+1];					/* reboot if the final possible state matches original */					if (a==(nstates[CH]-2) && (a+1)==undum[0])	{						a=-1;	/* will increment to 0*/						for (b=0; b<nstates[CH]; ++b)	undum[b]=b;						}					}	/* end assignment of state changes */								/* now make changes */				/* change node first */				nodedepnd[sp-notu]=unord[nodedepnd[sp-notu]];				for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))						character[sp2]=unord[character[sp2]];					/* change descendants node */					else if (sp2>=notu)						nodedepnd[sp2-notu]=unord[nodedepnd[sp2-notu]];					}	/* end unordered multistate change for species within clade */				}	/* end unordered multistate change within clade */			}	/* end routine for unordered multistate characters */					/** routine for ordered multistate **/		else if (ctype[CH]==0)	{			/* determine whether state increases or decreases */			for (flip=-1; flip<0 || flip>99; flip=flip)	{				flip=(int)((double)rand() / ((double)RAND_MAX + 1) * 100);				}			if (flip<bias[CH])	flip=1;			else				flip=-1;			/* routine for species */			if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{				character[sp]=character[sp]+flip;				}	/* end ordered multistate change for species */			/* routine for clade */			else	{				nodedepnd[sp-notu]=nodedepnd[sp-notu]+flip;				/* now make changes */				for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))						character[sp2]=character[sp2]+flip;					else if (sp2>=notu)	{						nodedepnd[sp2-notu]=nodedepnd[sp2-notu]+flip;						}					}	/* end ordered multistate change for species within clade */				}	/* end ordered multistate change within clade */						/* Now, make sure that the lowest value is 0, not -1 or 1 */			st=nstates[CH];			for (a=0; a<notu; ++a) {				if (character[a]<st)	st=character[a];				}			if (st!=0)	{				for (a=0; a<notu; ++a) {					character[a]=character[a]-st;					}				}			}	/* end routine for ordered multistate characters */		}	}	for (sp=0; sp<notu; ++sp)	matrix[sp][CH]=character[sp];/*available, *branches, *unord, *undum, *TrPD, *change, *derivation, **DescNodes;*character, *independent, *nodestate*/free_ivector(available);free_ivector(branches);free_ivector(unord);free_ivector(undum);free_ivector(TrPD);free_ivector(change);free_ivector(derivation);free_lvector(character);free_lvector(independent);free_lvector(nodestate);free_imatrix(DescNodes,nodes,nodes);return matrix;}/* DescendantNodes/* Routine to calculate the number of nodes descended from a more basal node given a VennTree/* Requires:/*		tree - a matrix in which row i gives the j descended OTUs/*		notu - number of otus/* Returns:/*		DescNodes - a matrix in which row i gives the j descended nods/********************************************************************************************************/int	**DescendantNodes (long ** tree, int notu)	{int	a, b, c;int	species, nodes;int	**DescNodes;nodes=number_of_nodes(tree,notu);DescNodes=imatrix(nodes,nodes);for (a=nodes-1; a>0; --a)	{	species=tree[a][1];	for (b=a-1; b>=0; --b)	{		for (c=1; c<=tree[b][0]; ++c)	{			if (species==tree[b][c])	{				++DescNodes[b][0];				DescNodes[b][DescNodes[b][0]]=a;				c=tree[b][0];				}			}		}	}return DescNodes;}/* number_of_nodes/* Routine to calculate the number of nodes descended from a more basal node given a VennTree/* Requires:/*		tree - a matrix in which row i gives the j descended OTUs/*		notu - number of otus/* Returns:/*		nodes - the number of nodes/********************************************************************************************************/int number_of_nodes(long ** tree, int notu){int	a, nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}return nodes;}
#define PowerFunctions#include "PowerFunctions.h"#define memory#include "memory.h"/* LinearStates: finds the best linearly increasing # of states hypothesis/*/* Requires:/*	data: Exhaustion curve/*		data[0]: # of changes/*		data[1]: # of characters/*		data[2]: # of states/*	branches: number of branches/*/* Returns:/*	bestline: information about best fit line/*		bestline[0]: best linear increase for characters/*		bestline[1]: log-likelihood for best linear increase/*		bestline[2]: best linear increase for states/*		bestline[3]: log-likelihood for best linear increase************************************************************************************/double* LinearStates(int **data, int BR){int		a, i, j, start, r;int		*deltas,*ttlst;double	B, M, S;double	BestS=-10000000, BestRate;double	*bestline;/*deltas =(int *)malloc(branches*sizeof(int));ttlst =(int *)malloc(branches*sizeof(int));bestline =(double *)malloc(2*sizeof(double));	*/deltas=ivector(BR);ttlst=ivector(BR);bestline=dvector(4);/* do two runs: one for characters, one for states */for (r=0; r<=1; ++r)	{	for (a=0; a<BR; ++a)	{		deltas[a]=data[a][1];		ttlst[a]=data[a][2+r];	/* 2 if chars, 3 if states */		if (deltas[a]==ttlst[a])	start=a;		}	B = .001;	M = .001;	/* linear */	BestS = -100000;	for (j=1; j<=1000; ++j)	{		B = j;		B = B/1000;		S = 0;		for (i=start; i<BR; ++i)	{			M = deltas[i]-deltas[i-1];			S = S+LnPoisson((ttlst[i]-ttlst[i-1]),B,M);			}		if (S>BestS || j==1)	{			bestline[0+(r*2)]=BestRate=B;	/* 0 for chars, 2 for states */			bestline[1+(r*2)]=BestS=S;		/* 1 for chars, 3 for states */			}		else	j=1000;				}	}/*free ((void *)deltas);free ((void *)ttlst);*/free_ivector(deltas);free_ivector(ttlst);return bestline;}/* FiniteStates: finds the best finite equiprobable states hypothesis/*/* Requires:/*	data: Exhaustion curve/*		data[0]: # of changes/*		data[1]: # of characters/*		data[2]: # of states/*	branches: number of branches/*/* Returns:/*	bestrare: information about best fit line/*		bestrare[0]: best linear increase for characters/*		bestrare[1]: log-likelihood for best linear increase/*		bestrare[2]: best linear increase for states/*		bestrare[3]: log-likelihood for best linear increase************************************************************************************/double* FiniteStates(int **data, int BR){int		a, i, j, BestTotal, start, r;int		*deltas,*ttlst;double	B, M, S, y;double	BestS;double	*bestrare;/*deltas =(int *)malloc(BR*sizeof(int));ttlst =(int *)malloc(BR*sizeof(int));bestrare =(double *)malloc(2*sizeof(double));*/deltas=ivector(BR);ttlst=ivector(BR);bestrare=dvector(4);for (r=0; r<=1; ++r)	{	for (a=0; a<BR; ++a)	{		deltas[a]=data[a][1];		ttlst[a]=data[a][2+r];	/* 2 if chars, 3 if states */		if (deltas[a]==ttlst[a])	start=a;		}	/* the first loop gives a range of states to examine */	BestS=-10000000;	for (j=ttlst[BR-1]; j<10*deltas[BR-1]; ++j)	{		y = j;		S=0;		for (i=start; i<BR; ++i)	{			M = deltas[i]-deltas[i-1];			B = y*(1-pow(1-(1/y),deltas[i])) - y*(1-pow(1-(1/y),deltas[i-1]));					B = B/M;			S = S+LnPoisson((ttlst[i]-ttlst[i-1]),B,M);			}		if (S>BestS || j==ttlst[BR-1]-5)	{			bestrare[0+(r*2)]=BestTotal=j;			bestrare[1+(r*2)]=BestS=S;			}		else	j = 10*deltas[BR-1];		}	}/*free ((void *)deltas);free ((void *)ttlst);*/free_ivector(deltas);free_ivector(ttlst);return bestrare;}/* PowerStates: finds the best power function fitting character state expansion/*/* Requires:/*	data: Exhaustion curve/*		data[0]: # of changes/*		data[1]: # of characters/*		data[2]: # of states/*	branches: number of branches/*/* Returns:/*	bestpowr: information about best fit line/*		bestpowr[0]: best coefficient for characters/*		bestpowr[1]: best exponent for characters/*		bestpowr[2]: log-likelihood for best linear increase/*		bestpowr[3]: best coefficient for states/*		bestpowr[4]: best exponent for states/*		bestpowr[5]: log-likelihood for best linear increase************************************************************************************/double* PowerStates(int **data, int BR){int		a, d, i, k, start, coef, exp, inexp, real, r, tries;int		*deltas,*ttlst;double	E, B, M, X, S, y, C, BestS, BestX, *bestpowr;/*deltas =(int *)malloc(BR*sizeof(int));ttlst =(int *)malloc(BR*sizeof(int));bestpowr=(double *)malloc(3*sizeof(double));*/deltas=ivector(BR);ttlst=ivector(BR);bestpowr=dvector(6);bestpowr[2]=bestpowr[5]=-10000000;for (r=0; r<=1; ++r)	{	for (a=0; a<BR; ++a)	{		deltas[a]=data[a][1];		ttlst[a]=data[a][2+r];	/* 2 if chars, 3 if states */		if (deltas[a]==ttlst[a])	start=a;		}	tries=d=0;	/* the first loop gives a range of states to examine */	for (coef=1001; coef<3000+d; coef=coef+2)	{		C=coef;		C=0.001*C;		E=ttlst[BR-1];		E=100*E;				inexp=999;		while (E>ttlst[BR-1]+25)	{			X = inexp;			X = 0.001*X;			E = C*pow(deltas[BR-1],X);			--inexp;			}				BestS=-100000000;		for (exp=inexp; exp>0; --exp)	{			X = exp;			X = 0.001*X;			/* find where Æ is less than 1.0 */			real=0;			y=2;			while (y>=1)	{				y=(C*pow(real+1,X))-(C*pow(real,X));				++real;				}			--real;			S=0;						for (i=0; i<BR-start-1; ++i)	{				k=i+start;				M = deltas[k+1]-deltas[k];				B = (C*pow(real+deltas[k+1],X)) - (C*pow(real+deltas[k],X));				B = B/M;				S = S+LnPoisson((ttlst[k+1]-ttlst[k]),B,M);				}							if (S>BestS)	{				BestX=X;				BestS=S;				}			else	exp=0;			}		if (BestS>bestpowr[2+(r*3)])	{			bestpowr[0+(r*3)]=C;			bestpowr[1+(r*3)]=BestX;			bestpowr[2+(r*3)]=BestS;			if (coef>=3000+d)	++d;			tries=0;			}		/* if BestS is lower than best overall S, then make note of this */		/* to avoid local optima due to rounding error, wait until we've seen this three times in a row */		else	++tries;				if (tries==3)	coef=3000+d;		}	}/*free ((void *)deltas);free ((void *)ttlst);*/free_ivector(deltas);free_ivector(ttlst);return bestpowr;}double LnPoisson(int obs, double rate, double N){double	result, lambda, x, y;x = obs;lambda = rate*N;if (lambda==0)	lambda = rate;if (obs>0)	y = factorial(obs);else		y = 0;result = (x*log(lambda)-y)-lambda;return result;}double	factorial (int number){int	i;double	result;result=0;for (i=2; i<=number; ++i)	result=result+log(i);return result;}/*FROM HURLBERT 1971 EQUATION 14 - E(Sn) = ·[1 - (1-¹i)^n]NEEDS:    - array with abundance distribution (*abundance)    - number of samples (n)RETURNS:    - expected number of sampled data at a given sampling intensity.*************************************************************/double HurlbertSimple(int n, int S)	{int	i;double	p, xx, ES=0;p=S;p=1/p;for (i=0; i<S; ++i)	{	xx=1-p;	xx=pow(xx,n);	xx=1-xx;	ES=ES+xx;	}return ES;}double PowerFunction(int n, double coeff, double exp)	{double	x, y;x=n;y=coeff*pow(x,exp);}
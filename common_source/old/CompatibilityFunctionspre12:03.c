#define CompatibilityFunctions#include <time.h>#include "CompatibilityFunctions.h"#include "matrixanalysis.h"#include "matrixchange.h"#include "matrixreading.h"#include "memory.h"#include "minmax.h"#include "MonteCarloPhylogenyFunctions.h"#include "TreeRead.h"/*Function returning compability matrix.  O means incompatible, 1 means compatible.Neads:	states: #states per character	notu: number of taxa	chmatrix: character matrix	type: character type (0 = ordered, 1 = unordered)	nchars: number of characters	comptype: 0: general compatibility; 1: hierarchical compatibilty	OUTGROUP: number of outgroup taxon	UNKNOWN: value for "?"	INAP: value for inapplicableReturns:	comatrix: compatibility matrix*****************************************************************************/unsigned long **compatible(int *states, int notu, long **chmatrix, int *type, int nchars, int comptype, int OUTGROUP, int UNKNOWN, int INAP){int a, b, c, d, ch1, ch2, sp, placer, incompatible, inhiercompat, total, mxst, hi, lo, compsp;int	matched, drop, rise, last, maxst;int *autap, *character1, *character2, *mnst, *mtch, *tallied, *taxst, *test1, *test2;int pair[25][25];unsigned long	**comatrix;comatrix=ulmatrix(nchars,nchars);mnst=ivector(nchars);character1=ivector(notu);character2=ivector(notu);test1=ivector(notu);test2=ivector(notu);maxst=maxiarray(states,notu);for (a=0; a<nchars; ++a)	{	mnst[a]=100;	for (b=0; b<notu; ++b)	{		if (chmatrix[b][a]<mnst[a] && (chmatrix[b][a]!=UNKNOWN && chmatrix[b][a]!=INAP))			mnst[a]=chmatrix[b][a];		}	}autap=autapomorphies(chmatrix, states, notu, nchars, UNKNOWN, INAP);for (a=0; a<notu; ++a)	character1[a]=character2[a]=test1[a]=test2[a]=0;tallied=ivector(maxst+1);taxst=ivector(maxst+1);mtch=ivector(maxst+1);//pair=intmatrix(maxst+1,maxst+1);for (ch1=0; ch1<nchars; ch1++)	{	/* if the character is an autapomorphy or invariant, do not waste your time */	/*    the character must be compatible with all other characters	*/	for (ch1=ch1; autap[ch1]<2 && ch1<nchars; ++ch1)	{		comatrix[ch1][ch1]=0;		for (ch2=ch1+1; ch2<nchars; ++ch2)	{			if (comptype==0)	comatrix[ch1][ch2]=comatrix[ch2][ch1]=1;			else				comatrix[ch1][ch2]=comatrix[ch2][ch1]=0;			}			}		if (ch1>=nchars)	break;		comatrix[ch1][ch1]=0;	/* Make sure that outgroup state is appropriately coded	*/	if (states[ch1]==2 && chmatrix[OUTGROUP][ch1]==1)	{		for (sp=0; sp<notu; ++sp)	{			if (chmatrix[sp][ch1]==0)			chmatrix[sp][ch1]=1;			else if (chmatrix[sp][ch1]==1)		chmatrix[sp][ch1]=0;			}		}						if (ch1>=nchars)	break;		for (ch2=ch1+1; ch2<nchars; ++ch2)	{		mxst = states[ch1];		for (sp=0; sp<notu; ++sp)			character1[sp]=chmatrix[sp][ch1];		/* characters are compatible if second is autapomorphic */		for (ch2=ch2; (autap[ch2]<2 && ch2<nchars); ++ch2)	{			if (comptype==0)	comatrix[ch1][ch2]=comatrix[ch2][ch1]=1;			else				comatrix[ch1][ch2]=comatrix[ch2][ch1]=0;			}			if (ch2>=nchars)	break;		comatrix[ch1][ch2]=comatrix[ch2][ch1]=0;		clearivector(test1,notu,RAND_MAX);		clearivector(test2,notu,RAND_MAX);		for (sp=0; sp<notu; ++sp)			character2[sp]=chmatrix[sp][ch2];		/*** Determine compatibility ***/				incompatible = 0;		if ((states[ch1]>states[ch2] && type[ch1]==1) || (states[ch2]>states[ch1] && type[ch2]==0))	{			for (sp=0; sp<notu; ++sp)	{				b = character2[sp];				character2[sp]=character1[sp];				character1[sp]=b;				mxst = states[ch2];				}			hi=ch2;			lo=ch1;			}		else	{			hi=ch1;			lo=ch2;			}		/* sort on placers for comparisons */		/* rewrite to ignore unknowns & inapplicables */		compsp=0;	/* this counts the number of comparable species - i.e., those scored for both characters */		for (sp=0; sp<notu; ++sp)	{			placer = 0;			while (sp<notu && ((character1[sp]==UNKNOWN || character1[sp]==INAP) || (character2[sp]==UNKNOWN || character2[sp]==INAP)))				++sp;			if (sp>=notu)	break;			++compsp;			/**** Sort on 1st character ****/			for (placer=0; (character1[sp]>test1[placer] && placer< notu); ++placer);			/**** Sort on 2nd character ****/			for (placer=placer; ((character1[sp]==test1[placer]&&character2[sp]>test2[placer]) && placer<notu); ++placer);			for (b=sp; b>placer; --b)	{				test1[b]=test1[b-1];				test2[b]=test2[b-1];				}			test1[placer] = character1[sp];			test2[placer] = character2[sp];			}		if (compsp>0)	{				/* for ease of computation, set lowest state to 0 */			if (test1[0]>0 && (test1[0]!=INAP && test1[0]!=UNKNOWN))	{				a=test1[0];				for (sp=0; sp<compsp; ++sp)	{					if (test1[sp]!=INAP && test1[sp]!=UNKNOWN)	{						test1[sp]=test1[sp]-a;						}					else	sp=compsp;					}				}			/**** Routine for Binary Characters ****/			if (states[ch1]==2 && states[ch2]==2)	{				total=1;				for (sp=1; sp<compsp; ++sp)	{					if (test1[sp]==UNKNOWN)	sp = compsp;					else if (test2[sp]>test2[sp-1] && test2[sp]!=UNKNOWN)	++total;					else if (test1[sp]>test1[sp-1])							++total;					if (total>3)	{						sp = compsp;						++incompatible;						}						}				}						/**** Routine for Multistate Characters ****/			else	{				/* if ordered multistate	*/				if (type[hi]==0)	{					drop=rise=0;					c=0;	//				while (test2[c]>mxst && c<compsp)	++c;					for (c=0; test2[c]>mxst && c<compsp; ++c);					if (c>=compsp)	break;					last = test2[c];					for (d=c+1; d<compsp; ++d)	{						if (test2[d]<mxst && test1[c]<mxst)	{							if (test2[d]<last)	++drop;							if (test2[d]>last)	++rise;							last = test2[d];														if (type[lo]==0 && (drop+rise)>=states[lo])	{								incompatible=1;								d=compsp;								}							else if ((drop+rise)>states[lo])	{								incompatible=1;								d=compsp;								}							}						}					}	/* end routine for ordered multistates	*/				else	{					/* find where each character starts	*/					if (test1[0]<=mxst)		sp=taxst[test1[0]]=0;					else if (test1[0]!=UNKNOWN && test1[0]!=INAP)						printf("Too many states for chars %d & %d on line 189\n",ch1,ch2);					for (d=0; d<mxst-1; ++d)	{						taxst[d+1]=0;						for (sp=sp; test1[sp]==d && sp<compsp; ++sp);						if (test1[sp]==UNKNOWN || test1[sp]==INAP)								d=mxst;						else	taxst[d+1]=sp;						}					for (a=0; a<mxst; ++a)	{						mtch[a]=-1;						for (b=0; b<mxst; ++b)	pair[a][b]=-1;						if (a>=mxst)	printf("Too many states for chars %d & %d on line 182\n",ch1,ch2);						}					mtch[a=0]=0;					pair[0][a]=test2[0];					/* find all realized character pairs */					/* look at first n-1 characters; tally each state from char 2 that 					    is paired with state a from character 1if state d+1 != state d, then 						begin anew with the next state; repeat. */					for (d=0; d<compsp-1; ++d)	{						if (test1[d]==UNKNOWN || test1[d]==INAP)	{							d=compsp;							break;							}						else if (test1[d]!=test1[d+1])	{							if (test1[d+1]!=UNKNOWN && test1[d+1]!=INAP)	{								++a;								mtch[a]=b=0;								if (a>=mxst)	printf("Too many states for chars %d & %d on line 200\n",ch1,ch2);								pair[a][b]=test2[d+1];								}							}						else if (test2[d]!=test2[d+1])	{							if (test2[d+1]!=UNKNOWN && test2[d+1]!=INAP)	{								++mtch[a];								if (a>=mxst)	printf("Too many states for chars %d & %d on line 200\n",ch1,ch2);								b=mtch[a];								pair[a][b]=test2[d+1];								}							}						}											/* go through pairs - if 2 states both paired with 2 states, */					/* then they are incompatible */					for (a=0; (a<states[ch1]-1 && a<states[ch2]-1); ++a)	{						for (c=a+1; (c<states[ch1] && c<states[ch2]); ++c)	{							matched=0;							for (b=0; b<=mtch[a]; ++b)	{								for (d=0; d<=mtch[c]; ++d)	{									if (pair[a][b]==pair[c][d])	{										/* one match: they might be compatible	*/										/* two match: they cannot be			*/										if (matched==0)	{											matched=1;										/* d loop is not needed anymore	*/											d=mtch[c];											}										else	{		/* characters must be incompatible */											incompatible=1;										/* none of the loops are needed anymore */											a=c=mxst;											d=mtch[c]+1;											b=mtch[a]+1;											}										}	/* end matching pair */									}	/* end search of paired states for 2nd state */								}	/* end search of paired states for 1st state */							}	/* end search on 2nd state */						}	/* end examination of character pairs				*/					}		/* end compatibility test for unordered characters */				}	/* end routine for multstates	*/			inhiercompat = 1;			if (incompatible==0)	{				if (comptype==0)	{					comatrix[ch1][ch2]=comatrix[ch2][ch1]=1;					}				else	{											a=0;					/* simple test if both are binary: */					if (states[ch1]==2 && states[ch2]==2)	{						a=0;						/* first look for 00 & 01 */						for (a=0; test1[a]==mnst[ch1] && a<compsp; ++a);						for (sp=0; sp<=a; ++sp)	{							/* 2nd state found?	*/							if (test2[sp]!=test2[0])	{								inhiercompat = 0;								sp = compsp;								}											}						/* if only 00's found (or 01's), make sure that two states are found with 1- */						if (inhiercompat==1)	{							b=a;							for (b=a; (test1[b]==1+mnst[ch1] && b<compsp); ++b);							for (sp=a; sp<=b; ++sp)	{								if (test2[sp]!=test2[a])	{									inhiercompat = 0;									sp = compsp;									}								} 							}						}					/* if two multistates with different # states OR different numbers of taxa					 with derived conditions, then they must be HC if compatible at all 					 (unless they are "complements")				*/										else	{						/* check to see if any derived states have multiple counterparts	*/						for (d=0; d<compsp; ++d)	{							if (test1[d]>0 && test1[d]<mxst)	{								if (test2[d]>0 && test2[d]<mxst)	{									inhiercompat = 0;									d=compsp;									}								}							}						/* even if all deriveds for one state paired with single derived, this might not be true */						if (inhiercompat==1)	{							for (d=0; d<compsp; ++d)	{								if (test2[d]>0 && test2[d]<mxst)	{									if (test1[d]>0 && test1[d]<mxst)	{										inhiercompat = 0;										d=compsp;										}									}								}							}						}					}				if (inhiercompat==0)	{					comatrix[ch1][ch2]=comatrix[ch2][ch1]=1;					/* 1 for hierarchically compatible, 0 for hierarchically incompatible	*/					}				}			else	comatrix[ch1][ch2]=comatrix[ch2][ch1]=0;			}	/* only look for compatibility if there is anything to compare */		}	/* end comparison between ch1 & ch2 */	}for (ch1=0; ch1<nchars; ++ch1)	{	comatrix[ch1][ch1]=0;	for (ch2=0; ch2<nchars; ++ch2)	{		if (ch2!=ch1)	comatrix[ch1][ch1]=comatrix[ch1][ch1]+comatrix[ch1][ch2];		}	}free_ivector(autap);free_ivector(character1);free_ivector(character2);free_ivector(mnst);free_ivector(mtch);free_ivector(tallied);free_ivector(taxst);free_ivector(test1);free_ivector(test2);//free_intmatrix(pair,mxst,mxst);return comatrix;}/*Function returning the number of compatible characters WITHOUT requiring a compatibility matrix.	IF you have a compatiblity matrix, use int count_comp instead!Neads:	states: #states per character	notu: number of taxa	chmatrix: character matrix	type: character type (0 = ordered, 1 = unordered)	nchars: number of characters	comptype: 0: general compatibility; 1: hierarchical compatibilty	OUTGROUP: number of outgroup taxon	UNKNOWN: value for "?"	INAP: value for inapplicable*****************************************************************************/int nu_comp(int *states, int notu, long **chmatrix, int *type, int nchars, int comptype, int OUTGROUP, int UNKNOWN, int INAP){int a, b, c, d, ch1, ch2, sp, placer, incompatible, inhiercompat, total, mxst, hi, lo, CP=0, compsp;int	matched, drop, rise, last, maxst;int *character1, *character2, *test1, *test2, *mnst, *autap;int *tallied, *taxst, mtch[25], pair[25][25];mnst=ivector(nchars);character1=ivector(notu);character2=ivector(notu);test1=ivector(notu);test2=ivector(notu);autap=autapomorphies(chmatrix, states, notu, nchars, UNKNOWN, INAP);maxst=maxiarray(states,nchars);for (a=0; a<nchars; ++a)	{	mnst[a]=100;	for (b=0; b<notu; ++b)		if (chmatrix[b][a]<mnst[a] && (chmatrix[b][a]!=UNKNOWN && chmatrix[b][a]!=INAP))				mnst[a]=chmatrix[b][a];	}tallied=ivector(maxst+1);taxst=ivector(maxst+1);//mtch=ivector(mxst);//pair=intmatrix(mxst,mxst);for (ch1=0; ch1<nchars; ch1++)	{	/* if the character is an autapomorphy or invariant, do not waste your time */	/*    the character must be compatible with all other characters	*/	for (ch1=ch1; (autap[ch1]<2 && ch1<nchars); ++ch1)	{		for (ch2=ch1+1; ch2<nchars; ++ch2)	{			if (comptype==0)	++CP;			}			}	/* Make sure that outgroup state is appropriately coded	*/	if (states[ch1]==2 && chmatrix[OUTGROUP][ch1]==1)	{		for (sp=0; sp<notu; ++sp)	{			if (chmatrix[sp][ch1]==0)			chmatrix[sp][ch1]=1;			else if (chmatrix[sp][ch1]==1)		chmatrix[sp][ch1]=0;			}		}						if (ch1>=nchars)	break;		for (ch2=ch1+1; ch2<nchars; ++ch2)	{		mxst = states[ch1];		for (sp=0; sp<notu; ++sp)			character1[sp]=chmatrix[sp][ch1];		/* characters are compatible if second is autapomorphic */		for (ch2=ch2; (autap[ch2]<2 && ch2<nchars); ++ch2)	{			if (comptype==0)	++CP;			}			if (ch2>=nchars)	break;				clearivector(test1,notu,RAND_MAX);		clearivector(test2,notu,RAND_MAX);				for (sp=0; sp<notu; ++sp)			character2[sp]=chmatrix[sp][ch2];		/*** Determine compatibility ***/				incompatible = 0;		if ((states[ch1]>states[ch2] && type[ch1]==1) || (states[ch2]>states[ch1] && type[ch2]==0))	{			for (sp=0; sp<notu; ++sp)	{				b = character2[sp];				character2[sp]=character1[sp];				character1[sp]=b;				mxst = states[ch2];				}			hi=ch2;			lo=ch1;			}		else	{			hi=ch1;			lo=ch2;			}		/* sort on placers for comparisons */		/* rewrite to ignore unknowns & inapplicables */		compsp=0;	/* this counts the number of comparable species - i.e., those scored for both characters */		for (sp=0; sp<notu; ++sp)	{			placer = 0;			while (sp<notu && ((character1[sp]==UNKNOWN || character1[sp]==INAP) || (character2[sp]==UNKNOWN || character2[sp]==INAP)))				++sp;			if (sp>=notu)	break;			++compsp;			/**** Sort on 1st character ****/			for (placer=0; (character1[sp]>test1[placer] && placer< notu); ++placer);			/**** Sort on 2nd character ****/			for (placer=placer; ((character1[sp]==test1[placer]&&character2[sp]>test2[placer]) && placer<notu); ++placer);			for (b=sp; b>placer; --b)	{				test1[b]=test1[b-1];				test2[b]=test2[b-1];				}			test1[placer] = character1[sp];			test2[placer] = character2[sp];			}		if (compsp>0)	{				/* for ease of computation, set lowest state to 0 */			if (test1[0]>0 && (test1[0]!=INAP && test1[0]!=UNKNOWN))	{				a=test1[0];				for (sp=0; sp<compsp; ++sp)	{					if (test1[sp]!=INAP && test1[sp]!=UNKNOWN)	{						test1[sp]=test1[sp]-a;						}					else	sp=compsp;					}				}			/**** Routine for Binary Characters ****/			if (states[ch1]==2 && states[ch2]==2)	{				total=1;				for (sp=1; sp<compsp; ++sp)	{					if (test1[sp]==UNKNOWN)	sp = compsp;					else if (test2[sp]>test2[sp-1] && test2[sp]!=UNKNOWN)	++total;					else if (test1[sp]>test1[sp-1])							++total;					if (total>3)	{						sp = compsp;						++incompatible;						}						}				}	/* end routine for binary */						/**** Routine for Multistate Characters ****/			else	{				/* if ordered multistate	*/				if (type[hi]==0)	{					drop=rise=0;					c=0;					for (c=0; (test2[c]>mxst && c<compsp); ++c); 					if (c>=compsp)	break;					last = test2[c];					for (d=c+1; d<compsp; ++d)	{						if (test2[d]<mxst && test1[c]<mxst)	{							if (test2[d]<last)	++drop;							if (test2[d]>last)	++rise;							last = test2[d];														if (type[lo]==0 && (drop+rise)>=states[lo])	{								incompatible=1;								d=compsp;								}							else if ((drop+rise)>states[lo])	{								incompatible=1;								d=compsp;								}							}						}					}	/* end routine for ordered multistates	*/				/**** Routine for Unorderd Multistates ****/				else	{					/* find where each character starts	*/					sp=taxst[test1[0]]=0; 					for (d=0; d<mxst-1; ++d)	{						taxst[d+1]=0;						for (sp=sp; (test1[sp]==d && sp<compsp); ++sp);						if (test1[sp]==UNKNOWN || test1[sp]==INAP)								d=mxst;						else	taxst[d+1]=sp;						}					for (a=0; a<mxst; ++a)	{						mtch[a]=-1;						for (b=0; b<mxst; ++b)	pair[a][b]=-1;						}					mtch[a=0]=0;					pair[0][a]=test2[0];					/* find all realized character pairs */					/* look at first n-1 characters; tally each state from char 2 that 					    is paired with state a from character 1if state d+1 != state d, then 						begin anew with the next state; repeat. */					for (d=0; d<compsp-1; ++d)	{						if (test1[d]==UNKNOWN || test1[d]==INAP)	{							d=compsp;							break;							}						else if (test1[d]!=test1[d+1])	{							if (test1[d+1]!=UNKNOWN && test1[d+1]!=INAP)	{								++a;								mtch[a]=b=0;								pair[a][b]=test2[d+1];								if (a>=mxst)	printf("screwup on chars %d & %d line 559\n",ch1,ch2);								}							}						else if (test2[d]!=test2[d+1])	{							if (test2[d+1]!=UNKNOWN && test2[d+1]!=INAP)	{								++mtch[a];								b=mtch[a];								pair[a][b]=test2[d+1];								if (a>=mxst)	printf("screwup on chars %d & %d line 567\n",ch1,ch2);								}							}						}											/* go through pairs - if 2 states both paired with 2 states, */					/* then they are incompatible */					for (a=0; (a<states[ch1]-1 && a<states[ch2]-1); ++a)	{						for (c=a+1; (c<states[ch1] && c<states[ch2]); ++c)	{							matched=0;							for (b=0; b<=mtch[a]; ++b)	{								for (d=0; d<=mtch[c]; ++d)	{									if (pair[a][b]==pair[c][d])	{										/* one match: they might be compatible	*/										/* two match: they cannot be			*/										if (matched==0)	{											matched=1;										/* d loop is not needed anymore	*/											d=mtch[c];											}										else	{		/* characters must be incompatible */											incompatible=1;										/* none of the loops are needed anymore */											a=c=mxst;											d=mtch[c]+1;											b=mtch[a]+1;											}										}	/* end matching pair */									}	/* end search of paired states for 2nd state */								}	/* end search of paired states for 1st state */							}	/* end search on 2nd state */						}	/* end examination of character pairs				*/					}	/* end compatibility test for unordered characters	*/				}	/* end routine for multstates	*/			inhiercompat = 1;			if (incompatible==0)	{				if (comptype==0)	++CP;				else	{											a=0;					/* simple test if both are binary: */					if (states[ch1]==2 && states[ch2]==2)	{						a=0;						/* first look for 00 & 01 */						for (a=0; (test1[a]==mnst[ch1] && a<compsp); ++a);						for (sp=0; sp<=a; ++sp)	{							/* 2nd state found?	*/							if (test2[sp]!=test2[0])	{								inhiercompat = 0;								sp = compsp;								}											}						/* if only 00's found (or 01's), make sure that two states are found with 1- */						if (inhiercompat==1)	{							b=a;							for (b=a; (test1[b]==1+mnst[ch1] && b<compsp); ++b);							for (sp=a; sp<=b; ++sp)	{								if (test2[sp]!=test2[a])	{									inhiercompat = 0;									sp = compsp;									}								} 							}						}					/* if two multistates with different # states OR different numbers of taxa					 with derived conditions, then they must be HC if compatible at all 					 (unless they are "complements")				*/										else	{						/* check to see if any derived states have multiple counterparts	*/						for (d=0; d<compsp; ++d)	{							if (test1[d]>0 && test1[d]<mxst)	{								if (test2[d]>0 && test2[d]<mxst)	{									inhiercompat = 0;									d=compsp;									}								}							}						/* even if all deriveds for one state paired with single derived, this might not be true */						if (inhiercompat==1)	{							for (d=0; d<compsp; ++d)	{								if (test2[d]>0 && test2[d]<mxst)	{									if (test1[d]>0 && test1[d]<mxst)	{										inhiercompat = 0;										d=compsp;										}									}								}							}						}					/* 1 for hierarchically compatible, 0 for hierarchically incompatible	*/					if (inhiercompat==0)	{						++CP;												}					}	/* end routine for hierachically compatible */				}	/* End tally of compatible characters */				}	/* end test of whether they are compatible */		}	/* end comparison between ch1 and ch2 */	}	/* end ch1 */		free_ivector(character1);free_ivector(character2);free_ivector(test1);free_ivector(test2);free_ivector(mnst);free_ivector(autap);free_ivector(tallied);free_ivector(taxst);//free_ivector(mtch);//free_intmatrix(pair,mxst,mxst);return CP;}/*Function returning the number of compatiblities per character WITHOUT requiring a compatibility matrix.Neads:	states: #states per character	notu: number of taxa	chmatrix: character matrix	type: character type (0 = ordered, 1 = unordered)	nchars: number of characters	comptype: 0: general compatibility; 1: hierarchical compatibilty	OUTGROUP: number of outgroup taxon	UNKNOWN: value for "?"	INAP: value for inapplicable	charcomps: the array giving the number of compatibilities per character; this is allocated in advance		in order to discourage memory errors from repeated allocations/deallocations.*****************************************************************************/unsigned long *char_comp(int *states, int notu, long **chmatrix, int *type, int nchars, int comptype, int OUTGROUP, int UNKNOWN, int INAP){int a, b, c, d, ch1, ch2, sp, placer, incompatible, inhiercompat, total, mxst, hi, lo;int	matched, drop, rise, last, maxst;int *character1, *character2, *test1, *test2, *mnst, *autap;int *tallied, *taxst, mtch[25], pair[25][25];unsigned long *charcomps;charcomps=ulvector(nchars);mnst=ivector(nchars);character1=ivector(notu);character2=ivector(notu);test1=ivector(notu);test2=ivector(notu);autap=autapomorphies(chmatrix, states, notu, nchars, UNKNOWN, INAP);maxst=maxiarray(states,nchars);for (a=0; a<nchars; ++a)	{	charcomps[a]=0;	mnst[a]=100;	for (b=0; b<notu; ++b)	{		if (chmatrix[b][a]<mnst[a] && (chmatrix[b][a]!=UNKNOWN && chmatrix[b][a]!=INAP))				mnst[a]=chmatrix[b][a];		}	}tallied=ivector(maxst+1);taxst=ivector(maxst+1);//mtch=ivector(maxst+1);//pair=intmatrix(maxst+1,maxst+1);for (ch1=0; ch1<nchars; ch1++)	{	/* if the character is an autapomorphy or invariant, do not waste your time */	/*    the character must be compatible with all other characters	*/	for (ch1=ch1; (autap[ch1]<2 && ch1<nchars); ++ch1)	{		for (ch2=ch1+1; ch2<nchars; ++ch2)	{			if (comptype==0)	{				++charcomps[ch1];				++charcomps[ch2];				}			}			}	/* Make sure that outgroup state is appropriately coded	*/	if (states[ch1]==2 && chmatrix[OUTGROUP][ch1]==1)	{		for (sp=0; sp<notu; ++sp)	{			if (chmatrix[sp][ch1]==0)			chmatrix[sp][ch1]=1;			else if (chmatrix[sp][ch1]==1)		chmatrix[sp][ch1]=0;			}		}						if (ch1>=nchars)	break;		for (ch2=ch1+1; ch2<nchars; ++ch2)	{		mxst = states[ch1];		for (sp=0; sp<notu; ++sp)			character1[sp]=chmatrix[sp][ch1];		/* characters are compatible if second is autapomorphic */		for (ch2=ch2; (autap[ch2]<2 && ch2<nchars); ++ch2)	{			if (comptype==0)	{				++charcomps[ch1];				++charcomps[ch2];				}			}			if (ch2>=nchars)	break;		clearivector(test1,notu,RAND_MAX);		clearivector(test2,notu,RAND_MAX);		for (sp=0; sp<notu; ++sp)			character2[sp]=chmatrix[sp][ch2];		/*** Determine compatibility ***/				incompatible = 0;		if ((states[ch1]>states[ch2] && type[ch1]==1) || (states[ch2]>states[ch1] && type[ch2]==0))	{			for (sp=0; sp<notu; ++sp)	{				b = character2[sp];				character2[sp]=character1[sp];				character1[sp]=b;				mxst = states[ch2];				}			hi=ch2;			lo=ch1;			}		else	{			hi=ch1;			lo=ch2;			}		/*sort on placers for comparisons */		for (sp=0; sp<notu; ++sp)	{			placer = 0;			/**** Sort on 1st character ****/			for (placer=0; (character1[sp]>test1[placer] && placer< notu); ++placer);			/**** Sort on 2nd character ****/			for (placer=placer; ((character1[sp]==test1[placer]&&character2[sp]>test2[placer]) && placer<notu); ++placer);			for (b=sp; b>placer; --b)	{				test1[b]=test1[b-1];				test2[b]=test2[b-1];				}			test1[placer] = character1[sp];			test2[placer] = character2[sp];			}		/* for ease of computation, set lowest state to 0 */		if (test1[0]>0 && (test1[0]!=INAP && test1[0]!=UNKNOWN))	{			a=test1[0];			for (sp=0; sp<notu; ++sp)	{				if (test1[sp]!=INAP && test1[sp]!=UNKNOWN)	{					test1[sp]=test1[sp]-a;					}				else	sp=notu;				}			}		/**** Routine for Binary Characters ****/		if (states[ch1]==2 && states[ch2]==2)	{			total=1;			for (sp=1; sp<notu; ++sp)	{				if (test1[sp]==UNKNOWN)	sp = notu;				else if (test2[sp]>test2[sp-1] && test2[sp]!=UNKNOWN)	++total;				else if (test1[sp]>test1[sp-1])							++total;				if (total>3)	{					sp = notu;					++incompatible;					}					}			}				/**** Routine for Multistate Characters ****/		else	{			/* if ordered multistate	*/			if (type[hi]==0)	{				drop=rise=0;				c=0;				for (c=0; (test2[c]>mxst && c<notu); ++c); 				if (c>=notu)	break;				last = test2[c];				for (d=c+1; d<notu; ++d)	{					if (test2[d]<mxst && test1[c]<mxst)	{						if (test2[d]<last)	++drop;						if (test2[d]>last)	++rise;						last = test2[d];												if (type[lo]==0 && (drop+rise)>=states[lo])	{							incompatible=1;							d=notu;							}						else if ((drop+rise)>states[lo])	{							incompatible=1;							d=notu;							}						}					}				}	/* end routine for ordered multistates	*/			else	{				/* find where each character starts	*/				sp=taxst[test1[0]]=0; 				for (d=0; d<mxst-1; ++d)	{					taxst[d+1]=0;					for (sp=sp; (test1[sp]==d && sp<notu); ++sp);					if (test1[sp]==UNKNOWN || test1[sp]==INAP)							d=mxst;					else	taxst[d+1]=sp;					}				for (a=0; a<mxst; ++a)	{					mtch[a]=-1;					for (b=0; b<mxst; ++b)	pair[a][b]=-1;					if (a>=mxst)	printf("Too many states for chars %d & %d on line 786\n",ch1,ch2);					}				mtch[a=0]=0;				pair[0][a]=test2[0];				/* find all realized character pairs */				/* look at first n-1 characters; tally each state from char 2 that 				    is paired with state a from character 1if state d+1 != state d, then 					begin anew with the next state; repeat. */				for (d=0; d<notu-1; ++d)	{					if (test1[d]==UNKNOWN || test1[d]==INAP)	{						d=notu;						break;						}					else if (test1[d]!=test1[d+1])	{						if (test1[d+1]!=UNKNOWN && test1[d+1]!=INAP)	{							++a;							mtch[a]=b=0;							if (a>=mxst)	printf("Too many states for chars %d & %d on line 804\n",ch1,ch2);							pair[a][b]=test2[d+1];							}						}					else if (test2[d]!=test2[d+1])	{						if (test2[d+1]!=UNKNOWN && test2[d+1]!=INAP)	{							++mtch[a];							b=mtch[a];							if (a>=mxst)	printf("Too many states for chars %d & %d on line 812\n",ch1,ch2);							pair[a][b]=test2[d+1];							}						}					}									/* go through pairs - if 2 states both paired with 2 states, */				/* then they are incompatible */				for (a=0; (a<states[ch1]-1 && a<states[ch2]-1); ++a)	{					for (c=a+1; (c<states[ch1] && c<states[ch2]); ++c)	{						matched=0;						for (b=0; b<=mtch[a]; ++b)	{							for (d=0; d<=mtch[c]; ++d)	{								if (pair[a][b]==pair[c][d])	{									/* one match: they might be compatible	*/									/* two match: they cannot be			*/									if (matched==0)	{										matched=1;									/* d loop is not needed anymore	*/										d=mtch[c];										}									else	{		/* characters must be incompatible */										incompatible=1;									/* none of the loops are needed anymore */										a=c=mxst;										d=mtch[c]+1;										b=mtch[a]+1;										}									}	/* end matching pair */								}	/* end search of paired states for 2nd state */							}	/* end search of paired states for 1st state */						}	/* end search on 2nd state */					}	/* end examination of character pairs				*/				}		/* end compatibility test for unordered characters */			}	/* end routine for multstates	*/		inhiercompat = 1;		if (incompatible==0)	{			if (comptype==0)	{				++charcomps[ch1];				++charcomps[ch2];				}			else	{										a=0;				/* simple test if both are binary: */				if (states[ch1]==2 && states[ch2]==2)	{					a=0;					/* first look for 00 & 01 */					for (a=0; (test1[a]==mnst[ch1] && a<notu); ++a);					for (sp=0; sp<=a; ++sp)	{						/* 2nd state found?	*/						if (test2[sp]!=test2[0])	{							inhiercompat = 0;							sp = notu;							}										}					/* if only 00's found (or 01's), make sure that two states are found with 1- */					if (inhiercompat==1)	{						b=a;						for (b=a; (test1[b]==1+mnst[ch1] && b<notu); ++b);						for (sp=a; sp<=b; ++sp)	{							if (test2[sp]!=test2[a])	{								inhiercompat = 0;								sp = notu;								}							} 						}					}				/* if two multistates with different # states OR different numbers of taxa				 with derived conditions, then they must be HC if compatible at all 				 (unless they are "complements")				*/								else	{					/* check to see if any derived states have multiple counterparts	*/					for (d=0; d<notu; ++d)	{						if (test1[d]>0 && test1[d]<mxst)	{							if (test2[d]>0 && test2[d]<mxst)	{								inhiercompat = 0;								d=notu;								}							}						}					/* even if all deriveds for one state paired with single derived, this might not be true */					if (inhiercompat==1)	{						for (d=0; d<notu; ++d)	{							if (test2[d]>0 && test2[d]<mxst)	{								if (test1[d]>0 && test1[d]<mxst)	{									inhiercompat = 0;									d=notu;									}								}							}						}					}				}			if (inhiercompat==0)	{				++charcomps[ch1];				++charcomps[ch2];				/* 1 for hierarchically compatible, 0 for hierarchically incompatible	*/				}			}		}	}		free_ivector(character1);free_ivector(character2);free_ivector(test1);free_ivector(test2);free_ivector(mnst);free_ivector(autap);free_ivector(tallied);free_ivector(taxst);//free_ivector(mtch);//free_intmatrix(pair,mxst,mxst);return charcomps;}/*Function returning the number of compatibilities given a compatibility matrix.Neads:	comatrix: char x char compatibility matrix, with 1 = compatible and 0 = incompatible	nchars: number of characters*****************************************************************************/int countcomp(unsigned long **comatrix, int nchars){int	c1, c2, CP=0;for (c1=0; c1<nchars-1; ++c1)	{	for (c2=c1+1; c2<nchars; ++c2)	{		if (comatrix[c1][c2]==1)			++CP;		}	}return CP;}/*Function returning the number of compatibilities per character given a compatibility matrix.Neads:	comatrix: char x char compatibility matrix, with 1 = compatible and 0 = incompatible	nchars: number of characters	charcomps: the array giving compatibilities per character (this is allocated in advance		in order to discourage memory errors from repeated allocations / deallocations.)*****************************************************************************/unsigned long *countcharcomps(unsigned long **comatrix, int nchars, unsigned long *charcomps){int	c1, c2;for (c1=0; c1<nchars; ++c1)	charcomps[c1]=0;for (c1=0; c1<nchars-1; ++c1)	{	for (c2=c1+1; c2<nchars; ++c2)	{		if (comatrix[c1][c2]==1)	{			++charcomps[c1];			++charcomps[c2];			}		}	}return charcomps;}/*Function returning the number of mutual compatibilities (see OÕKeefe & Wagner 2001 Syst. Biol. 	given a compatibility matrix.Neads:	comatrix: char x char compatibility matrix, with 1 = compatible and 0 = incompatible	nchars: number of characters*****************************************************************************/unsigned long **mutualcomp(unsigned long **comatrix, int nchars){int	c1, c2, c3;unsigned long **m;m=ulmatrix(nchars,nchars);for (c1=0; c1<nchars; ++c1)	{	m[c1][c1]=comatrix[c1][c1];	for (c2=c1+1; c2<nchars; ++c2)	{		m[c1][c2]=0;		for (c3=0; c3<nchars; ++c3)	{			while (c3==c1 || c3==c2)	++c3;			if (c3>=nchars)	break;			if (comatrix[c1][c3]==1 && comatrix[c2][c3]==1)				++m[c1][c2];			}		m[c2][c1]=m[c1][c2];		}	}return m;}/*Function returning the number of compatible characters for a particular character	WITHOUT requiring a compatibility matrix in advance.Neads:	states: #states per character	notu: number of taxa	chmatrix: character matrix	type: character type (0 = ordered, 1 = unordered)	nchars: number of characters	comptype: 0: general compatibility; 1: hierarchical compatibilty	OUTGROUP: number of outgroup taxon	UNKNOWN: value for "?"	INAP: value for inapplicable*****************************************************************************/int char_nu_comp(int CH, int *states, int notu, long **chmatrix, int *type, int nchars, int comptype, int OUTGROUP, int UNKNOWN, int INAP){int a, b, c, d, ch2, sp, placer, incompatible, inhiercompat, total, mxst, hi, lo, NC=0;int	matched, drop, rise, last, maxst;int *character1, *character2, *test1, *test2, *mnst, *autap;int *tallied, *taxst, mtch[25], pair[25][25];mnst=ivector(nchars);character1=ivector(notu);character2=ivector(notu);test1=ivector(notu);test2=ivector(notu);autap=autapomorphies(chmatrix, states, notu, nchars, UNKNOWN, INAP);maxst=maxiarray(states,nchars)+1;for (a=0; a<nchars; ++a)	{	mnst[a]=100;	for (b=0; b<notu; ++b)		if (chmatrix[b][a]<mnst[a] && (chmatrix[b][a]!=UNKNOWN && chmatrix[b][a]!=INAP))	mnst[a]=chmatrix[b][a];	}tallied=ivector(maxst+1);taxst=ivector(maxst+1);/* if the character is an autapomorphy or invariant, do not waste your time *//*    the character must be compatible with all other characters	*/if (autap[CH]==1)	NC=nchars-1;else	{	/* Make sure that outgroup state is appropriately coded	*/	if (states[CH]==2 && chmatrix[OUTGROUP][CH]==1)	{		for (sp=0; sp<notu; ++sp)	{			if (chmatrix[sp][CH]==0)			chmatrix[sp][CH]=1;			else if (chmatrix[sp][CH]==1)		chmatrix[sp][CH]=0;			}		}						for (ch2=0; ch2<nchars; ++ch2)	{		if (ch2==CH)	++ch2;		if (ch2>=nchars)	break;		mxst = states[CH];		for (sp=0; sp<notu; ++sp)			character1[sp]=chmatrix[sp][CH];		/* characters are compatible if second is autapomorphic */		for (ch2=ch2; (autap[ch2]<2 && ch2<nchars); ++ch2)	{			if (comptype==0)	++NC;			}			if (ch2>=nchars)	break;		/* set up arrays for testing compatibility */		for (a=0; a<notu; ++a)			test1[a]=test2[a]=100;	 		for (sp=0; sp<notu; ++sp)			character2[sp]=chmatrix[sp][ch2];		/*** Determine compatibility ***/				incompatible = 0;		if ((states[CH]>states[ch2] && type[CH]==1) || (states[ch2]>states[CH] && type[ch2]==0))	{			for (sp=0; sp<notu; ++sp)	{				b = character2[sp];				character2[sp]=character1[sp];				character1[sp]=b;				mxst = states[ch2];				}			hi=ch2;			lo=CH;			}		else	{			hi=CH;			lo=ch2;			}		/*sort on placers for comparisons */		for (sp=0; sp<notu; ++sp)	{			placer = 0;			/**** Sort on 1st character ****/			for (placer=0; (character1[sp]>test1[placer] && placer< notu); ++placer);			/**** Sort on 2nd character ****/			for (placer=placer; ((character1[sp]==test1[placer]&&character2[sp]>test2[placer]) && placer<notu); ++placer);			for (b=sp; b>placer; --b)	{				test1[b]=test1[b-1];				test2[b]=test2[b-1];				}			test1[placer] = character1[sp];			test2[placer] = character2[sp];			}		/**** Routine for Binary Characters ****/		if (states[CH]==2 && states[ch2]==2)	{			total=1;			for (sp=1; sp<notu; ++sp)	{				if (test1[sp]==UNKNOWN)	sp = notu;				else if (test2[sp]>test2[sp-1] && test2[sp]!=UNKNOWN)	++total;				else if (test1[sp]>test1[sp-1])							++total;				if (total>3)	{					sp = notu;					++incompatible;					}					}			}				/**** Routine for Multistate Characters ****/		else	{			/* if ordered multistate	*/			if (type[hi]==0)	{				drop=rise=0;				c=0;				for (c=0; (test2[c]>mxst && c<notu); ++c); 				if (c>=notu)	break;				last = test2[c];				for (d=c+1; d<notu; ++d)	{					if (test2[d]<mxst && test1[c]<mxst)	{						if (test2[d]<last)	++drop;						if (test2[d]>last)	++rise;						last = test2[d];												if (type[lo]==0 && (drop+rise)>=states[lo])	{							incompatible=1;							d=notu;							}						else if ((drop+rise)>states[lo])	{							incompatible=1;							d=notu;							}						}					}				}	/* end routine for ordered multistates	*/			/**** Routine for Unorderd Multistates ****/			else	{				/* find where each character starts	*/				sp=taxst[test1[0]]=0; 				for (d=0; d<mxst-1; ++d)	{					taxst[d+1]=0;					for (sp=sp; (test1[sp]==d && sp<notu); ++sp);					if (test1[sp]==UNKNOWN || test1[sp]==INAP)							d=mxst;					else	taxst[d+1]=sp;					}				for (a=0; a<mxst; ++a)	{					mtch[a]=-1;					for (b=0; b<mxst; ++b)	pair[a][b]=-1;					}				mtch[a=0]=0;				pair[0][a]=test2[0];				/* find all realized character pairs */				/* look at first n-1 characters; tally each state from char 2 that 				    is paired with state a from character 1if state d+1 != state d, then 					begin anew with the next state; repeat. */				for (d=0; d<notu-1; ++d)	{					if (test1[d]==UNKNOWN || test1[d]==INAP)	{						d=notu;						break;						}					else if (test1[d]!=test1[d+1])	{						if (test1[d+1]!=UNKNOWN && test1[d+1]!=INAP)	{							++a;							mtch[a]=b=0;							pair[a][b]=test2[d+1];							if (a>=mxst)	printf("screwup on chars %d & %d line 503\n",CH,ch2);							}						}					else if (test2[d]!=test2[d+1])	{						if (test2[d+1]!=UNKNOWN && test2[d+1]!=INAP)	{							++mtch[a];							b=mtch[a];							pair[a][b]=test2[d+1];							if (a>=mxst)	printf("screwup on chars %d & %d line 511\n",CH,ch2);							}						}					}									/* go through pairs - if 2 states both paired with 2 states, */				/* then they are incompatible */				for (a=0; (a<states[CH]-1 && a<states[ch2]-1); ++a)	{					for (c=a+1; (c<states[CH] && c<states[ch2]); ++c)	{						matched=0;						for (b=0; b<=mtch[a]; ++b)	{							for (d=0; d<=mtch[c]; ++d)	{								if (pair[a][b]==pair[c][d])	{									/* one match: they might be compatible	*/									/* two match: they cannot be			*/									if (matched==0)	{										matched=1;									/* d loop is not needed anymore	*/										d=mtch[c];										}									else	{		/* characters must be incompatible */										incompatible=1;									/* none of the loops are needed anymore */										a=c=mxst;										d=mtch[c]+1;										b=mtch[a]+1;										}									}	/* end matching pair */								}	/* end search of paired states for 2nd state */							}	/* end search of paired states for 1st state */						}	/* end search on 2nd state */					}	/* end examination of character pairs				*/				}	/* end compatibility test for unordered characters	*/			}	/* end routine for multstates	*/		inhiercompat = 1;		if (incompatible==0)	{			if (comptype==0)	++NC;			else	{										a=0;				/* simple test if both are binary: */				if (states[CH]==2 && states[ch2]==2)	{					a=0;					/* first look for 00 & 01 */					for (a=0; (test1[a]==mnst[CH] && a<notu); ++a);					for (sp=0; sp<=a; ++sp)	{						/* 2nd state found?	*/						if (test2[sp]!=test2[0])	{							inhiercompat = 0;							sp = notu;							}										}					/* if only 00's found (or 01's), make sure that two states are found with 1- */					if (inhiercompat==1)	{						b=a;						for (b=a; (test1[b]==1+mnst[CH] && b<notu); ++b);						for (sp=a; sp<=b; ++sp)	{							if (test2[sp]!=test2[a])	{								inhiercompat = 0;								sp = notu;								}							} 						}					}				/* if two multistates with different # states OR different numbers of taxa				 with derived conditions, then they must be HC if compatible at all 				 (unless they are "complements")				*/								else	{					/* check to see if any derived states have multiple counterparts	*/					for (d=0; d<notu; ++d)	{						if (test1[d]>0 && test1[d]<mxst)	{							if (test2[d]>0 && test2[d]<mxst)	{								inhiercompat = 0;								d=notu;								}							}						}					/* even if all deriveds for one state paired with single derived, this might not be true */					if (inhiercompat==1)	{						for (d=0; d<notu; ++d)	{							if (test2[d]>0 && test2[d]<mxst)	{								if (test1[d]>0 && test1[d]<mxst)	{									inhiercompat = 0;									d=notu;									}								}							}						}					}				}			if (inhiercompat==0)	{				++NC;				/* 1 for hierarchically compatible, 0 for hierarchically incompatible	*/				}			}		}	}free_ivector(character1);free_ivector(character2);free_ivector(test1);free_ivector(test2);free_ivector(mnst);free_ivector(autap);free_ivector(tallied);free_ivector(taxst);//free_ivector(mtch);//free_intmatrix(pair,mxst,mxst);return NC;}/*Function returning possible numbers of combinations per character.Neads:	states: #states per character	notu: number of taxa	chmatrix: character matrix	nchars: number of characters	UNKNOWN: value for "?"	INAP: value for inapplicable*****************************************************************************/long *PossibleCharCombinations(int *states, int nchars){int	 ch1, ch2;long *combos;combos=lvector(nchars);for (ch1=0; ch1<nchars; ++ch1)	{	combos[ch1]=0;	for (ch2=0; ch2<nchars; ++ch2)	{		if (ch2==ch1)	++ch2;		if (ch2>=nchars)	break;		combos[ch1]=combos[ch1]+states[ch1]*states[ch2];		}	/* end addition of combinations on ch1 */	}	/* end search through characters	*/return combos;}/*Function returning observed numbers of combinations per character.Neads:	states: #states per character	notu: number of taxa	chmatrix: character matrix	nchars: number of characters	UNKNOWN: value for "?"	INAP: value for inapplicable	*****************************************************************************/long **Combinations(long **combomatrix, int *states, int notu, long **chmatrix, int nchars, int UNKNOWN, int INAP){int 	a, b, d, ch1, ch2, sp, placer, mxst, maxst, hi, lo;int 	*character1, *character2, *mtch, *test1, *test2, *taxst;int 	**pair;character1=ivector(notu);character2=ivector(notu);test1=ivector(notu);test2=ivector(notu);//dependent=ivector(nchars);maxst=0;for (a=0; a<nchars; ++a)	{	for (b=0; b<notu; ++b)	{		if (chmatrix[b][a]>maxst && (chmatrix[b][a]!=UNKNOWN && chmatrix[b][a]!=INAP))				maxst=chmatrix[b][a];		}	}for (a=0; a<notu; ++a)	character1[a]=character2[a]=test1[a]=test2[a]=0;mtch=ivector(maxst+1);taxst=ivector(maxst+1);pair=imatrix(maxst+1,maxst+1);for (ch1=0; ch1<nchars; ch1++)	{	combomatrix[ch1][ch1]=0;	for (ch2=ch1+1; ch2<nchars; ++ch2)	{			combomatrix[ch1][ch2]=0;		clearimatrix(pair,maxst+1,maxst+1,-1);		mxst = states[ch1];		for (sp=0; sp<notu; ++sp)	character1[sp]=chmatrix[sp][ch1];		clearivector(test1,notu,RAND_MAX);		clearivector(test2,notu,RAND_MAX);	 		for (sp=0; sp<notu; ++sp)			character2[sp]=chmatrix[sp][ch2];		/*** Determine combinations ***/				if (states[ch1]>states[ch2])	{			for (sp=0; sp<notu; ++sp)	{				b = character2[sp];				character2[sp]=character1[sp];				character1[sp]=b;				mxst = states[ch2];				}			hi=ch2;			lo=ch1;			}		else	{			hi=ch1;			lo=ch2;			}		/*sort on placers for comparisons */		for (sp=0; sp<notu; ++sp)	{			placer = 0;			/**** Sort on 1st character ****/			for (placer=0; (character1[sp]>test1[placer] && placer< notu); ++placer);			/**** Sort on 2nd character ****/			for (placer=placer; ((character1[sp]==test1[placer]&&character2[sp]>test2[placer]) && placer<notu); ++placer);			for (b=sp; b>placer; --b)	{				test1[b]=test1[b-1];				test2[b]=test2[b-1];				}			test1[placer] = character1[sp];			test2[placer] = character2[sp];			}					/* for ease of computation, set lowest state to 0 */		if (test1[0]>0 && (test1[0]!=INAP && test1[0]!=UNKNOWN))	{			a=test1[0];			for (sp=0; sp<notu; ++sp)	{				if (test1[sp]!=INAP && test1[sp]!=UNKNOWN)	{					test1[sp]=test1[sp]-a;					}				else	sp=notu;				}			}		/* find where each character starts	*/		if (test1[0]<=mxst)	sp=taxst[test1[0]]=0;		else if (test1[0]!=INAP && test1[0]!=UNKNOWN)			printf("Too many states for chars %d & %d on line 1173\n",ch1,ch2);		for (d=0; d<mxst-1; ++d)	{			taxst[d+1]=0;			for (sp=sp; test1[sp]==d && sp<notu; ++sp);			if (test1[sp]==UNKNOWN || test1[sp]==INAP)					d=mxst;			else	taxst[d+1]=sp;			}		for (a=0; a<mxst; ++a)			mtch[a]=-1;		mtch[a=0]=0;		pair[0][a]=test2[0];		/* find all realized character pairs */		/* look at first n-1 characters; tally each state from char 2 that 		    is paired with state a from character 1if state d+1 != state d, then 			begin anew with the next state; repeat. */		/* check at 17 sp., ch=0 & 20 */		for (d=0; d<notu-1; ++d)	{			if (test1[d]==UNKNOWN || test1[d]==INAP)	{				d=notu;				break;				}			else if (test1[d]!=test1[d+1])	{				/* if the first state is unknown or inapplicable, then this state has no pairs */				if ((test1[d+1]!=UNKNOWN && test1[d+1]!=INAP) && (test2[d+1]!=UNKNOWN && test2[d+1]!=INAP))	{					++a;					mtch[a]=b=0;					if (a>maxst)	printf("Too many states for chars %d & %d on line 1232\n",ch1,ch2);					pair[a][b]=test2[d+1];					}				}			else if (test2[d]!=test2[d+1])	{				if (test2[d+1]!=UNKNOWN && test2[d+1]!=INAP)	{					++mtch[a];					if (a>maxst)	printf("Too many states for chars %d & %d on line 1239\n",ch1,ch2);					b=mtch[a];					pair[a][b]=test2[d+1];					}				}	/* end test to see if b is new in a¥b comparison */			}	/* end search through taxa */					for (a=0; (a<=maxst /*&& pair[a][0]!=-1*/); ++a)	{			for (a=a; pair[a][0]==-1 & a<maxst; ++a);			if (a>maxst)	break;			for (b=0; (b<=maxst /*&& pair[a][b]!=-1*/); ++b)	{				for (b=b; pair[a][b]==-1; ++b);				if (b>maxst)	break;				if (pair[a][b]!=UNKNOWN && pair[a][b]!=INAP)	++combomatrix[ch1][ch2];				}			}		combomatrix[ch2][ch1]=combomatrix[ch1][ch2];		}	/* end search of combinations	*/	}free_ivector(character1);free_ivector(character2);free_ivector(test1);free_ivector(test2);free_ivector(mtch);free_ivector(taxst);free_imatrix(pair,maxst+1,maxst+1);return combomatrix;}/*likeallstepsgivencomp - calculates the probability of X compatibilities given Y steps and observed matrix.Neads:	matrix: empirical character matrix	ctype: array giving character types (0: ordered; 1: unordered)	nstates: array giving the number of states per character	nchars: number of characters	empcomp: compatibility of matrix	bias: array giving biases in gains / loses for character, with 60 meaning P[increase]=0.6	maxd: maximum number of changes per character	notu: number of taxa	fossil: 0 if no fossils, 1 if fossils included.  	mbl: simulation parameters (origination, extinction, sampling, speciation mode)	debug: 0 if using a random number, 1 if using a number generated by the replicate for debugging purposes	UNKNOWN: value for "?"	INAP: value for inapplicable**********************************************************************************************************************************************************/double *likeallstepsgivencomp(long **matrix, int *ctype, int *nstates, int nchars, int notu, int empcomp, int comptype, int out, int fossils, double *mbl, int *bias, int *maxd, int pars, int debug, int UNKNOWN, int INAP){int		a, b,st,max,reps,truns;int		simcomp;long	**simat, **tree;double	*Lsteps;max=iarraytotal(nstates,nchars)-nchars;Lsteps=dvector(1+(max-pars));printf("Enter the number of runs: ");scanf("%s",&reps);printf("\n");printf("The program will examine %d trees from %d to %d steps\n",reps,pars,max);printf("\tto find the best tree lengths for this test.\n");printf("Doing tree #");tree=lmatrix(notu+2,notu);		/* also will give clade diversity in first cell */								/* finally, gives branch lengths in final two lines *//* set the simulated matrix equal to the true matrix initially - this will make things easier later */simat=lmatrix(notu,nchars);equallmatrix(simat,matrix,notu,nchars);for (truns=0; truns<reps; ++truns)	{	if (debug==1)	srand((unsigned int) (truns));	/* This is easier because you do not know how many nodes you'll get when sampling over time */	if (fossils==1)	tree=evolvetreeVenn(notu, mbl, fossils);	/* if no fossil taxa, then just make a cladogram and a Venn tree from it */	else	{		tree=evolvecladogram(notu,tree);		tree=clademember(tree, notu, notu-1);		}	printf("%d",reps+1);		for (st=pars; st<=max; ++st)	{		a=st-pars;		printf(" %d st\n",st);		if (debug==1)	srand((unsigned int) (truns+st));		simat=evolvematrix(tree, notu, simat, nchars, nstates, ctype, bias, maxd, st, UNKNOWN, INAP);		simcomp=nu_comp(nstates, notu, simat, ctype, nchars, comptype, out, UNKNOWN, INAP);		if (simcomp==empcomp)	++Lsteps[a];		printf("\b");		for (b=1; b<=st; b=b*10) {			printf("\b");			}		printf("\b\b\b\b");		if (simcomp<(2*empcomp/3) && reps==0)	max=st-1;		}	for (b=(reps+1); b>=1; b=b/10)	printf("\b");	}free_lmatrix(simat,notu,nchars);free_lmatrix(tree,notu+2,notu);return Lsteps;}/*probcompgivenallsteps - calculates the probability of X compatibilities given Y steps and observed matrix.Neads:	matrix: empirical character matrix	ctype: array giving character types (0: ordered; 1: unordered)	nstates: array giving the number of states per character	nchars: number of characters	empcomp: compatibility of matrix	bias: array giving biases in gains / loses for character, with 60 meaning P[increase]=0.6	maxd: maximum number of changes per character	notu: number of taxa	fossil: 0 if no fossils, 1 if fossils included.  	mbl: simulation parameters (origination, extinction, sampling, speciation mode)	debug: 0 if using a random number, 1 if using a number generated by the replicate for debugging purposes	UNKNOWN: value for "?"	INAP: value for inapplicableReturns:	PComp: each P[a][b] give the probability of a compatibilities given b steps. This is formatted for reading likelihoods.....**********************************************************************************************************************************************************/double **probcompgivenallsteps(long **matrix, int *ctype, int *nstates, int nchars, int notu, int empcomp, int comptype, int fossils, double *mbl, int *bias, int *maxd, int pars, int max, int debug, int UNKNOWN, int INAP){int		a, b,st,mreps,treps,truns, mruns;long	*compats;long	**simat, **tree;double	x;double	**Pcomp;Pcomp=dmatrix((nchars*(nchars-1))/2,1+(max-pars));printf("Enter the number of trees to evolve: ");scanf("%i",&treps);printf("\n");printf("Enter the number of matrices to evolve per tree: ");scanf("%i",&mreps);printf("\n");printf("The program will examine %d trees, generating %d matrices for each tree with\n",treps,mreps);printf("\t%d to %d steps to find the P[%d compatible pairs | steps].\n",pars,max,empcomp);printf("Note that for each matrix, it will check compatibility after each step from %d to %d steps\n",pars,max);printf("Doing tree #");tree=lmatrix(notu+2,notu);		/* also will give clade diversity in first cell */								/* finally, gives branch lengths in final two lines *//* set the simulated matrix equal to the true matrix initially - this will make things easier later */simat=lmatrix(notu,nchars);for (truns=0; truns<treps; ++truns)	{	if (debug==1)	srand((unsigned int) (truns));	/* This is easier because you do not know how many nodes you'll get when sampling over time */	if (fossils==1)	tree=evolvetreeVenn(notu, mbl, fossils);	/* if no fossil taxa, then just make a cladogram and a Venn tree from it */	else	{		tree=evolvecladogram(notu,tree);		tree=clademember(tree, notu, notu-1);		}	printf("%d matrix ",truns+1);		for (mruns=0; mruns<mreps; ++mruns)	{		printf("%d\n",mruns+1);		equallmatrix(simat,matrix,notu,nchars);		compats=evolvecompat(tree, notu, simat, nchars, nstates, ctype, bias, maxd, pars, max, comptype, UNKNOWN, INAP);		for (st=pars; st<=max; ++st)	{			a=compats[st-pars];			++Pcomp[a][st-pars];			}		for (b=(mruns+1); b>=1; b=b/10)	printf("\b");		printf("\b");		}	printf("\b\b\b\b\b\b\b");	for (b=(truns+1); b>=1; b=b/10)	printf("\b");	printf("\b");		free_lvector(compats);	}x=treps*mreps;for (b=0; b<(1+(max-pars)); ++b)	{	x=0;	for (a=0; a<(nchars*(nchars-1))/2; ++a)		x=Pcomp[a][b]+x;	for (a=0; a<(nchars*(nchars-1))/2; ++a)		Pcomp[a][b]=Pcomp[a][b]/x;	}free_lmatrix(simat,notu,nchars);free_lmatrix(tree,notu+2,notu);return Pcomp;}/*likelystepsperchar - calculates the probability of X compatibilities given Y steps and observed matrix.Neads:	matrix: empirical character matrix	nstates: array giving the number of states per character	ctype: array giving character types (0: ordered; 1: unordered)	maxd: maximum numbers of steps per character	compat: array giving number of compatibilties per character character types (0: ordered; 1: unordered)	nchars: number of characters	empcomp: compatibility of matrix	bias: array giving biases in gains / loses for character, with 60 meaning P[increase]=0.6	maxd: maximum number of changes per character	notu: number of taxa	fossil: 0 if no fossils, 1 if fossils included.  	mbl: simulation parameters (origination, extinction, sampling, speciation mode)	debug: 0 if using a random number, 1 if using a number generated by the replicate for debugging purposes	UNKNOWN: value for "?"	INAP: value for inapplicableReturns:	Lsteps: each L[a][b] give the probability of a compatibilities given b steps and the rest of the matrix. This is formatted for reading likelihoods.....**********************************************************************************************************************************************************/double **likelystepsperchar(long **matrix, int *nstates, int *ctype, int *maxd, int *bias, int *depend, int nchars, int empcompat, int comptype, int notu, int fossil, double *mbl, int debug, int UNKNOWN, int INAP){int	a, b, c, d, ch, sp, steps;int dcompat, mxst, mxdl, redch;int	truns, mruns, cruns;int	apo, dapo, unsc, logdp, mxdp;int	*dstates, *dtypes, *dmaxd, *dbias, *ddpnd, *sychos;long *chvector, **chmat;long **tree, **dsmatrix;double runs;unsigned long *compat;double **Lsteps, **denom;/* get the real compatibilities for each character */compat=char_comp(nstates,notu,matrix,ctype,nchars,comptype,0,UNKNOWN,INAP);/* see if there are dependent inapplicables */a=0;for (ch=0; ch<nchars && a==0; ++ch)	if (depend[ch]!=ch)	a=1;sychos=ivector(nchars);				/* sychos[x] gives the number of characters depending of character x */if (a==1)	for (ch=0; ch<nchars && a==0; ++ch)	++sychos[depend[ch]]; else	clearivector(sychos,nchars,1);/* allocate memory for "dummy" arrays & matrices - these simply jackknife the real data to make a nchars-1 matrix & character info */dstates=ivector(nchars);dtypes=ivector(nchars);dmaxd=ivector(nchars-1);dbias=ivector(nchars-1);ddpnd=ivector(nchars-1);dsmatrix=lmatrix(notu, nchars);chvector=lvector(notu);mxdp=maxiarray(sychos,nchars);if (mxdp>1)	chmat=lmatrix(notu,mxdp);mxdl=maxiarray(maxd,nchars);	/* maximum number of changes possible for any character */if (mxdl>notu)	mxdl=notu-1;Lsteps=dmatrix(nchars,2*mxdl);denom=dmatrix(nchars,mxdl);printf("For each character, this routine will generate X trees and Y matrices per tree.\n");printf("  Each matrix is of N-1 characters, with N being the observed number.  The compatibility.\n");printf("  of each matrix will be the same as the compatibility of the other N-1 characters in\n");printf("  the observed matrix.  The program then will evolve the character K, K+1, K+2É steps Z times\n");printf("  (with K being one less than the number of states).  The program then calculate the\n");printf("  compatibility of the character.  It also will determine whether the proper number of states\n");printf("  and the proper number of derived taxa evolve.  Over X*Y*Z runs, this will determine the\n");printf("  probability of the observed structure of each character given K, K+1, etc., steps.  \n");printf("Enter the number of trees to use for each character (X above): ");scanf("%i",&truns);printf("\n");printf("Enter the number of matrices to evolve per tree (Y above): ");scanf("%i",&mruns);printf("\n");printf("Enter the number of times to replicate each number of steps (Z above): ");scanf("%i",&cruns);printf("\n");printf("The program will examine %d trees, generating %d matrices for each tree with\n",truns,mruns);printf("\teach number of steps replicated %d times to find L[setps | CPs, states, apomorphies].\n",cruns);for (ch=0; ch<nchars; ++ch)	{	redch=0;	/* reduced number of characters */	logdp=0;	/* rewrite array of dependents to take into account that the characters are migrating */	for (c=0; c<nchars; ++c)	{		/************************************************************************************/		/* logdp counts the logical dependents; it will be at least 1 when we reach ch		*/		/*    if there are multiple dependents, then it will be >1;	 The reduced matrix		*/		/*    removed all characters dependent on ch (including ch); thus, the properies of	*/		/*    the remaining characters must be moved up; the logical dependence must be		*/		/*    changed because the character numbers change.  For example, if chars. 4 & 5	*/		/*    depend on char. 3 and we remove char. 1, then char. 3 becomes char. 2 and 	*/		/*	  chars. 4&5 become 3&4 and dependent on 2.  Note that when we remove 3, chars	*/		/*    1 & 2 stay put, but char. 6 is moved up to char. 3 because 4 & 5 also are		*/		/*    removed.  Those will be evolved along with char. 3 after the matrix evolves.  */		/************************************************************************************/		if (depend[c]==ch)	++logdp;		else	{			dstates[c-logdp]=nstates[c];			dtypes[c-logdp]=ctype[c];			dmaxd[c-logdp]=maxd[c];			dbias[c-logdp]=bias[c];			ddpnd[c-logdp]=depend[c]-logdp;			++redch;			}		}	/* clear vector for character change */	if (logdp==1)	for (sp=0; sp<notu; ++sp)	chvector[sp]=matrix[sp][ch];	else		/* count the unknowns and inapplicables */	unsc=0;	for (sp=0; sp<notu; ++sp)	if (matrix[sp][ch]==UNKNOWN || matrix[sp][ch]==INAP)	++unsc;		dstates[nchars-1]=nstates[ch];	dtypes[nchars-1]=ctype[ch];	apo=autapo_char(matrix,notu,ch,UNKNOWN,INAP);	dcompat=empcompat-compat[ch];	for (c=0; c<nchars; ++c)	{		/* remove compatibilities of logically dependent characters */		if (depend[c]==ch && c!=ch)			dcompat=dcompat-compat[c];		}	/* create reduced matrix and character info arrays excluding character ch and any characters logically dependent upon it*/	c=0;	for (a=ch; a<nchars; ++a)		if (depend[a]!=ch)		for (b=0; b<notu; ++b)	dsmatrix[b][c]=matrix[b][a];		/* evolve a tree to evolve characters over */	if (debug==1)	srand((unsigned int) ch);	for (a=0; a<truns; ++a)	{		/* This is easier because you do not know how many nodes you'll get when sampling over time */		if (fossil==1)	tree=evolvetreeVenn(notu, mbl, fossil);		/* if no fossil taxa, then just make a cladogram and a Venn tree from it */		else	{			tree=evolvecladogram(notu,tree);			tree=clademember(tree, notu, notu-1);			}		if (debug==1)	srand((unsigned int) ch);		/* if character is apomorphic, then skip this part - it has a perfect compatibility regardless */		if (apo>1 || (apo+unsc)<notu-1)	{			for (b=0; b<mruns; ++b)	{				/* now evolve the reduced matrix until it matches the compatibility of the other nchar-1 characters 		*/				/* What we will do is seed the random number generator with a particular value and retain that value;		*/				/* We then use the evolvecompat routine to generate an array of compatibilities per step; if the desired	*/				/* compatibility is in that array, then we will use evolvematrix to evolve that matrix AFTER reseeding the	*/				/* random number generator with the same seed with the number of steps known to produce the desired 		*/				/* compatibility.  This means that we need to keep track of our random numbers!								*/				dsmatrix=evolvetocompat(tree,dcompat,notu,dsmatrix,redch,dstates,dtypes,dbias,dmaxd,ddpnd,comptype,UNKNOWN,INAP);								/* now, find the probability of getting observed compatibility AND observed apomorphy distribution given rates */				for (c=0; c<cruns; ++c)	{					/* easy routine for characters with no dependents */					if (logdp==1)	{						for (steps=nstates[ch]-1; steps<maxd[ch]+4 && steps<(notu-1); ++steps)	{							/* now, evolve character */							chvector=evolvecharacterNsteps(tree,steps,notu,chvector,nstates[ch],ctype[ch],bias[ch],UNKNOWN,INAP);							/* next, add it to the rest of the matrix */							for (sp=0; sp<notu; ++sp)	dsmatrix[sp][nchars-1]=chvector[sp];							/* find its compatibility */							d=char_nu_comp(nchars-1, dstates, notu, dsmatrix, dtypes, nchars, comptype, 0, UNKNOWN, INAP);							/* now see if compatibilities match */							if (nstates[ch]>2 && ctype[ch]==0)	{								mxst=0;								for (sp=0; sp<notu; ++sp)									if (chvector[sp]!=UNKNOWN && chvector[sp]!=INAP)										if (chvector[sp]>mxst)	mxst=chvector[sp];								}							else	mxst=nstates[ch]-1;							if (d==compat[ch] && mxst==(nstates[ch]-1))	{								++Lsteps[ch][steps];								dapo=autapo_char(dsmatrix,notu,nchars-1,UNKNOWN,INAP);								if (dapo==apo || (notu-dapo)==apo)	++Lsteps[ch][notu+steps];								}	/* end examination of whether we duplicated compatibility */							++denom[ch][steps];	/* increment number of runs */							}	/* end run of possible steps */						}	/* end case where character has no logical dependents */										/* more difficult routine for those with depdendents */					else	{						for (steps=nstates[ch]-1; steps<maxd[ch]+4 && steps<(notu-1); ++steps)	{							/* now, evolve character */							chvector=evolvecharacterNsteps(tree,steps,notu,chvector,nstates[ch],ctype[ch],bias[ch],UNKNOWN,INAP);							/* next, add it to the rest of the matrix */							for (sp=0; sp<notu; ++sp)	dsmatrix[sp][nchars-logdp]=chvector[sp];							/* find the characters compatibility compatibility 						*/							/* note: you need to omit the dependent characters in two ways; 		*/							/*   1) simulated charact is #chars-dependents (not #chars-1)			*/							/*   2) because all dependents are compatible with their independent,	*/							/*      we want to look for #compatibilites - dependents				*/							d=char_nu_comp(nchars-logdp, dstates, notu, dsmatrix, dtypes, (nchars-logdp+1), comptype, 0, UNKNOWN, INAP);														/* now see if compatibilities match */							/* first, determine the maximum number of st */							if (nstates[ch]>2)	{								mxst=0;								for (sp=0; sp<notu; ++sp)									if (chvector[sp]!=UNKNOWN && chvector[sp]!=INAP)										if (chvector[sp]>mxst)	mxst=chvector[sp];								}							else	mxst=nstates[ch]-1;							if (d==compat[ch]-logdp && mxst==(nstates[ch]-1))	{								++Lsteps[ch][steps];								dapo=autapo_char(dsmatrix,notu,nchars-1,UNKNOWN,INAP);								/* if we replicate the number of taxa with derived conditions, continue */								if (dapo==apo || (notu-dapo)==apo)	{									++Lsteps[ch][notu+steps];									/* if we have the right number of apomorphies, then evolve the dependent characters */									if (dapo==apo)	{										/* the minimum number of steps could be 0 IF the number of steps for the independent matches 	*/										/* the number of states for the dependent character												*///										for ()										}									}	/* tally cases where everything matches */								}	/* end examination of whether we duplicated compatibility */														}	/* end run of possible steps */						}	/* end case where character has logical dependents */					}	/* end runs for evolving character */				}	/* end evolved matrices */			}	/* end case for non-apomorphic taxa */		/* if apomorphic, then just determine the probability of apomorphy given K, K+1, K+2, etc. steps. */		else	{			for (b=0; b<mruns*cruns; ++b)	{				for (steps=nstates[ch]-1; steps<maxd[ch]+3 && steps<notu; ++steps)	{					chvector=evolvecharacterNsteps(tree,steps,notu,chvector,nstates[ch],ctype[ch],bias[ch],UNKNOWN,INAP);					dapo=0;					/* if only one taxon has '1' or if all but one have '1' then it is apomorphic */					for (sp=0; sp<notu; ++sp)	if (chvector[ch]==1)	++dapo;					if (dapo==1 || dapo==(notu-unsc-1))	{						++Lsteps[ch][steps];						++Lsteps[ch][notu+steps];						}	/* tally apomorphic successes */					}	/* end X steps */				}	/* do this mruns*cruns times just to make it as common as the other runs */			}	/* end routine for apomorphic states */		}	/* end evolved trees */		dstates[ch]=nstates[ch];	dtypes[ch]=dtypes[ch];	dmaxd[ch]=maxd[ch];	}runs=truns*mruns*cruns;free_ulvector(compat);free_ivector(dstates);free_ivector(dtypes);free_ivector(dmaxd);free_ivector(dbias);free_lmatrix(dsmatrix,notu, nchars);free_lvector(chvector);if (mxdp>1)	free_lmatrix(chmat,notu,mxdp);return Lsteps;}
/* Routines to manipulate matrices/arrays already in computer memory.  /*	Peter Wagner	05/02/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */#define matrixanalysis#include "matrixanalysis.h"#include "matrixchange.h"#include "matrixreading.h"#include "memory.h"#include "minmax.h"#include <stdlib.h>#include <stdio.h>#include <time.h>#include <math.h>#include <string.h>/* RawDist - returns a matrix wgiving number of differing characters		and the number of comparable characters		/*/* Requires: /*		mat: species X character matrix of character states/*		notu: number of species/*		nchars: number of characters***************************************************************************************/long **RawDist(long **mat, int notu, int nchars, int UNKNOWN, int INAP){int sp1, sp2, ch;long	**DistMat;DistMat=lmatrix(notu,notu);for (sp1=0; sp1<notu-1; ++sp1)	{	for (sp2=sp1+1; sp2<notu; ++sp2)	{		DistMat[sp1][sp2]=DistMat[sp2][sp1]=0;		for (ch=0; ch<nchars; ++ch)	{			while (ch<nchars && ((mat[sp1][ch]==UNKNOWN || mat[sp1][ch]==INAP) || (mat[sp2][ch]==UNKNOWN || mat[sp2][ch]==INAP)))	++ch;			if (ch>=nchars)	break;			if (mat[sp1][ch]!=mat[sp2][ch])	++DistMat[sp1][sp2];				++DistMat[sp2][sp1];			}		}	}return DistMat;}/* PhenDis - returns a matrix giving phenetic dissimilarity bn. species/*/* Requires: /*		Dmat: species X species matrix of raw differences & comparable states/*		notu: number of species***************************************************************************************/double **PhenDist(long **DMat, int notu){int 	sp1, sp2;double	x,y;double	**PD;PD=dmatrix(notu,notu);for (sp1=0; sp1<notu-1; ++sp1)	{	for (sp2=sp1+1; sp2<notu; ++sp2)	{		x=DMat[sp1][sp2];		y=DMat[sp2][sp1];		if (y==0)	y=1;		PD[sp1][sp2]=PD[sp2][sp1]=x/y;		}	}return PD;}/* PhenDis - returns a matrix giving phenetic dissimilarity bn. species/*/* Requires: /*		Dmat: species X species matrix of raw differences & comparable states/*		notu: number of species***************************************************************************************/double **PhDfromData(long **mat, int notu, int nchars, int UNKNOWN, int INAP){int 	sp1, sp2, ch;double	denom;double	**PD;PD=dmatrix(notu,notu);for (sp1=0; sp1<notu-1; ++sp1)	{	for (sp2=sp1+1; sp2<notu; ++sp2)	{		denom=PD[sp1][sp2]=PD[sp2][sp1]=0;		for (ch=0; ch<nchars; ++ch)	{			while (ch<nchars && ((mat[sp1][ch]==UNKNOWN || mat[sp1][ch]==INAP) || (mat[sp2][ch]==UNKNOWN || mat[sp2][ch]==INAP)))	++ch;			if (ch>=nchars)	break;			if (mat[sp1][ch]!=mat[sp2][ch])	++PD[sp1][sp2];				++denom;			}		if (denom==0)	denom=1;		PD[sp1][sp2]=PD[sp2][sp1]=(PD[sp1][sp2]/denom);		}	}return PD;}/* PhD - Returns the phenetic distance between two species/* Requires:/*		sp1: species 1's characters/*		sp2: species 2's characters/*		nchars: # characters/*		UNKNOWN: number for unknown characters/*		INAP: number for inapplicable characters/*/* Returns:/*		pd: proportion of characters that differ***************************************************************************************/double PhD(long *sp1, long *sp2, int nchars, int UNKNOWN, int INAP){int		ch;double	pd=0, denom=0;for (ch=0; ch<nchars; ++ch)	{	while (ch<nchars && ((sp1[ch]==UNKNOWN || sp1[ch]==INAP) || (sp2[ch]==UNKNOWN || sp2[ch]==INAP)))		++ch;	if (ch>=nchars)	break;	if (sp1[ch]!=sp2[ch])	++pd;	++denom;	}if (denom==0)	denom=1;pd=pd/denom;return pd;}/*Function returning the similarities among characters (see OÕKeefe & Wagner 2001 Syst. Biol.) 	given a compatibility matrix.Needs:	comatrix: binary matrix, such as a char x char compatibility matrix, 		with 1 = compatible and 0 = incompatible	n: number of characters*****************************************************************************/double **binarydis(unsigned long **matrix, int n){int		i, j;double	x, nn;double	**m;m=dmatrix(n,n);nn=n-1;for (i=0; i<n-1; ++i)	{	m[i][i]=0;	for (j=i+1; j<n; ++j)	{		x=matrix[i][j];		x=x/n;		m[i][j]=x;		m[j][i]=m[i][j]=1-m[i][j];		}	}return m;}/*Function returning the similarities among characters (see OÕKeefe & Wagner 2001 Syst. Biol.) 	given a compatibility matrix.Needs:	comatrix: binary matrix, such as a char x char compatibility matrix, 		with 1 = compatible and 0 = incompatible	n: number of characters*****************************************************************************/double **propshared(unsigned long **matrix, int n){int		i, j;double	x;double	**m;m=dmatrix(n,n);for (i=0; i<n-1; ++i)	{	for (j=i; j<n; ++j)	{		x=matrix[i][j];		x=x/n;		m[i][j]=x;		m[j][i]=m[i][j]=1-m[i][j];		}	}return m;}/*Function returning the similarities among characters given mutual compatiblity (see OÕKeefe & Wagner 2001 Syst. Biol.) 	given a compatibility matrix.Neads:	comatrix: binary matrix, such as a char x char compatibility matrix, 		with 1 = compatible and 0 = incompatible	n: number of characters*****************************************************************************/double **gowertrans(double **matrix, int n){int		i, j;double	ave;double **dmat;double	*average;double	**gower;dmat=dmatrix(n,n);for (i=0; i<n; ++i)	for (j=0; j<n; ++j)		dmat[i][j]=-0.5*matrix[i][j];		gower=dmatrix(n,n);average=dvector(n);for (i=0; i<n; ++i)	average[i]=dvectoraver(dmat[i],n);ave=dmatrixaver(dmat,n,n);for (i=0; i<n-1; ++i)	{	for (j=i+1; j<n; ++j)	{		gower[i][j]=gower[j][i]=matrix[i][j]-(average[i]+average[j])+ave;		}	}free_dvector(average);free_dmatrix(dmat,n,n);return gower;}/* dvectoraver - calculates the average value in vector v;/*/* Requires:/*		v - an array of real numbers;/*		n - the length of the array;/* Returns:/*		ave - the average value;***************************************************************************************/double dvectoraver(double *v, int n){double denom=0.0f, sum=0.0f, ave=0.0f;denom=n;sum=sumdvector(v,n);ave=sum/denom;return ave;}/* dmatrixaver - calculates the average value in vector v;/*/* Requires:/*		m - an array of real numbers;/*		r - the number of rows;/*		c - the number of columns;/* Returns:/*		ave - the average value;***************************************************************************************/double dmatrixaver(double **m, int r, int c){int a, b;double denom=0.0f, sum=0.0f, ave=0.0f;for (a=0; a<r; ++a)	{	for (b=0; b<c; ++b)	{		sum=sum+m[a][b];		++denom;		}	}ave=sum/denom;return ave;}/* sumdarray - sums two arrays of real numbers/*/* Requires:/*		i - the array of sums;/*		j - an array of real numbers;/*		k - another array of real numbers;/*		N - the length of the array;/* Returns:/*		i - the sum of the elements;***************************************************************************************/double *sumdvectors(double *i, double *j, double *k, int N){int	a;for (a=0; a<N; ++a)	i[a]=k[a]+j[a];return i;}/* sumivectosr - sums two arrays of real numbers/*/* Requires:/*		i - the array of sums;/*		j - an array of real numbers;/*		k - another array of real numbers;/*		N - the length of the array;/* Returns:/*		i - the sum of the elements;***************************************************************************************/int *sumivectors(int *i, int *j, int *k, int N){int	a;for (a=0; a<N; ++a)	i[a]=k[a]+j[a];return i;}/* sumivector - sums one array of integer/*/* Requires:/*		i - the array of sums;/*		j - an array of real numbers;/*		k - another array of real numbers;/*		N - the length of the array;/* Returns:/*		i - the sum of the elements;***************************************************************************************/int sumivector(int *i, int N){int	a, s=0;for (a=0; a<N; ++a)	s=s+i[a];return s;}/* sumivector - sums one array of integer/*/* Requires:/*		i - the array of sums;/*		j - an array of real numbers;/*		k - another array of real numbers;/*		N - the length of the array;/* Returns:/*		i - the sum of the elements;***************************************************************************************/double sumdvector(double *i, int N){int	a;double s=0.0f;for (a=0; a<N; ++a)	s=s+i[a];return s;}/* countivector - counts the number of nonzero elements in an array.  /*/* Requires:/*		i - the array of sums;/*		j - an array of real numbers;/*		k - another array of real numbers;/*		N - the length of the array;/* Returns:/*		i - the sum of the elements;***************************************************************************************/int countivector(int *i, int N){int	a, s=0;for (a=0; a<N; ++a)	if (i[a]>0)	++s;return s;}/* darraytotal - returns the sum of values in an array of real numbers/*/* Requires:/*		d - an array of real numbers;/*		N - the length of the array;/* Returns:/*		T - the sum of the elements;***************************************************************************************/double darraytotal(double *d, int N){int		i;double	T=0;for (i=0; i<N; ++i)	T=T+d[i];return T;}/* intarraytotal - returns the sum of values in an array of integers/*/* Requires:/*		d - an array of integers;/*		N - the length of the array;/* Returns:/*		T - the sum of the elements;***************************************************************************************/int iarraytotal(int *d, int N){int		i, T=0;for (i=0; i<N; ++i)	T=T+d[i];return T;}/* larraytotal - returns the sum of values in an array of integers/*/* Requires:/*		d - an array of integers;/*		N - the length of the array;/* Returns:/*		T - the sum of the elements;***************************************************************************************/long larraytotal(long *d, int N){int		i;long	T=0;for (i=0; i<N; ++i)	T=T+d[i];return T;}/* charraydifferences - Returns the number of differences between two species/* Requires:/*		sp1: species 1's characters/*		sp2: species 2's characters/*		nchars: # characters/*		UNKNOWN: number for unknown characters/*		INAP: number for inapplicable characters/*/* Returns:/*		diffs: number of characters that differ***************************************************************************************/int charraydifferences(long *sp1, long *sp2, int nchars, int UNKNOWN, int INAP){int		ch, diffs=0;for (ch=0; ch<nchars; ++ch)	{	while (ch<nchars && ((sp1[ch]==UNKNOWN || sp1[ch]==INAP) || (sp2[ch]==UNKNOWN || sp2[ch]==INAP)))		++ch;	if (ch>=nchars)	break;	if (sp1[ch]!=sp2[ch])	++diffs;	}return diffs;}/* charraycomparable - Returns the number of characters comparable between two species/* Requires:/*		sp1: species 1's characters/*		sp2: species 2's characters/*		nchars: # characters/*		UNKNOWN: number for unknown characters/*		INAP: number for inapplicable characters/*/* Returns:/*		comp: proportion of characters that differ***************************************************************************************/int charraycomparable(long *sp1, long *sp2, int nchars, int UNKNOWN, int INAP){int		ch, comp=0;for (ch=0; ch<nchars; ++ch)	{	while (ch<nchars && ((sp1[ch]==UNKNOWN || sp1[ch]==INAP) || (sp2[ch]==UNKNOWN || sp2[ch]==INAP)))		++ch;	if (ch>=nchars)	break;	++comp;	}return comp;}/* ihistogram - Returns array h in which h[x] gives the number of times x is observed in array v/* Requires:/*		v: data array/*		n: length of data array/*/* Returns:/*		histo: array where histo[x] gives the number of times x occurs in v/* NOTE: returned vector is long***************************************************************************************/long *ilhistogram (int *v, int n){int i, mn, mx;long *histo;mx=maxiarray(v,n);mn=miniarray(v,n);histo=lvector((mx-mn)+2);for (i=0; i<n; ++i)	++histo[v[i]];return histo;}/* lhistogram - Returns array h in which h[x] gives the number of times x is observed in array v/* Requires:/*		v: data array/*		n: length of data array/*/* Returns:/*		histo: array where histo[x] gives the number of times x occurs in v/* NOTE: returned vector is long***************************************************************************************/long *llhistogram (long *v, int n){int i, mn, mx;long *histo;mx=maxlarray(v,n);mn=minlarray(v,n);histo=lvector((mx-mn)+2);for (i=0; i<n; ++i)	++histo[v[i]];return histo;}/* ihistogram - Returns array h in which h[x] gives the number of times x is observed in array v/* Requires:/*		v: data array/*		n: length of data array/*/* Returns:/*		histo: array where histo[x] gives the number of times x occurs in v/* NOTE: returned vector is double***************************************************************************************/double *idhistogram (int *v, int n){int i, mn, mx;double *histo;mx=maxiarray(v,n);mn=miniarray(v,n);histo=dvector(2*((mx-mn)+2));for (i=0; i<n; ++i)	++histo[v[i]];return histo;}/* lhistogram - Returns array h in which h[x] gives the number of times x is observed in array v/* Requires:/*		v: data array/*		n: length of data array/*/* Returns:/*		histo: array where histo[x] gives the number of times x occurs in v/* NOTE: returned vector is double***************************************************************************************/double *ldhistogram (long *v, int n){int i, mn, mx;double *histo;mx=maxlarray(v,n);mn=minlarray(v,n);histo=dvector(2*((mx-mn)+2));for (i=0; i<n; ++i)	++histo[v[i]];return histo;}/* codedcombinations - Returns a long matrix giving observed morphotypes (combinations) and a list of species with that morphotype/*	Requires:/*		matrix: character matrix/*		notu:	number of taxa/*		nchar:	number of characters/*		miss:	unknown score/*		gap:	inapplicable score/* Returns:/*		results:/*			results[0]: combination/*			results[1]: number of species with combination/*			results[2Én]: species number***************************************************************************************/long **codedcombinations (long **matrix, int notu, int nchar, int miss, int gap){int		a, b;int 	mxcm=0, mxtx=1, cell, unique=0, mc=0, nc;int		*states, *mxst, *combin, *combos, *code, *combrich;double	*observed;double	x,y,z;long	**results;code = ivector(notu);	/* this will give the morphotypes number for each taxon */states=numberstates(matrix, notu, nchar, miss, gap);mxst=maxcharstates(matrix, notu, nchar, miss, gap);combos=ivector(nchar);for (a=0; a<nchar; ++a)	{	if (a<(nchar-1))	combos[a]=states[a+1];	else				combos[a]=1;	for (b=a+2; b<nchar; ++b)		combos[a]=combos[a]*states[b];	}/* find the number of combinations */mxcm=states[0];for (a=1; a<nchar; ++a)	if (states[a]>1)	mxcm=mxcm*states[a];combin=ivector(mxcm);		/* combinations */combrich=ivector(mxcm);		/* richness of each combination */if (mxcm<notu)	observed=dvector(mxcm);else			observed=dvector(notu);/*mnst=mincharstates(matrix, notu, nchar, miss, gap);*/nc=mxcm;/* reduce tab-delimited matrix to a single 'string' of numbers */ for (a=0; a<notu; ++a)	{	cell = 0;	for (b=0; b<nchar; ++b)	{/*		cell = cell+((matrix[a][b]-mnst[b])*combos[b]);	/* make sure that this can know that 0 is not the minimum! */		cell = cell+((matrix[a][b])*combos[b]);	/* make sure that this can know that 0 is not the minimum! */		}	if (cell>=mxcm || cell<0)	{		printf("WE HAVE A PROBLEM WITH TAXON %d: ",a+1);		for (b=0; b<nchar; ++b)	printf("%d",matrix[a][b]);		}	if (cell>mc)	mc=cell;	if (cell<nc)	nc=cell;		++combin[cell];	/* this marks the first time a morphotype is found */	if (combin[cell]==1)	{		y=10;		for (b=0; b<nchar; ++b)	{			x=matrix[a][b];			x/=y;			observed[unique]+=x;	/* condense morphotype to a single number */			y*=10;			}	/* finish condensing morphotype to a single numberr */		code[a]=unique;		/* assign morphotype to species */		combrich[unique]=1;		++unique;		}	/* end case	/* the morphotype has been found before */	else	{		y=10;		z=0;		for (b=0; b<nchar; ++b)	{			x=matrix[a][b];			x/=y;			z+=x;			y*=10;			}		for(b=0; b<unique; ++b)	{			if (z==observed[b])	{				code[a]=b;	/* assign morphotype to species */				++combrich[b];				if (combrich[b]>mxtx)	mxtx=combrich[b];				b=unique;				}	/* z and species a is morphotype b */			}	/* end search to see if z has been seen */		}	/* end case where morphotype is not new */	}	/* end search of species */for (a=0; a<unique; ++a)	observed[a]*=pow(10,nchar);results=lmatrix(unique,mxtx+3);	/* results[a][0]: morphotype; results[a][1]: richness; results[a][2Émxtx+1]: taxon #'s */for (a=0; a<unique; ++a)	{	results[a][0]=observed[a];	results[a][1]=combrich[a];	}clearivector(combrich,mxcm,0);for (a=0; a<notu; ++a)	{	b=code[a];	results[b][2+combrich[b]]=a;	++combrich[b];	}free_ivector(states);free_ivector(combin);free_ivector(combos);free_ivector(code);free_ivector(combrich);free_ivector(mxst);free_dvector(observed);return results;}
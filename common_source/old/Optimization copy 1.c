#define Optimization#include "Optimization.h"#define memory#include "memory.h"#define matrixchange#include "matrixchange.h"#define matrixreading#include "matrixreading.h"#define minmax#include "minmax.h"/* Parsimony: finds the minimum number of steps needed for a tree to yield a matrix/*/* Requires: /*	chmatrix: taxon X character matrix of character states/*	tree: matrix giving tree, with first element giving # of branches and next X giving OTU/HTU # for branch/*	statetypes: character X states matrix giving states of each character/*	nstate: array giving the number of states for each character/*	ctype: array giving the type of each character (0: unordered; 1: ordered)/*	notu: number of taxa/*	nchars: number of characters/*	OUTGROUP: taxon that is the outgroup/*	INAP: code for inapplicable characters/*	UNKNOWN: code for unknown state/*/* Returns:/*	chmatrix: matrix modified to include ancestral conditions***************************************************************************************/long** Parsimony(long **chmatrix, long **tree, int** statetypes, int* nstate, int* ctype, int clades, int notu, int nchars, int OUTGROUP, int INAP, int UNKNOWN){int		a, b, c, depend, anc, ch, sp1, sp2, sp3, sp4, sp5, sp6, node, maxtaxa, undec, mnst, mxst;int		*dependents,*ictype, *instate, **istatetypes, *BL, *stpres;long	**indmatrix;long	/**invmatrix*/invmatrix[40][40], **iinvmatrix;		/* for debugging */float	e, f, x, y, w, z;depend = inapplicables(chmatrix,notu,nchars,INAP);//invmatrix=TransposeLong(chmatrix,notu+clades,nchars);//invmatrix=lmatrix(nchars,notu+clades);undec=INAP+UNKNOWN;mxst=maxiarray(nstate,nchars);stpres=ivector(mxst+3);for (sp1=0; sp1<notu; ++sp1)	for (ch=0; ch<nchars; ++ch)	invmatrix[ch][sp1]=chmatrix[sp1][ch];if (depend>0)	{	dependents=inaplist(chmatrix,notu,nchars,INAP,depend);	indmatrix=IndependentsMatrix(chmatrix, dependents, depend, notu, nchars, INAP, UNKNOWN);		ictype=ivector(depend);	instate=ivector(depend);	clearivector(instate,depend,2);		istatetypes=imatrix(depend,2);	for (a=0; a<depend; ++a)	for (b=0; b<2; ++b)	istatetypes[a][b]=b;		indmatrix=Parsimony(indmatrix,tree,istatetypes,instate,ictype,clades,notu,depend,OUTGROUP,INAP,UNKNOWN);	iinvmatrix=TransposeLong(indmatrix,notu+clades,depend);		for (c=0; c<depend; ++c)	{		ch=dependents[c];		for (sp1=notu; sp1<clades+notu; ++sp1)	{			if (indmatrix[sp1][c]==0)				chmatrix[sp1][ch]=INAP;			else if (indmatrix[sp1][c]==1)			chmatrix[sp1][ch]=0;			else if (indmatrix[sp1][c]==UNKNOWN)	chmatrix[sp1][ch]=UNKNOWN;			invmatrix[ch][sp1]=chmatrix[sp1][ch];			}		}	}	/* clear ancestral conditions */maxtaxa = 2*notu;a=0;for (node=0; node<clades; ++node)	{	if (depend>0)	{		for (ch=0; ch<nchars; ++ch)	{			if (ch!=dependents[a])				invmatrix[ch][node+notu]=chmatrix[node+notu][ch]=undec;			else	++a;			}		}	else	{		for (ch=0; ch<nchars; ++ch)			invmatrix[ch][node+notu]=chmatrix[node+notu][ch]=undec;		}	}/*** Find Shared States between Sister Taxa ***/for (ch=0; ch<nchars; ++ch)	{	mnst=miniarray(statetypes[ch],nstate[ch]);	mxst=maxiarray(statetypes[ch],nstate[ch]);	clearivector(stpres,mxst+3,0);			for (node=clades-1; node>=0; --node)	{		anc = notu+node;		if (tree[node][1]<tree[node][2])	{			sp1 = tree[node][1];			sp2 = tree[node][2];			}		else	{			sp2 = tree[node][1];			sp1 = tree[node][2];			tree[node][1]=sp1;			tree[node][2]=sp2;			}			if (chmatrix[anc][ch]!=INAP)	{			e = chmatrix[sp1][ch];			f = chmatrix[sp2][ch];			/* if the states are the same, then set the ancestor to equal descendants */			/* if both species are unknown, then the node is legitimately unknown	  */			if (e==f && e!=undec)				chmatrix[anc][ch] = e;						/* species do not match - ancestor is undecided */			else if (sp1<=notu && sp2<=notu)	chmatrix[anc][ch]=undec;			/* if two unknown / inapplicable species then ancestor should be unknown or inapplicable */			else if ((e==f && (e<mnst || e>mxst)) && (sp1<=notu && sp2<=notu))	{				if (nstate[ch]==1)				chmatrix[anc][ch] = statetypes[ch][1];				else							chmatrix[anc][ch]=UNKNOWN;	/* 2 unknown species */				}						/* if one is legitimately unknown but the other is not, then make ancestor equivalent to known species */			else if (f==UNKNOWN && (e>=mnst && e<=mxst))				chmatrix[anc][ch]=e;					/* known with unknown */			else if (e==UNKNOWN && (f>=mnst && f<=mxst))				chmatrix[anc][ch]=f;					/* ditto			*/						/* if one is a species and unknown, then the node equals the known species */			/*  Or, if sister clade is full of unknowns, clade is kept as unknown */			else if (e==undec && sp1<=notu)		chmatrix[anc][ch]=f;			else if (f==undec && sp2<=notu)		chmatrix[anc][ch]=e;						/* ROUTINES FOR AMBIGUOUS CLADES WITHIN NODES */			/* Routine for Binary Character an ambiguous clade with known sister taxon & a binary character - assign sister taxon's state */			else if ((e>=mnst && e<=mxst) && ((f==undec && sp2>notu) && nstate[ch]==2))	{									invmatrix[ch][sp2]=chmatrix[anc][ch]=chmatrix[sp2][ch]=e;									}						else if ((f>=mnst && f<=mxst) && ((e==undec && sp1>notu) && nstate[ch]==2))	{									invmatrix[ch][sp1]=chmatrix[anc][ch]=chmatrix[sp1][ch]=f;									}			/** Routine for Unordered Multistate Characters **/			else if (ctype[ch]==1)	{				if ((f<mnst || f>mxst))	{					if (sp2>notu)	{						sp3=tree[sp2-notu][1];						sp4=tree[sp2-notu][2];						if (chmatrix[sp1][ch]==chmatrix[sp3][ch] || chmatrix[sp1][ch]==chmatrix[sp4][ch])												chmatrix[anc][ch] = chmatrix[sp2][ch] = chmatrix[sp1][ch];						else				chmatrix[anc][ch] = undec;						}					else					chmatrix[anc][ch] = undec;					}				else if ((e<mnst || e>mxst))	{					if (sp1>notu)	{						sp3=tree[sp1-notu][1];						sp4=tree[sp1-notu][2];						if (chmatrix[sp2][ch]==chmatrix[sp3][ch] || chmatrix[sp2][ch]==chmatrix[sp4][ch])											chmatrix[anc][ch] = chmatrix[sp1][ch] = chmatrix[sp2][ch];						else				chmatrix[anc][ch] = undec;						}					else					chmatrix[anc][ch] = undec;					}				else						chmatrix[anc][ch] = undec;				}			/** Routine for Ordered Multistates Characters **/	//		else							chmatrix[anc][ch] = (e+f)/2;			else if (nstate[ch]>2 && ctype[ch]==0)	{				if ((f<mnst || f>mxst) && (e>=mnst && e<=mxst))	{					if (sp2>notu)	{						sp3=tree[sp2-notu][1];						sp4=tree[sp2-notu][2];						x = chmatrix[sp3][ch];						y = chmatrix[sp4][ch];						chmatrix[anc][ch]=undec;						if (x>=0 && y>=0)	{							/* routine if continuous character is greater than outgroup state */							if (e<x && e<y)	{		/* outgroup is less than either */								if (x<y)	chmatrix[sp2][ch]=x;								else		chmatrix[sp2][ch]=y;								}							else if (e>x && e>y)	{	/* outgroup is greater than either */								if (x>y)	chmatrix[sp2][ch]=x;								else		chmatrix[sp2][ch]=y;								}							else	{								if (abs(e-x)<abs(e-y))		chmatrix[sp2][ch]=x;								else if (abs(e-x)>abs(e-y))	chmatrix[sp2][ch]=y;								else						chmatrix[sp2][ch]=e;								}							}						else if (x<0)						chmatrix[sp2][ch]=y;						else if (y<0)						chmatrix[sp2][ch]=x;						}					else					chmatrix[anc][ch] = chmatrix[sp1][ch];					}				else if ((e<mnst || e>mxst) && (f>=mnst && f<=mxst))	{					if (sp1>notu)	{						sp3=tree[sp1-notu][1];						sp4=tree[sp1-notu][2];						x = chmatrix[sp3][ch];						y = chmatrix[sp4][ch];						chmatrix[anc][ch]=undec;						if (x>=0 && y>=0)	{							/* routine if continuous character is greater than outgroup state */							if (f<x && f<y)	{		/* outgroup is less than either */								if (x<y)	chmatrix[sp1][ch]=x;								else		chmatrix[sp1][ch]=y;								}							else if (f>x && f>y)	{	/* outgroup is greater than either */								if (x>y)	chmatrix[sp1][ch]=x;								else		chmatrix[sp1][ch]=y;								}							else	{								if (abs(f-x)<abs(f-y))		chmatrix[sp1][ch]=x;								else if (abs(f-x)>abs(f-y))	chmatrix[sp1][ch]=y;								else						chmatrix[sp1][ch]=f;								}							}						}					}				/* routine if both taxa are ambiguous */				else if ((e<mnst || e>mxst) && (f<mnst || f>mxst))	{					if (sp1<=notu && sp2<=notu)				chmatrix[anc][ch] = undec;					else	{					/* two ambiguous sister clades!*/						chmatrix[anc][ch]=undec;						sp3=tree[sp1-notu][1];						sp4=tree[sp1-notu][2];						sp5=tree[sp2-notu][1];						sp6=tree[sp2-notu][2];												w = chmatrix[sp3][ch];						z = chmatrix[sp4][ch];						x = chmatrix[sp5][ch];						y = chmatrix[sp6][ch];												if ((w==x || w==y) && w>=0)							chmatrix[sp1][ch]=chmatrix[sp2][ch]=w;												else if ((z==x || z==y) && z>=0)							chmatrix[sp1][ch]=chmatrix[sp2][ch]=z;													else	{							if ((w<x && w<y) && (z<x && z<y))	{								if (w>z)		chmatrix[sp1][ch]=w;								else			chmatrix[sp1][ch]=z;								if (x<y)		chmatrix[sp2][ch]=x;								else			chmatrix[sp2][ch]=y;								}							else if ((w>x && w>y) && (z>x && z>y))	{								if (w<z)		chmatrix[sp1][ch]=w;								else			chmatrix[sp1][ch]=z;								if (x<y)		chmatrix[sp2][ch]=x;								else			chmatrix[sp2][ch]=y;								}							else	{								if (abs(chmatrix[sp3][ch]-chmatrix[sp5][ch])<abs(chmatrix[sp3][ch]-chmatrix[sp6][ch]))									x = w = abs(chmatrix[sp3][ch]-chmatrix[sp5][ch]);								else									y = w = abs(chmatrix[sp3][ch]-chmatrix[sp6][ch]);								if (abs(chmatrix[sp4][ch]-chmatrix[sp5][ch])<abs(chmatrix[sp4][ch]-chmatrix[sp6][ch]))									x = z = abs(chmatrix[sp4][ch]-chmatrix[sp5][ch]);								else									y = z = abs(chmatrix[sp4][ch]-chmatrix[sp6][ch]);								if (w<z)	chmatrix[sp1][ch]=abs(chmatrix[sp3][ch]);								else		chmatrix[sp1][ch]=abs(chmatrix[sp4][ch]);								if (x<y)	chmatrix[sp2][ch]=abs(chmatrix[sp5][ch]);								else		chmatrix[sp2][ch]=abs(chmatrix[sp6][ch]);								}							}						}					}						}		/* end routine for ordered multistates */			/* irreversibles */			else if (ctype[ch]==2)	{				if ((e>=mnst && e<=mxst) && (f>=mnst && f<=mxst))	{					if (e==chmatrix[OUTGROUP][ch])						chmatrix[anc][ch]=e;					else if (f==chmatrix[OUTGROUP][ch])						chmatrix[anc][ch]=f;					else						chmatrix[anc][ch]=UNKNOWN;	//				if (abs(chmatrix[sp1][ch]-chmatrix[OUTGROUP][ch])<abs(chmatrix[sp2][ch]-chmatrix[OUTGROUP][ch]))	//						chmatrix[anc][ch]=chmatrix[sp1][ch];	//				else	chmatrix[anc][ch]=chmatrix[sp2][ch];					}				else if (chmatrix[sp1][ch]>=0 && chmatrix[sp2][ch]<0)							chmatrix[anc][ch]=chmatrix[sp1][ch];				else if (chmatrix[sp1][ch]<0 && chmatrix[sp2][ch]>=0)							chmatrix[anc][ch]=chmatrix[sp2][ch];				else		chmatrix[anc][ch]=undec;				}						invmatrix[ch][anc]=chmatrix[anc][ch];						}		/* End Search of Node */		}	}		/* End First pass */a=findinlmatrix(chmatrix,notu+clades,nchars,undec,clades,clades+notu);if (a==1)	{	/*** Use Outgroup to Polarize Indeterminate Characters at Base of Tree ***/	for (ch=0; ch<nchars; ++ch)	{		mnst=miniarray(statetypes[ch],nstate[ch]);		mxst=maxiarray(statetypes[ch],nstate[ch]);		e = chmatrix[notu][ch];		if (chmatrix[notu][ch] == undec)	{			if (nstate[ch]==1)	chmatrix[notu][ch] = statetypes[ch][1];			else if (nstate[ch]==2 || ctype[ch]==1)	{				if (chmatrix[OUTGROUP][ch]!=UNKNOWN)					chmatrix[notu][ch] = chmatrix[OUTGROUP][ch];				else	{					for (a=0; a<clades; ++a)	{						for (b=0; b<=tree[a][0]; ++b)	{							sp1=tree[a][b];							if (chmatrix[sp1][ch]>=0)	{								chmatrix[notu][ch]=chmatrix[sp1][ch];								b=tree[a][0];								a=clades;								}							}						}					}				}			else if (nstate[ch]>=2 && ctype[ch]==0)	{				sp1 = tree[0][1];				sp2 = tree[0][2];								if (chmatrix[sp1][ch]<0 && sp1<=notu)			chmatrix[notu][ch] = chmatrix[sp2][ch];				if (chmatrix[sp2][ch]<0 && sp2<=notu)			chmatrix[notu][ch] = chmatrix[sp1][ch];				if (chmatrix[sp2][ch]<0 && chmatrix[sp1][ch]<0)																chmatrix[notu][ch] = chmatrix[OUTGROUP][ch];				else	{					if (abs(chmatrix[sp1][ch]-chmatrix[OUTGROUP][ch]) < abs(chmatrix[sp2][ch]-chmatrix[OUTGROUP][ch]))						chmatrix[notu][ch] = chmatrix[sp1][ch];					else if (abs(chmatrix[sp1][ch]-chmatrix[OUTGROUP][ch]) > abs(chmatrix[sp2][ch]-chmatrix[OUTGROUP][ch]))						chmatrix[notu][ch] = chmatrix[sp2][ch];					else						chmatrix[notu][ch] = (chmatrix[sp1][ch]+chmatrix[sp2][ch])/2;					}				}			}		invmatrix[ch][notu]=chmatrix[notu][ch];		}	/*** Use Successive Outgroups to Polarize Indeterminate Characters ***/	for (node=0; node<clades; ++node)	{		anc = notu+node;		sp1 = tree[node][1];		sp2 = tree[node][2];		while ((sp1<notu && sp2<notu) && node<clades)	{			++node;			sp1 = tree[node][1];			sp2 = tree[node][2];			}		if (node>=clades)	break;		if (sp1>=notu && sp2<notu)	{			sp1 = tree[node][2];			sp2 = tree[node][1];			}		for (ch=0; ch<nchars; ++ch)	{			mnst=miniarray(statetypes[ch],nstate[ch]);			mxst=maxiarray(statetypes[ch],nstate[ch]);			x = chmatrix[anc][ch];			e = chmatrix[sp1][ch];			f = chmatrix[sp2][ch];			if (sp1>=notu && sp2>=notu)	{				if (chmatrix[sp1][ch]<0)	chmatrix[sp1][ch]=chmatrix[anc][ch];				if (chmatrix[sp2][ch]<0)	chmatrix[sp2][ch]=chmatrix[anc][ch];				}			else if (sp1<notu && sp2>=notu)	{	/*			if (chmatrix[sp1][ch]<0)	*/				sp3=tree[sp2-notu][1];				sp4=tree[sp2-notu][2];								if (sp3>maxtaxa || sp4>maxtaxa)	{					printf("Descendant doesn't exist in clade %d!\n",sp2-notu);					exit(0);					}								w = chmatrix[sp3][ch];				z = chmatrix[sp3][ch];				if (chmatrix[sp3][ch]<0 && sp3<= notu)	{					if (sp4>=notu && chmatrix[sp4][ch]>=0)	chmatrix[sp2][ch]=chmatrix[sp4][ch];					else									chmatrix[sp2][ch]=chmatrix[anc][ch];					}				else if (chmatrix[sp4][ch]<0 && sp4<= notu)	{					if (sp3>=notu && chmatrix[sp4][ch]>=0)	chmatrix[sp2][ch]=chmatrix[sp3][ch];					else									chmatrix[sp2][ch]=chmatrix[anc][ch];					}				if (chmatrix[sp2][ch]<0)	{					/* Routine for Ordered Multistates - use state closest to ancestral form */					if (nstate[ch]>2 && ctype[ch]==0)	{						if (chmatrix[sp3][ch]>=0 && chmatrix[sp4][ch]>=0)	{							if (abs(chmatrix[sp3][ch]-chmatrix[anc][ch])<abs(chmatrix[sp4][ch]-chmatrix[anc][ch]))								chmatrix[sp2][ch]=chmatrix[sp3][ch];							else if (abs(chmatrix[sp3][ch]-chmatrix[anc][ch])>abs(chmatrix[sp4][ch]-chmatrix[anc][ch]))								chmatrix[sp2][ch]=chmatrix[sp4][ch];															else								chmatrix[sp2][ch]=(chmatrix[sp3][ch]+chmatrix[sp4][ch])/2;							}						else if (chmatrix[sp3][ch]<0)	{							a = chmatrix[sp4][ch] - chmatrix[anc][ch];							a = a/2;							chmatrix[sp3][ch]=chmatrix[sp3][ch]+a;							}						else if (chmatrix[sp4][ch]<0)	{							a = chmatrix[sp3][ch] - chmatrix[anc][ch];							a = a/2;							chmatrix[sp4][ch]=chmatrix[sp4][ch]+a;							}						}					/* Routine for irreversible characters */					else if (ctype[ch]==2)	{						if (w>=0 && z>=0)	{							if (abs(w-chmatrix[anc][ch])<(z-chmatrix[anc][ch]))	chmatrix[sp2][ch]=w;							else												chmatrix[sp2][ch]=z;							}						else if (w<0 && z<0)					chmatrix[sp2][ch]=chmatrix[anc][ch];						else if (w<0)							chmatrix[sp2][ch]=chmatrix[anc][ch];						else if (z<0)							chmatrix[sp2][ch]=chmatrix[anc][ch];						}					/* Routine for Unordered Multistates & Binaries (No Brainer here) */					else	chmatrix[sp2][ch] = chmatrix[anc][ch];					}				}			e = chmatrix[sp1][ch];			f = chmatrix[sp2][ch];			for (sp1=0; sp1<notu+clades; ++sp1)	invmatrix[ch][sp1]=chmatrix[sp1][ch];			}		}	}/* make sure that there are minimum uncertain ancestral reconstructions - they should be there only if all descendants are unknown */a=0;for (sp1=notu; sp1<(notu+clades) && a==0; ++sp1)	for (ch=0; ch<nchars && a==0; ++ch)		if (chmatrix[sp1][ch]==undec)	a=1;if (a>0)	{	BL=ivector(notu+clades);	for (node=0; node<clades; ++node)	{		anc=node+notu;		for (b=1; b<tree[node][0]; ++b)	{			sp1=tree[node][0];			if (chmatrix[anc][ch]!=chmatrix[sp1][ch])				if ((chmatrix[anc][ch]!=UNKNOWN && chmatrix[anc][ch]!=undec) && (chmatrix[anc][ch]!=INAP && chmatrix[sp1][ch]!=INAP))					++BL[sp1];									}		}	for (node=(clades-1); node>=0; --node)	{		for (ch=0; ch<nchars; ++ch)	{			if (chmatrix[anc=node+notu][ch]==undec)	{				sp1=tree[node][1];				for (b=2; b<=tree[node][0]; ++b)	{					sp2=tree[node][b];					if (BL[sp2]<BL[sp1])					sp1=sp2;					else if (chmatrix[sp1][ch]==UNKNOWN)	sp1=sp2;					}				invmatrix[ch][anc]=chmatrix[anc][ch]=chmatrix[sp1][ch];				}			}		}	free_ivector(BL);	}if (depend>0)	{	free_ivector(dependents);	free_lmatrix(indmatrix,notu,depend);	free_lmatrix(iinvmatrix,depend,notu);	free_ivector(ictype);	free_ivector(instate);	free_imatrix(istatetypes,depend,2);	}//free_lmatrix(invmatrix,notu+clades,nchars);return chmatrix;}/* BranchChanges: tells whether a character changes on a branch/*/* Requires: /*	chmatrix: taxon X character matrix of character states/*	tree: matrix giving tree, with first element giving # of branches and next X giving OTU/HTU # for branch/*	ctype: array giving the type of each character (0: unordered; 1: ordered)/*	notu: number of taxa/*	nchars: number of characters/*	INAP: code for inapplicable characters/*	UNKNOWN: code for unknown state/*/* Returns:/*	BC: branch X character matrix telling whether a character changes (1) or not (0) on a branch***************************************************************************************/int** BranchChanges(long **chmatrix, long **tree, int nchars, int clades, int notu, int INAP, int UNKNOWN){int	c, d, sp, anc, ch;int	**BC;BC=imatrix(2*notu,nchars);for (sp=0; sp<clades+notu; ++sp)	for (ch=0; ch<nchars; ++ch)	BC[sp][ch]=-5;for (c=0; c<clades; ++c)	{	anc=c+notu;	for (d=1; d<=tree[c][0]; ++d)	{		sp=tree[c][d];		for (ch=0; ch<nchars; ++ch)	{			if (chmatrix[anc][ch]!=chmatrix[sp][ch])	{				if ((chmatrix[anc][ch]!=INAP && chmatrix[anc][ch]!=UNKNOWN) && (chmatrix[sp][ch]!=INAP && chmatrix[sp][ch]!=UNKNOWN))	{					BC[sp][ch]=chmatrix[sp][ch];					}				}			}		}	}return BC;}	/* BranchLengths: finds the number of steps per branch for a tree to yield a matrix/*/* Requires: /*	chmatrix: taxon X character matrix of character states/*	tree: matrix giving tree, with first element giving # of branches and next X giving OTU/HTU # for branch/*	ctype: array giving the type of each character (0: unordered; 1: ordered)/*	notu: number of taxa/*	nchars: number of characters/*	clades: number of clades/*	INAP: code for inapplicable characters/*	UNKNOWN: code for unknown state/*/* Returns:/*	BL: array giving the number of changes per branch***************************************************************************************/int* BranchLengths(long **chmatrix, long **tree, int* ctype, int nchars, int clades, int notu, int INAP, int UNKNOWN){int	c, d, sp, anc, ch, steps;int	*BL;BL = ivector(clades+notu);//CS = ivector(nchars);steps=0;for (c=0; c<clades; ++c)	{	anc=c+notu;	for (d=1; d<=tree[c][0]; ++d)	{		sp=tree[c][d];		BL[sp]=0;		for (ch=0; ch<nchars; ++ch)	{			if (chmatrix[anc][ch]!=chmatrix[sp][ch])	{				if ((chmatrix[anc][ch]!=INAP && chmatrix[anc][ch]!=UNKNOWN) && (chmatrix[sp][ch]!=INAP && chmatrix[sp][ch]!=UNKNOWN))	{					if (ctype[ch]==1)	{						++BL[sp];//						++CS[ch];						}					else if (ctype[ch]==0)	{						BL[sp]=BL[sp]+abs(chmatrix[sp][ch]-chmatrix[anc][ch]);//						CS[ch]=CS[ch]+abs(chmatrix[sp][ch]-chmatrix[anc][ch]);						}					}				}			}		steps=steps+BL[sp];		}	}//free_ivector(CS);return BL;}/* ExhaustionCurve: yields a branch X 2 matrix giving the number of changes and the number of realized states/*/* Requires: /*	chmatrix: taxon X character matrix of character states/*	BC: matrix telling what changes on each branch/*	BL: array giving the type of each character (0: unordered; 1: ordered)/*	tree: matrix giving tree, with first element giving # of branches and next X giving OTU/HTU # for branch/*	clades: number of clades/*	notu: number of taxa/*	nchars: number of characters/*/* Returns:/*	EC: branch X 4 Exhaustion curve/*		EC[br][0]: cumulative branches/*		EC[br][1]: cumulative steps/*		EC[br][2]: realized characters/*		EC[br][3]: realized character states***************************************************************************************/int **ExhaustionCurve(long **chmatrix, int **BC, int *BL, int *FA, long **tree, int *nstates, int clades, int notu, int nchars){int	a, c, d, sp, ch, S, F, i, br, maxstate, states, nch, found;int	*chrealized;int **EC, **chobserved;nch=states=maxstate=br=d=0;for (c=0; c<clades+notu; ++c)	if (BL[c]>0)	++d;for (ch=0; ch<nchars; ++ch)		if (nstates[ch]>maxstate)	maxstate=nstates[ch];++maxstate;EC=imatrix(d,4);for (a=0; a<d; ++a)	for (c=0; c<4; ++c)	EC[a][c]=-1;chrealized = ivector(nchars);chobserved=imatrix(nchars,maxstate);S=FA[1];F=FA[1];for (ch=0; ch<nchars; ++ch)	{	for (a=0; a<maxstate; ++a)	chobserved[ch][a]=-1;	if (chmatrix[notu][ch]>=0 && chmatrix[notu][ch]<=maxstate)	{		chobserved[ch][0]=chmatrix[notu][ch];		chrealized[ch]=1;		}	else	chrealized[ch]=0;	}for (sp=2; sp<notu; ++sp)	{	if (FA[sp]<S)		S=FA[sp];	else if (FA[sp]>F)	F=FA[sp];	}	for (i=S; i<=F; ++i)	{	for (c=0; c<clades; ++c)	{		for (d=1; d<=tree[c][0]; ++d)	{			sp=tree[c][d];			if (FA[sp]==i && BL[sp]>0)	{				EC[br][0]=sp;				if (br==0)	EC[br][1]=BL[sp];				else		EC[br][1]=EC[br-1][1]+BL[sp];				for (ch=0; ch<nchars; ++ch)	{					if (BC[sp][ch]>=0)	{						found=0;						for (a=0; a<chrealized[ch]; ++a)	{							if (BC[sp][ch]==chobserved[ch][a])	{								found=1;								a=chrealized[ch];								}							}						if (found==0)	{							chobserved[ch][chrealized[ch]]=BC[sp][ch];							if (chrealized[ch]==1)	++nch;							++chrealized[ch];							++states;							}						}					}				EC[br][2]=nchars;				EC[br][3]=states;				++br;				}			}		}	}free ((void *)chrealized);free ((void **)chobserved);return EC;}/* IndependentsMatrix: yields an auxillary matrix giving presence/absence of independent character for characters with inapplicables.  /*/* Requires: /*	chmatrix: taxon X character matrix of character states/*	dependents: array giving the character number of dependent states/*	depend: number of dependent states/*	tree: matrix giving tree, with first element giving # of branches and next X giving OTU/HTU # for branch/*	notu: number of taxa/*	nchars: number of characters/*	INAP: code for inapplicable/*	UNKNOWN: code for UNKNOWN/*/* Returns:/*	indmatrix: a matrix of independent correlates of the dependent characters***************************************************************************************/long **IndependentsMatrix(long **chmatrix, int *dependents, int depend, int notu, int nchars, int INAP, int UNKNOWN){int	ch, sp, d=0;long **indmatrix;indmatrix=lmatrix(notu*2,depend);for (ch=0; ch<nchars && d<depend; ++ch)	{	while (ch!=dependents[d] && ch<nchars)	++ch;	if (ch>=nchars)	break;		for (sp=0; sp<notu; ++sp)	{		if (chmatrix[sp][ch]==INAP)			indmatrix[sp][d]=0;		else if (chmatrix[sp][ch]==UNKNOWN)	indmatrix[sp][d]=UNKNOWN;		else								indmatrix[sp][d]=1;		}	++d;	}return indmatrix;}
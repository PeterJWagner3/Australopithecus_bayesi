#define matrixreading#include "matrixreading.h"#include "memory.h"#include <stdlib.h>#include <stdio.h>#include <time.h>#include <math.h>#include <string.h>/* Calculates the number of states for each character given a matrix./*/* Requires:/*	omat: taxon X character matrix of character states/*	notu: number of taxa/*	nchars: number of characters/*	UNKNOWN: code for unknown states/*	GAP: code for inapplicable characters/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *numberstates(long **omat, int notu, int nchars, int UNKNOWN, int GAP){int	a, b, ch, sp, st;int *nstates, *unst;nstates=ivector(nchars);/* find the maximum state number */st=0;for (ch=0; ch<nchars; ++ch)	{	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]>st && (omat[sp][ch]!=GAP && omat[sp][ch]!=UNKNOWN))			st=omat[sp][ch];		}	}unst=ivector(st+1);/* determine how species each state  has */for (ch=0; ch<nchars; ++ch)	{	st=0;	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]!=UNKNOWN && omat[sp][ch]!=GAP)	{			b=0;			for (a=0; a<st; ++a)	{				if (omat[sp][ch]==unst[a])	{					b=1;					a=st;					}				}			if (b==0)	{				unst[st]=omat[sp][ch];				++st;				}			}		}	nstates[ch]=st;	}free_ivector(unst);return nstates;}/* Calculates the number of states for a particular character given a matrix./*/* Requires:/*	states: taxon X character matrix of character states/*	notu: number of taxa/*	UNKNOWN: code for unknown states/*	GAP: code for inapplicable characters/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int no_states(long **omat, int CH, int notu, int UNKNOWN, int GAP){int	a, b, sp, st;int *unst;/* find the maximum state number */st=0;for (sp=0; sp<notu; ++sp)	{	if (omat[sp][CH]>st && (omat[sp][CH]!=GAP && omat[sp][CH]!=UNKNOWN))		st=omat[sp][CH];	}/* determine how species each state  has */unst=ivector(st+1);st=0;for (sp=0; sp<notu; ++sp)	{	if (omat[sp][CH]!=UNKNOWN && omat[sp][CH]!=GAP)	{		b=0;		for (a=0; a<st; ++a)	{			if (omat[sp][CH]==unst[a])	{				b=1;				a=st;				}			}		if (b==0)	{			unst[st]=omat[sp][CH];			++st;			}		}	}free_ivector(unst);return st;}/* Calculates the number of species with derived conditions./*/* Requires:/*	omat: taxon X character matrix of character states/*	notu: number of taxa/*	nchars: number of characters/*	UNKNOWN: code for unknown states/*	GAP: code for inapplicable characters/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *autapomorphies(long **omat, int notu, int nchars, int UNKNOWN, int GAP){int	ch, st, sp, max, stmax, out;int *autap, *tallied;autap=ivector(nchars);max=0;for (ch=0; ch<nchars; ++ch)	{	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]>max && (omat[sp][ch]!=GAP && omat[sp][ch]!=UNKNOWN))			max=omat[sp][ch];		}	}tallied=ivector(max);/* determine how many species each states has */for (ch=0; ch<nchars; ++ch)	{	for (st=0; st<=max; ++st)		tallied[st]=0; 	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]!=UNKNOWN && omat[sp][ch]!=GAP)	{			st=omat[sp][ch];			++tallied[st];			}		}	autap[ch]=stmax=0;	for (st=0; st<=max; ++st)	{		if (tallied[st]>stmax)	{			out=st;			stmax=tallied[st];			}		}	for (st=0; st<=max; ++st)	if (st!=out)	autap[ch]=autap[ch]+tallied[st];	}free_ivector(tallied);return autap;}/* Calculates the number of species with derived conditions for a single character CH./*/* Requires:/*	omat: taxon X character matrix of character states/*	notu: number of taxa/*	CH: character being examined/*	UNKNOWN: code for unknown states/*	GAP: code for inapplicable characters/*	OutCond: State of Outgroup/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int autapo_char(long **omat, int notu, int CH, int UNKNOWN, int GAP, int OutCond){int	st, sp, max, stmax;int *tallied, autap;max=0;for (sp=0; sp<notu; ++sp)	{	if (omat[sp][CH]>max && (omat[sp][CH]!=GAP && omat[sp][CH]!=UNKNOWN))		max=omat[sp][CH];	}tallied=ivector(max);/* determine how many species each states has */for (st=0; st<=max; ++st)	tallied[st]=0; for (sp=0; sp<notu; ++sp)	{	if (omat[sp][CH]!=UNKNOWN && omat[sp][CH]!=GAP)	{		st=omat[sp][CH];		++tallied[st];		}	}autap=stmax=0;for (st=0; st<=max; ++st)	{	if (tallied[st]>stmax)	{//		out=st;		stmax=tallied[st];		}	}for (st=0; st<=max; ++st)	if (st!=OutCond)	autap=autap+tallied[st];free_ivector(tallied);return autap;}/* Calculates the number of species with derived conditions./*/* Requires:/*	omat: taxon X character matrix of character states/*	notu: number of taxa/*	nchars: number of characters/*	UNKNOWN: code for unknown states/*	GAP: code for inapplicable characters/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *unknownstates(long **omat, int notu, int nchars, int UNKNOWN, int GAP){int	ch, sp;int *missing;missing=ivector(nchars);for (ch=0; ch<nchars; ++ch)	{	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]==GAP || omat[sp][ch]==UNKNOWN)			++missing[ch];		}	}return missing;}
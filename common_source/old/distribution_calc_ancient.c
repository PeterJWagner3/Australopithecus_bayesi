#define distribution_calc#include "distribution_calc.h"/*CALCULATES GEOMETRIC DISTRIBUTION. NEEDS:	- abundance (array with sorted absolute abundance)... will be determined within    - M (slope in log-linear space)    - Sr (hypothesized number of taxa)    - So (observed number of taxa)RETURNS:	- abundance: proportional abundances***********************************************************************/double *GEOM(double *abundance, double M, int Sr, int So){int	a;double	t, *A;A=dvector(Sr);t=A[0]=100;for (a=1; a<Sr; ++a)	{	A[a]=A[a-1]/M;	t=t+A[a];	}for (a=0; a<Sr; ++a)	A[a]=A[a]/t;for (a=0; a<So; ++a)	abundance[a]=A[a];free_dvector(A);return abundance;}/*CALCULATES ZIPF-MANDELBROT DISTRIBUTION. NEEDS:	- abundance (array with sorted absolute abundance)... will be determined within    - M (slope in log-log space)    - Sr (hypothesized number of taxa)    - So (observed number of taxa)RETURNS:	- abundance: proportional abundances***********************************************************************/double *ZPFMN(double *abundance, double M, int Sr, int So){int	a;double	t, *A;A=dvector(Sr);t=A[0]=100;/* create a density function */for (a=1; a<Sr; ++a)	{	A[a]=exp(log(A[a-1])/M);	t=t+A[a];	}/* convert to a probability function */for (a=0; a<Sr; ++a)	A[a]=A[a]/t;for (a=0; a<So; ++a)	abundance[a]=A[a];free_dvector(A);return abundance;}/*CALCULATES LOG-NORMAL DISTRIBUTION. NEEDS:	- abundance (array with sorted absolute abundance)... will be determined within    - Mag (Magnitude of increase along each suboctave)    - Med (ÒMedianÓ Octave ([in dx SD's away from average])    - Oct (Number of Octaves)    - Sr (hypothesized number of taxa)    - So (observed number of taxa - for raw distributions make Sr=So)RETURNS:	- abundance: proportional abundances***********************************************************************/double *LGNOR(double *abundance, double Mag, double Med, int Oct, int Sr, int So){int	a, b, c, Rel;double	dx=0.25, Normal, t, v, x, y, z;double	PI=3.141592654, EX=2.718281828;double	A[1000], NormA[200];v=dx;v=1/v;/*A=dvector(Sr);*//* calculate Gaussian density function */Normal=0;x=0-Med;for (a=0; a<v*Oct; ++a)	{	z=a;	x=(0-Med)+ (z*dx);				/*each octave is 1/4 an SD */	y = pow(EX,-(x*x)/2);	y = y/(pow(2*PI,0.5));	NormA[a]=y;	Normal=Normal+y;	}/* convert density function to normal probability curve */for (a=0; a<v*Oct; ++a)	NormA[a]=NormA[a]/Normal;/* determine number of species in the octave */x=c=0;for (a=0; a<v*Oct; ++a)	{	b=NormA[a]=(Sr*NormA[a]);	if (NormA[a]-b >= 0.5)		NormA[a]=b+1;	else						NormA[a]=b;	c=c+NormA[a];	Rel=a;						/* relevant octaves */		/* case final octave has nothing */	if (NormA[a]==0 && (c>0 && c<Sr))	{		NormA[a]=Sr-c;		c=c+(Sr-c);		}		if (c==Sr)	{		for (a=a+1; a<v*Oct; ++a)	NormA[a]=0;		}	}/* Now create relative abundance density function */t=0;c=Sr-1;for (a=0; a<=Rel; ++a)	{	y=a;	x=0;	for (b=0; b<NormA[a]; ++b)	{		x=x+(1/NormA[a]);		z=pow(Mag,y+x);		t=t+z;				/* this abundances always greater than previous - 9/19/01 */		A[c]=z;		--c;		if (c<0)	{			break;			}		}	}/* convert to a probability function */for (a=0; a<Sr; ++a)	A[a]=A[a]/t;for (a=0; a<So; ++a)	abundance[a]=A[a];/*free_dvector(A);*/return abundance;}/*CALCULATES LOG-NORMAL DISTRIBUTION. NEEDS:	- abundance (array with sorted absolute abundance)... will be determined within    - C (coefficient on power function; a in a*x^b)    - X (exponent on power function; b in a*x^b)    - Sr (hypothesized number of taxa)    - So (observed number of taxa - for raw distributions make Sr=So)RETURNS:	- abundance: proportional abundances*/double *LGPOW (double *abundance, double C, double X, int Sr, int So){int	a;double	t, x, y;double	*A;A=dvector(Sr);/* Calculate possible distribution */for (a=0; a<Sr; ++a)	{	x=a+1;	y=-1*C*pow(x,X);	A[a]=pow(10,y);	t=t+A[a];	/* t is area under the curve */	}/* standardize distribution so that the area under the curve = 1.0 */for (a=0; a<Sr; ++a)	A[a]=A[a]/t;for (a=0; a<So; ++a)	abundance[a]=A[a];free_dvector(A);return abundance;}
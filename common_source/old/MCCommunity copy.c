/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//*/*	Peter J. Wagner: pwagner@fmnh.org/*	Matthew Kosnik: mkosnik@uchicago.edu/*/*	This file is copyright (C) 2001 Peter J. Wagner & Matthew Kosnik/*/*	This program is free software; you can redistribute it and/or modify it /*	under the terms of version 2 the GNU General Public License as published /*	by the Free Software Foundation./*/*	This program is distributed in the hope that it will be useful, but WITHOUT/*	ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or /*	FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for /*	more details./*/*	To view a copy of the license go to:/*	http://www.fsf.org/copyleft/gpl.html/*	To receive a copy of the GNU General Public License write the Free Software/* 	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA./*/*	Copies of this source code are available without cost from:/*	http://geosci.uchicago.edu/paleo/csource//*	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */#define MCCommunity#include "MCCommunity.h"#include "distribution_calc.h"/* Takes a slope and a true richness, then generates and returnsa geometric-series abundance distribution *//* E: slope in log-log space - from best fit distribution/* S: optimal richness - from best fit distribution/* Ttl: number of specimens per list.***********************************************************************/int *SimGS(double E, int S, int Ttl){int		a, b, c;int		*CumA, *abundance;double	*A;CumA=ivector(S);abundance=ivector(S);/*create geometric density function */A=proportional_gs_distribution(E,S);A=ideal_distribution(A,S);/* create a cumulative distribution for sampling */CumA[0]=RAND_MAX*A[0];for (a=1; a<S; ++a)	{	CumA[a]=CumA[a-1]+(RAND_MAX*A[a]);	}for (a=0; a<S; ++a)	abundance[a]=0;for (a=0; a<Ttl; ++a)	{	b = (int)((double)rand()/ ((double)RAND_MAX+1) * CumA[S-1]);	for (c=0 ; c<S ; c++) {		if (b<CumA[c]) {			++abundance[c];			c=S;			}		else if (c==S-1) {			++abundance[c];			printf("\nproblem in SimGS (s=%d, c=%d, b=%d)\t",S,c,b);			}		}	}c=0;for (a=0; a<S; ++a)	if (abundance[a]==0)	++c;for (a=0; a<(S-c); ++a)	{	if (abundance[a]==0)	{		for (b=a; b<(S-1); ++b)			abundance[b]=abundance[b+1];		abundance[S-1]=0;		--a;		}	}free_dvector(A);free_ivector(CumA);return abundance;}/* Takes a slope and a true richness, then generates and returnsa Zipf-Mandelbrot abundance distribution *//* E: slope in log-log space - from best fit distribution/* S: optimal richness - from best fit distribution/* Ttl: number of specimens per list./* Oc: number of occurrences per list.***********************************************************************/int *SimZM(double E, int S, int Ttl){int		a, b, c;int		*CumA, *abundance;double	T;double	*A;CumA=ivector(S);abundance=ivector(S);T=100;/*create Zipf-Mandelbrot density function */	A=proportional_zm_distribution(E,S);A=ideal_distribution(A,S);/* create a cumulative distribution for sampling */CumA[0]=RAND_MAX*A[0];for (a=1; a<S; ++a)	{	CumA[a]=CumA[a-1]+(RAND_MAX*A[a]);	}for (a=0; a<S; ++a)	abundance[a]=0;for (a=0; a<Ttl; ++a)	{	b = (int)((double)rand() / ((double)RAND_MAX+1) * CumA[S-1]);	for (c=0 ; c<S ; c++) {		if (b<CumA[c]) {			++abundance[c];			c=S;			}		else if (c==S-1) {			++abundance[c];			printf("\nproblem in SimZM (s=%d, c=%d, b=%d)\t",S,c,b);			}		}	}c=0;for (a=0; a<S; ++a)	if (abundance[a]==0)	++c;for (a=0; a<(S-c); ++a)	{	if (abundance[a]==0)	{		for (b=a; b<(S-1); ++b)			abundance[b]=abundance[b+1];		abundance[S-1]=0;		--a;		}	}free_dvector(A);free_ivector(CumA);return abundance;}/* Takes a slope and a true richness, then generates and returns a Log-Normal abundance distribution *//* InitM: Slope at outset/* ModM: Octave with median species number/* Ttl: number of specimens per list./* Oc: number of occurrences per list.***********************************************************************/int *SimfLN(double m, double ModM, int S, int Ttl, double mode){int		a, b, c;int		*CumA, *abundance;double	*A;A=dvector(S);CumA=ivector(S);abundance=ivector(S);/*create Log-Normal density function */	/*A=proportional_fln_distribution(ModM,InitM,S,mode);*/A=ideal_distribution(A,S);/* create a cumulative distribution for sampling */CumA[0]=RAND_MAX*A[0];for (a=1; a<S; ++a)	{	CumA[a]=CumA[a-1]+(RAND_MAX*A[a]);	}for (a=0; a<S; ++a)	abundance[a]=0;for (a=0; a<Ttl; ++a)	{	b = (int)((double)rand() / ((double)RAND_MAX+1) * CumA[S-1]);	for (c=0 ; c<S ; c++) {		if (b<CumA[c]) {			++abundance[c];			c=S;			}		else if (c==S-1) {			++abundance[c];			printf("\nproblem in SimLN (s=%d, c=%d, b=%d)\t",S,c,b);			}		}	}c=0;for (a=0; a<S; ++a)	if (abundance[a]==0)	++c;for (a=0; a<(S-c); ++a)	{	if (abundance[a]==0)	{		for (b=a; b<(S-1); ++b)			abundance[b]=abundance[b+1];		abundance[S-1]=0;		--a;		}	}free_dvector(A);free_ivector(CumA);return abundance;}/* Takes a slope and a true richness, then generates and returnsa Log-Normal abundance distribution *//* Mag: Magnitude of increase along each Octave/* Med: Octave with median species number/* Ttl: number of specimens per list./* Oc: number of occurrences per list.***********************************************************************/int *SimLN(double InitM, double ModM, int S, int Ttl){int		a, b, c;int		*CumA, *abundance;double	T;double	*A;A=dvector(S);CumA=ivector(S);abundance=ivector(S);T=A[0]=100;/*create Log-Normal density function */	//A=proportional_fln_distribution(ModM,InitM,S);A=ideal_distribution(A,S);/* create a cumulative distribution for sampling */CumA[0]=RAND_MAX*A[0];for (a=1; a<S; ++a)	{	CumA[a]=CumA[a-1]+(RAND_MAX*A[a]);	}for (a=0; a<S; ++a)	abundance[a]=0;for (a=0; a<Ttl; ++a)	{	b = (int)((double)rand() / ((double)RAND_MAX+1) * CumA[S-1]);	for (c=0 ; c<S ; c++) {		if (b<CumA[c]) {			++abundance[c];			c=S;			}		else if (c==S-1) {			++abundance[c];			printf("\nproblem in SimLN (s=%d, c=%d, b=%d)\t",S,c,b);			}		}	}c=0;for (a=0; a<S; ++a)	if (abundance[a]==0)	++c;for (a=0; a<(S-c); ++a)	{	if (abundance[a]==0)	{		for (b=a; b<(S-1); ++b)			abundance[b]=abundance[b+1];		abundance[S-1]=0;		--a;		}	}free_dvector(A);free_ivector(CumA);return abundance;}/* Generates and returns a Log-Power abundance distribution *//* C: Coefficient of Power Function/* X: Exponent of Power Function/* S: number of taxa per list./* Ttl: number of finds per list.***********************************************************************/int *SimLP(double C, double X, int S, int Ttl){int		a, b, c;int		*CumA, *abundance;double	*A;CumA=ivector(S);abundance=ivector(S);/*create Log-Normal density function */	A=proportional_lp_distribution(C,X,S);A=ideal_distribution(A,S);/* create a cumulative distribution for sampling */CumA[0]=RAND_MAX*A[0];for (a=1; a<S; ++a)	{	CumA[a]=CumA[a-1]+(RAND_MAX*A[a]);	}for (a=0; a<S; ++a)	abundance[a]=0;for (a=0; a<Ttl; ++a)	{	b = (int)((double)rand() / ((double)RAND_MAX+1) * CumA[S-1]);	for (c=0 ; c<S ; c++) {		if (b<CumA[c]) {			++abundance[c];			c=S;			}		else if (c==S-1) {			++abundance[c];			printf("\nproblem in SimLP (s=%d, c=%d, b=%d)\t",S,c,b);			}		}	}c=0;for (a=0; a<S; ++a)	if (abundance[a]==0)	++c;for (a=0; a<(S-c); ++a)	{	if (abundance[a]==0)	{		for (b=a; b<(S-1); ++b)			abundance[b]=abundance[b+1];		abundance[S-1]=0;		--a;		}	}free_dvector(A);free_ivector(CumA);return abundance;}
			if (b==0)	{						if (tree[node][1]<tree[node][2])	{					sp1 = tree[node][1];					sp2 = tree[node][2];					}				else	{					sp2 = tree[node][1];					sp1 = tree[node][2];					tree[node][1]=sp1;					tree[node][2]=sp2;					}					e = chmatrix[sp1][ch];				f = chmatrix[sp2][ch];				/* if the states are the same, then set the ancestor to equal descendants */				/* if both species are unknown, then the node is legitimately unknown	  */				if (e==f && e!=undec)				chmatrix[anc][ch] = e;								/* species do not match - ancestor is undecided */				else if (sp1<=notu && sp2<=notu)	chmatrix[anc][ch]=undec;				/* if two unknown / inapplicable species then ancestor should be unknown or inapplicable */				else if ((e==f && (e<mnst || e>mxst)) && (sp1<=notu && sp2<=notu))	{					if (nstate[ch]==1)				chmatrix[anc][ch] = statetypes[ch][1];					else							chmatrix[anc][ch]=UNKNOWN;	/* 2 unknown species */					}								/* if one is legitimately unknown but the other is not, then make ancestor equivalent to known species */				else if (f==UNKNOWN && (e>=mnst && e<=mxst))				chmatrix[anc][ch]=e;					/* known with unknown */				else if (e==UNKNOWN && (f>=mnst && f<=mxst))				chmatrix[anc][ch]=f;					/* ditto			*/								/* if one is a species and unknown, then the node equals the known species */				/*  Or, if sister clade is full of unknowns, clade is kept as unknown */				else if (e==undec && sp1<=notu)		chmatrix[anc][ch]=f;				else if (f==undec && sp2<=notu)		chmatrix[anc][ch]=e;								/* ROUTINES FOR AMBIGUOUS CLADES WITHIN NODES */				/* Routine for Binary Character an ambiguous clade with known sister taxon & a binary character - assign sister taxon's state */				else if ((e>=mnst && e<=mxst) && ((f==undec && sp2>notu) && nstate[ch]==2))	{									invmatrix[ch][sp2]=chmatrix[anc][ch]=chmatrix[sp2][ch]=e;									}								else if ((f>=mnst && f<=mxst) && ((e==undec && sp1>notu) && nstate[ch]==2))	{									invmatrix[ch][sp1]=chmatrix[anc][ch]=chmatrix[sp1][ch]=f;									}				/** Routine for Unordered Multistate Characters **/				else if (ctype[ch]==1)	{					if ((f<mnst || f>mxst))	{						if (sp2>notu)	{							sp3=tree[sp2-notu][1];							sp4=tree[sp2-notu][2];							if (chmatrix[sp1][ch]==chmatrix[sp3][ch] || chmatrix[sp1][ch]==chmatrix[sp4][ch])										invmatrix[ch][sp2]=chmatrix[anc][ch] = chmatrix[sp2][ch] = chmatrix[sp1][ch];							else	chmatrix[anc][ch] = undec;							}						else		chmatrix[anc][ch] = undec;						}					else if ((e<mnst || e>mxst))	{						if (sp1>notu)	{							sp3=tree[sp1-notu][1];							sp4=tree[sp1-notu][2];							if (chmatrix[sp2][ch]==chmatrix[sp3][ch] || chmatrix[sp2][ch]==chmatrix[sp4][ch])									invmatrix[ch][sp1]=chmatrix[anc][ch] = chmatrix[sp1][ch] = chmatrix[sp2][ch];							else	chmatrix[anc][ch] = undec;							}						else		chmatrix[anc][ch] = undec;						}					else			chmatrix[anc][ch] = undec;					}				/** Routine for Ordered Multistates Characters **/		//		else							chmatrix[anc][ch] = (e+f)/2;				else if (nstate[ch]>2 && ctype[ch]==0)	{					if ((f<mnst || f>mxst) && (e>=mnst && e<=mxst))	{						if (sp2>notu)	{							sp3=tree[sp2-notu][1];							sp4=tree[sp2-notu][2];							x = chmatrix[sp3][ch];							y = chmatrix[sp4][ch];							chmatrix[anc][ch]=undec;							if (x>=0 && y>=0)	{								/* routine if continuous character is greater than outgroup state */								if (e<x && e<y)	{		/* outgroup is less than either */									if (x<y)	chmatrix[sp2][ch]=x;									else		chmatrix[sp2][ch]=y;									}								else if (e>x && e>y)	{	/* outgroup is greater than either */									if (x>y)	chmatrix[sp2][ch]=x;									else		chmatrix[sp2][ch]=y;									}								else	{									if (abs(e-x)<abs(e-y))		chmatrix[sp2][ch]=x;									else if (abs(e-x)>abs(e-y))	chmatrix[sp2][ch]=y;									else						chmatrix[sp2][ch]=e;									}								}							else if (x<0)						chmatrix[sp2][ch]=y;							else if (y<0)						chmatrix[sp2][ch]=x;							}						else					chmatrix[anc][ch] = chmatrix[sp1][ch];						}					else if ((e<mnst || e>mxst) && (f>=mnst && f<=mxst))	{						if (sp1>notu)	{							sp3=tree[sp1-notu][1];							sp4=tree[sp1-notu][2];							x = chmatrix[sp3][ch];							y = chmatrix[sp4][ch];							chmatrix[anc][ch]=undec;							if (x>=0 && y>=0)	{								/* routine if continuous character is greater than outgroup state */								if (f<x && f<y)	{		/* outgroup is less than either */									if (x<y)	chmatrix[sp1][ch]=x;									else		chmatrix[sp1][ch]=y;									}								else if (f>x && f>y)	{	/* outgroup is greater than either */									if (x>y)	chmatrix[sp1][ch]=x;									else		chmatrix[sp1][ch]=y;									}								else	{									if (abs(f-x)<abs(f-y))		chmatrix[sp1][ch]=x;									else if (abs(f-x)>abs(f-y))	chmatrix[sp1][ch]=y;									else						chmatrix[sp1][ch]=f;									}								}							}						}					/* routine if both taxa are ambiguous */					else if ((e<mnst || e>mxst) && (f<mnst || f>mxst))	{						if (sp1<=notu && sp2<=notu)				chmatrix[anc][ch] = undec;						else	{					/* two ambiguous sister clades!*/							chmatrix[anc][ch]=undec;							sp3=tree[sp1-notu][1];							sp4=tree[sp1-notu][2];							sp5=tree[sp2-notu][1];							sp6=tree[sp2-notu][2];														w = chmatrix[sp3][ch];							z = chmatrix[sp4][ch];							x = chmatrix[sp5][ch];							y = chmatrix[sp6][ch];														if ((w==x || w==y) && w>=0)								chmatrix[sp1][ch]=chmatrix[sp2][ch]=w;														else if ((z==x || z==y) && z>=0)								chmatrix[sp1][ch]=chmatrix[sp2][ch]=z;															else	{								if ((w<x && w<y) && (z<x && z<y))	{									if (w>z)		chmatrix[sp1][ch]=w;									else			chmatrix[sp1][ch]=z;									if (x<y)		chmatrix[sp2][ch]=x;									else			chmatrix[sp2][ch]=y;									}								else if ((w>x && w>y) && (z>x && z>y))	{									if (w<z)		chmatrix[sp1][ch]=w;									else			chmatrix[sp1][ch]=z;									if (x<y)		chmatrix[sp2][ch]=x;									else			chmatrix[sp2][ch]=y;									}								else	{									if (abs(chmatrix[sp3][ch]-chmatrix[sp5][ch])<abs(chmatrix[sp3][ch]-chmatrix[sp6][ch]))										x = w = abs(chmatrix[sp3][ch]-chmatrix[sp5][ch]);									else										y = w = abs(chmatrix[sp3][ch]-chmatrix[sp6][ch]);									if (abs(chmatrix[sp4][ch]-chmatrix[sp5][ch])<abs(chmatrix[sp4][ch]-chmatrix[sp6][ch]))										x = z = abs(chmatrix[sp4][ch]-chmatrix[sp5][ch]);									else										y = z = abs(chmatrix[sp4][ch]-chmatrix[sp6][ch]);									if (w<z)	chmatrix[sp1][ch]=abs(chmatrix[sp3][ch]);									else		chmatrix[sp1][ch]=abs(chmatrix[sp4][ch]);									if (x<y)	chmatrix[sp2][ch]=abs(chmatrix[sp5][ch]);									else		chmatrix[sp2][ch]=abs(chmatrix[sp6][ch]);									}								}							}						}							}		/* end routine for ordered multistates */				/* irreversibles */				else if (ctype[ch]==2)	{					if ((e>=mnst && e<=mxst) && (f>=mnst && f<=mxst))	{						if (e==chmatrix[OUTGROUP][ch])							chmatrix[anc][ch]=e;						else if (f==chmatrix[OUTGROUP][ch])							chmatrix[anc][ch]=f;						else							chmatrix[anc][ch]=UNKNOWN;		//				if (abs(chmatrix[sp1][ch]-chmatrix[OUTGROUP][ch])<abs(chmatrix[sp2][ch]-chmatrix[OUTGROUP][ch]))		//						chmatrix[anc][ch]=chmatrix[sp1][ch];		//				else	chmatrix[anc][ch]=chmatrix[sp2][ch];						}					else if (chmatrix[sp1][ch]>=0 && chmatrix[sp2][ch]<0)								chmatrix[anc][ch]=chmatrix[sp1][ch];					else if (chmatrix[sp1][ch]<0 && chmatrix[sp2][ch]>=0)								chmatrix[anc][ch]=chmatrix[sp2][ch];					else		chmatrix[anc][ch]=undec;					}								invmatrix[ch][anc]=chmatrix[anc][ch];								}	/* end comparison of nodes with conflicting information */
#define Optimization#include "Optimization.h"#define memory#include "memory.h"int** Parsimony(int **chmatrix, long **tree, int** statetypes, int* nstate, int* ctype, int clades, int SOTU, int chars, int OUTGROUP, int GAP, int UNKNOWN){int		a, b, anc, ch, sp1, sp2, sp3, sp4, sp5, sp6, node, maxtaxa;float	e, f, x, y, w, z;maxtaxa = 2*SOTU;for (node=0; node<clades; ++node)	for (ch=0; ch<chars; ++ch)	chmatrix[node+SOTU][ch]=0;/*** Find Shared States between Sister Taxa ***/for (node=clades-1; node>=0; --node)	{	anc = SOTU+node;	if (tree[node][1]<tree[node][2])	{		sp1 = tree[node][1];		sp2 = tree[node][2];		}			else	{		sp2 = tree[node][1];		sp1 = tree[node][2];		tree[node][1]=sp1;		tree[node][2]=sp2;		}		for (ch=0; ch<chars; ++ch)	{		e = chmatrix[sp1][ch];		f = chmatrix[sp2][ch];		if (e==f && e!=-1)					chmatrix[anc][ch] = e;		else if ((e==f && e<0) && (sp1<=SOTU && sp2<=SOTU))	{			if (nstate[ch]==1)				chmatrix[anc][ch] = statetypes[ch][0];			else							chmatrix[anc][ch]=-2;	/* 2 unknown species */			}		else if (e==f && e==-2)	{			if (nstate[ch]==1)				chmatrix[anc][ch] = statetypes[ch][0];			else							chmatrix[anc][ch]=-2;					/* clade of unknown species */			}		else if (f==-2 && e>=0)				chmatrix[anc][ch]=e;					/* known with unknown */		else if (e==-2 && f>=0)				chmatrix[anc][ch]=f;					/* ditto			*/		/*		else if (e==-1 && f==-2)			chmatrix[anc][ch]=-1;		else if (e==-2 && f==-1)			chmatrix[anc][ch]=-1;	*/				/* if one is a species and unknown, then the node equals the known species */		/*  Or, if sister clade is full of unknowns, clade is kept as unknown */		else if (e==-1 && sp1<=SOTU)		chmatrix[anc][ch]=f;		else if (f==-1 && sp2<=SOTU)		chmatrix[anc][ch]=e;		else if (sp1<=SOTU && sp2<=SOTU)	chmatrix[anc][ch]=-1;				/* an ambiguous clade with known sister taxon & a binary character - assign sister taxon's state */		else if (e>=0 && ((f==-1 && sp2>SOTU) && nstate[ch]==2))											chmatrix[anc][ch]=chmatrix[sp2][ch]=e;				else if (f>=0 && ((e==-1 && sp1>SOTU) && nstate[ch]==2))											chmatrix[anc][ch]=chmatrix[sp1][ch]=f;		/** Routine for Binary and Unordered Multistate Characters **/		else if ((nstate[ch]<=2 && ctype[ch]!=2) || ctype[ch]==1)	{			if (f<0)	{				if (sp2>SOTU)	{					sp3=tree[sp2-SOTU][1];					sp4=tree[sp2-SOTU][2];					if (chmatrix[sp1][ch]==chmatrix[sp3][ch] || chmatrix[sp1][ch]==chmatrix[sp4][ch])											chmatrix[anc][ch] = chmatrix[sp2][ch] = chmatrix[sp1][ch];					else				chmatrix[anc][ch] = -1;					}				else					chmatrix[anc][ch] = -1;				}			else if (e<0)	{				if (sp1>SOTU)	{					sp3=tree[sp1-SOTU][1];					sp4=tree[sp1-SOTU][2];					if (chmatrix[sp2][ch]==chmatrix[sp3][ch] || chmatrix[sp2][ch]==chmatrix[sp4][ch])										chmatrix[anc][ch] = chmatrix[sp1][ch] = chmatrix[sp2][ch];					else				chmatrix[anc][ch] = -1;					}				else					chmatrix[anc][ch] = -1;				}			else						chmatrix[anc][ch] = -1;			}		/** Routine for Ordered Multistates Characters **///		else							chmatrix[anc][ch] = (e+f)/2;		else if (nstate[ch]>2 && ctype[ch]==0)	{			if (f<0 && e>=0)	{				if (sp2>SOTU)	{					sp3=tree[sp2-SOTU][1];					sp4=tree[sp2-SOTU][2];					x = chmatrix[sp3][ch];					y = chmatrix[sp4][ch];					chmatrix[anc][ch]=-1;					if (x>=0 && y>=0)	{						/* routine if continuous character is greater than outgroup state */						if (e<x && e<y)	{		/* outgroup is less than either */							if (x<y)	chmatrix[sp2][ch]=x;							else		chmatrix[sp2][ch]=y;							}						else if (e>x && e>y)	{	/* outgroup is greater than either */							if (x>y)	chmatrix[sp2][ch]=x;							else		chmatrix[sp2][ch]=y;							}						else	{							if (abs(e-x)<abs(e-y))		chmatrix[sp2][ch]=x;							else if (abs(e-x)>abs(e-y))	chmatrix[sp2][ch]=y;							else						chmatrix[sp2][ch]=e;							}						}					else if (x<0)						chmatrix[sp2][ch]=y;					else if (y<0)						chmatrix[sp2][ch]=x;					}				else					chmatrix[anc][ch] = chmatrix[sp1][ch];				}			else if (e<0 && f>=0)	{				if (sp1>SOTU)	{					sp3=tree[sp1-SOTU][1];					sp4=tree[sp1-SOTU][2];					x = chmatrix[sp3][ch];					y = chmatrix[sp4][ch];					chmatrix[anc][ch]=-1;					if (x>=0 && y>=0)	{						/* routine if continuous character is greater than outgroup state */						if (f<x && f<y)	{		/* outgroup is less than either */							if (x<y)	chmatrix[sp1][ch]=x;							else		chmatrix[sp1][ch]=y;							}						else if (f>x && f>y)	{	/* outgroup is greater than either */							if (x>y)	chmatrix[sp1][ch]=x;							else		chmatrix[sp1][ch]=y;							}						else	{							if (abs(f-x)<abs(f-y))		chmatrix[sp1][ch]=x;							else if (abs(f-x)>abs(f-y))	chmatrix[sp1][ch]=y;							else						chmatrix[sp1][ch]=f;							}						}					}				}			/* routine if both taxa are ambiguous */			else if (e<0 && f<0)	{				if (sp1<=SOTU && sp2<=SOTU)				chmatrix[anc][ch] = -1;				else	{					/* two ambiguous sister clades!*/					chmatrix[anc][ch]=-1;					sp3=tree[sp1-SOTU][1];					sp4=tree[sp1-SOTU][2];					sp5=tree[sp2-SOTU][1];					sp6=tree[sp2-SOTU][2];										w = chmatrix[sp3][ch];					z = chmatrix[sp4][ch];					x = chmatrix[sp5][ch];					y = chmatrix[sp6][ch];										if ((w==x || w==y) && w>=0)						chmatrix[sp1][ch]=chmatrix[sp2][ch]=w;										else if ((z==x || z==y) && z>=0)						chmatrix[sp1][ch]=chmatrix[sp2][ch]=z;											else	{						if ((w<x && w<y) && (z<x && z<y))	{							if (w>z)		chmatrix[sp1][ch]=w;							else			chmatrix[sp1][ch]=z;							if (x<y)		chmatrix[sp2][ch]=x;							else			chmatrix[sp2][ch]=y;							}						else if ((w>x && w>y) && (z>x && z>y))	{							if (w<z)		chmatrix[sp1][ch]=w;							else			chmatrix[sp1][ch]=z;							if (x<y)		chmatrix[sp2][ch]=x;							else			chmatrix[sp2][ch]=y;							}						else	{							if (abs(chmatrix[sp3][ch]-chmatrix[sp5][ch])<abs(chmatrix[sp3][ch]-chmatrix[sp6][ch]))								x = w = abs(chmatrix[sp3][ch]-chmatrix[sp5][ch]);							else								y = w = abs(chmatrix[sp3][ch]-chmatrix[sp6][ch]);							if (abs(chmatrix[sp4][ch]-chmatrix[sp5][ch])<abs(chmatrix[sp4][ch]-chmatrix[sp6][ch]))								x = z = abs(chmatrix[sp4][ch]-chmatrix[sp5][ch]);							else								y = z = abs(chmatrix[sp4][ch]-chmatrix[sp6][ch]);							if (w<z)	chmatrix[sp1][ch]=abs(chmatrix[sp3][ch]);							else		chmatrix[sp1][ch]=abs(chmatrix[sp4][ch]);							if (x<y)	chmatrix[sp2][ch]=abs(chmatrix[sp5][ch]);							else		chmatrix[sp2][ch]=abs(chmatrix[sp6][ch]);							}						}					}				}					}		/* end routine for ordered multistates */		/* irreversibles */		else if (ctype[ch]==2)	{			if (e>=0 && f>=0)	{				if (e==chmatrix[OUTGROUP][ch])					chmatrix[anc][ch]=e;				else if (f==chmatrix[OUTGROUP][ch])					chmatrix[anc][ch]=f;				else					chmatrix[anc][ch]=-2;//				if (abs(chmatrix[sp1][ch]-chmatrix[OUTGROUP][ch])<abs(chmatrix[sp2][ch]-chmatrix[OUTGROUP][ch]))//						chmatrix[anc][ch]=chmatrix[sp1][ch];//				else	chmatrix[anc][ch]=chmatrix[sp2][ch];				}			else if (chmatrix[sp1][ch]>=0 && chmatrix[sp2][ch]<0)						chmatrix[anc][ch]=chmatrix[sp1][ch];			else if (chmatrix[sp1][ch]<0 && chmatrix[sp2][ch]>=0)						chmatrix[anc][ch]=chmatrix[sp2][ch];			else		chmatrix[anc][ch]=-1;			}		}		/* End Search of Node */	}		/* End First pass *//*** Use Outgroup to Polarize Indeterminate Characters at Base of Tree ***/for (ch=0; ch<chars; ++ch)	{	e = chmatrix[SOTU][ch];	if (chmatrix[SOTU][ch] == -1)	{		if (nstate[ch]==1)	chmatrix[SOTU][ch] = statetypes[ch][0];		else if (nstate[ch]==2 || ctype[ch]==1)	{			if (chmatrix[OUTGROUP][ch]!=UNKNOWN)				chmatrix[SOTU][ch] = chmatrix[OUTGROUP][ch];			else	{				for (a=0; a<clades; ++a)	{					for (b=1; b<=tree[a][0]; ++b)	{						sp1=tree[a][b];						if (chmatrix[sp1][ch]>=0)	{							chmatrix[SOTU][ch]=chmatrix[sp1][ch];							b=tree[a][0];							a=clades;							}						}					}				}			}		else if (nstate[ch]>=2 && ctype[ch]==0)	{			sp1 = tree[0][1];			sp2 = tree[0][2];						if (chmatrix[sp1][ch]<0 && sp1<=SOTU)			chmatrix[SOTU][ch] = chmatrix[sp2][ch];			if (chmatrix[sp2][ch]<0 && sp2<=SOTU)			chmatrix[SOTU][ch] = chmatrix[sp1][ch];			if (chmatrix[sp2][ch]<0 && chmatrix[sp1][ch]<0)															chmatrix[SOTU][ch] = chmatrix[OUTGROUP][ch];			else	{				if (abs(chmatrix[sp1][ch]-chmatrix[OUTGROUP][ch]) < abs(chmatrix[sp2][ch]-chmatrix[OUTGROUP][ch]))					chmatrix[SOTU][ch] = chmatrix[sp1][ch];				else if (abs(chmatrix[sp1][ch]-chmatrix[OUTGROUP][ch]) > abs(chmatrix[sp2][ch]-chmatrix[OUTGROUP][ch]))					chmatrix[SOTU][ch] = chmatrix[sp2][ch];				else					chmatrix[SOTU][ch] = (chmatrix[sp1][ch]+chmatrix[sp2][ch])/2;				}			}		}	}/*** Use Successive Outgroups to Polarize Indeterminate Characters ***/for (node=0; node<clades; ++node)	{	anc = SOTU+node;	sp1 = tree[node][1];	sp2 = tree[node][2];	while ((sp1<SOTU && sp2<SOTU) && node<clades)	{		++node;		sp1 = tree[node][1];		sp2 = tree[node][2];		}	if (node>=clades)	break;	if (sp1>=SOTU && sp2<SOTU)	{		sp1 = tree[node][2];		sp2 = tree[node][1];		}	for (ch=0; ch<chars; ++ch)	{		x = chmatrix[anc][ch];		e = chmatrix[sp1][ch];		f = chmatrix[sp2][ch];		if (sp1>=SOTU && sp2>=SOTU)	{			if (chmatrix[sp1][ch]<0)	chmatrix[sp1][ch]=chmatrix[anc][ch];			if (chmatrix[sp2][ch]<0)	chmatrix[sp2][ch]=chmatrix[anc][ch];			}		else if (sp1<SOTU && sp2>=SOTU)	{			if (chmatrix[sp1][ch]<0)			sp3=tree[sp2-SOTU][1];			sp4=tree[sp2-SOTU][2];						if (sp3>maxtaxa || sp4>maxtaxa)	{				printf("Descendant doesn't exist in clade %d!\n",sp2-SOTU);				exit(0);				}						w = chmatrix[sp3][ch];			z = chmatrix[sp3][ch];			if (chmatrix[sp3][ch]<0 && sp3<= SOTU)	{				if (sp4>=SOTU && chmatrix[sp4][ch]>=0)	chmatrix[sp2][ch]=chmatrix[sp4][ch];				else									chmatrix[sp2][ch]=chmatrix[anc][ch];				}			else if (chmatrix[sp4][ch]<0 && sp4<= SOTU)	{				if (sp3>=SOTU && chmatrix[sp4][ch]>=0)	chmatrix[sp2][ch]=chmatrix[sp3][ch];				else									chmatrix[sp2][ch]=chmatrix[anc][ch];				}			if (chmatrix[sp2][ch]<0)	{				/* Routine for Ordered Multistates - use state closest to ancestral form */				if (nstate[ch]>2 && ctype[ch]==0)	{					if (chmatrix[sp3][ch]>=0 && chmatrix[sp4][ch]>=0)	{						if (abs(chmatrix[sp3][ch]-chmatrix[anc][ch])<abs(chmatrix[sp4][ch]-chmatrix[anc][ch]))							chmatrix[sp2][ch]=chmatrix[sp3][ch];						else if (abs(chmatrix[sp3][ch]-chmatrix[anc][ch])>abs(chmatrix[sp4][ch]-chmatrix[anc][ch]))							chmatrix[sp2][ch]=chmatrix[sp4][ch];													else							chmatrix[sp2][ch]=(chmatrix[sp3][ch]+chmatrix[sp4][ch])/2;						}					else if (chmatrix[sp3][ch]<0)	{						a = chmatrix[sp4][ch] - chmatrix[anc][ch];						a = a/2;						chmatrix[sp3][ch]=chmatrix[sp3][ch]+a;						}					else if (chmatrix[sp4][ch]<0)	{						a = chmatrix[sp3][ch] - chmatrix[anc][ch];						a = a/2;						chmatrix[sp4][ch]=chmatrix[sp4][ch]+a;						}					}				/* Routine for irreversible characters */				else if (ctype[ch]==2)	{					if (w>=0 && z>=0)	{						if (abs(w-chmatrix[anc][ch])<(z-chmatrix[anc][ch]))	chmatrix[sp2][ch]=w;						else												chmatrix[sp2][ch]=z;						}					else if (w<0 && z<0)					chmatrix[sp2][ch]=chmatrix[anc][ch];					else if (w<0)							chmatrix[sp2][ch]=chmatrix[anc][ch];					else if (z<0)							chmatrix[sp2][ch]=chmatrix[anc][ch];					}				/* Routine for Unordered Multistates & Binaries (No Brainer here) */				else	chmatrix[sp2][ch] = chmatrix[anc][ch];				}			}		e = chmatrix[sp1][ch];		f = chmatrix[sp2][ch];		}	}return chmatrix;}int** BranchChanges(int **chmatrix, long **tree, int chars, int clades, int SOTU, int GAP, int UNKNOWN){int	c, d, sp, anc, ch;int	**BC;BC=imatrix(2*SOTU,chars);for (sp=0; sp<clades+SOTU; ++sp)	for (ch=0; ch<chars; ++ch)	BC[sp][ch]=-5;for (c=0; c<clades; ++c)	{	anc=c+SOTU;	for (d=1; d<=tree[c][0]; ++d)	{		sp=tree[c][d];		for (ch=0; ch<chars; ++ch)	{			if (chmatrix[anc][ch]!=chmatrix[sp][ch])	{				if ((chmatrix[anc][ch]!=GAP && chmatrix[anc][ch]!=UNKNOWN) && (chmatrix[sp][ch]!=GAP && chmatrix[sp][ch]!=UNKNOWN))	{					BC[sp][ch]=chmatrix[sp][ch];					}				}			}		}	}return BC;}	int* BranchLengths(int **chmatrix, long **tree, int* ctype, int chars, int clades, int SOTU, int GAP, int UNKNOWN){int	c, d, sp, anc, ch, steps;int	*BL, *CS;BL = (int *)malloc((clades+SOTU)*sizeof(int));CS = (int *)malloc(chars*sizeof(int));for (ch=0; ch<chars; ++ch)			CS[ch]=0;for (sp=0; sp<SOTU+clades; ++sp)	BL[sp]=0;steps=0;for (c=0; c<clades; ++c)	{	anc=c+SOTU;	for (d=1; d<tree[c][0]; ++d)	{		sp=tree[c][d];		BL[sp]=0;		for (ch=0; ch<chars; ++ch)	{			if (chmatrix[anc][ch]!=chmatrix[sp][ch])	{				if ((chmatrix[anc][ch]!=GAP && chmatrix[anc][ch]!=UNKNOWN) && (chmatrix[sp][ch]!=GAP && chmatrix[sp][ch]!=UNKNOWN))	{					if (ctype[ch]==1)	{						++BL[sp];						++CS[ch];						}					else if (ctype[ch]==0)	{						BL[sp]=BL[sp]+abs(chmatrix[sp][ch]-chmatrix[anc][ch]);						CS[ch]=CS[ch]+abs(chmatrix[sp][ch]-chmatrix[anc][ch]);						}					}				}			}		steps=steps+BL[sp];		}	}free ((void *)CS);return BL;}	int **ExhaustionCurve(int **chmatrix, int **BC, int *BL, int *FA, long **tree, int *nstates, int clades, int OTUs, int chars){int	a, c, d, sp, ch, S, F, i, br, maxstate, states, nchars, found;int	*chrealized;int **EC, **chobserved;nchars=states=maxstate=br=d=0;for (c=0; c<clades+OTUs; ++c)	if (BL[c]>0)	++d;for (ch=0; ch<chars; ++ch)		if (nstates[ch]>maxstate)	maxstate=nstates[ch];++maxstate;EC=imatrix(d,4);for (a=0; a<d; ++a)	for (c=0; c<4; ++c)	EC[a][c]=-1;/******************************************//*		EC[br][0]: species/*		EC[br][1]: cumulative steps/*		EC[br][2]: realized characters/*		EC[br][3]: realized character states/******************************************/	chrealized = ivector(chars);chobserved=imatrix(chars,maxstate);S=FA[1];F=FA[1];for (ch=0; ch<chars; ++ch)	{	for (a=0; a<maxstate; ++a)	chobserved[ch][a]=-1;	if (chmatrix[OTUs][ch]>=0 && chmatrix[OTUs][ch]<=maxstate)	{		chobserved[ch][0]=chmatrix[OTUs][ch];		chrealized[ch]=1;		}	else	chrealized[ch]=0;	}for (sp=2; sp<OTUs; ++sp)	{	if (FA[sp]<S)		S=FA[sp];	else if (FA[sp]>F)	F=FA[sp];	}	for (i=S; i<=F; ++i)	{	for (c=0; c<clades; ++c)	{		for (d=1; d<=tree[c][0]; ++d)	{			sp=tree[c][d];			if (FA[sp]==i && BL[sp]>0)	{				EC[br][0]=sp;				if (br==0)	EC[br][1]=BL[sp];				else		EC[br][1]=EC[br-1][1]+BL[sp];				for (ch=0; ch<chars; ++ch)	{					if (BC[sp][ch]>=0)	{						found=0;						for (a=0; a<chrealized[ch]; ++a)	{							if (BC[sp][ch]==chobserved[ch][a])	{								found=1;								a=chrealized[ch];								}							}						if (found==0)	{							chobserved[ch][chrealized[ch]]=BC[sp][ch];							if (chrealized[ch]==1)	++nchars;							++chrealized[ch];							++states;							}						}					}				EC[br][2]=nchars;				EC[br][3]=states;				++br;				}			}		}	}free ((void *)chrealized);free ((void **)chobserved);return EC;}
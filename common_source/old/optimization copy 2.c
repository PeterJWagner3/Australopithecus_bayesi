#define Optimization#include "optimization.h"#define memory#include "memory.h"#define matrixchange#include "matrixchange.h"#define matrixreading#include "matrixreading.h"#define minmax#include "minmax.h"#define sort#include "sort.h"#define TreeRead#include "TreeRead.h"/* Parsimony: finds the minimum number of steps needed for a tree to yield a matrix/*/* Requires: /*	chmatrix: taxon X character matrix of character states/*	tree: matrix giving tree, with first element giving # of branches and next X giving otu/htu # for branch/*	statetypes: character X states matrix giving states of each character/*	nstate: array giving the number of states for each character/*	ctype: array giving the type of each character (0: unordered; 1: ordered)/*	notu: number of taxa/*	nchars: number of characters/*	outgroup: taxon that is the outgroup/*	inap: code for inapplicable characters/*	unknown: code for unknown state/*/* Returns:/*	chmatrix: matrix modified to include ancestral conditions***************************************************************************************/long** parsimony(long **chmatrix, long **tree, int** statetypes, int* nstate, int* ctype, int clades, int notu, int nchars, int outgroup, int inap, int unknown){int		a, b, c, d, s, t, u, depend, anc, ch, sp1, sp2, node, maxtaxa, undec, mnst, mxst, found;int		*dependents,*ictype, *instate, **istatetypes, *bl, *stpres, *oldstpres/*,/ stpres[25], oldstpres[25]*/;long	**indmatrix;long	/**invmatrix, invmatrix[40][40],*/ **iinvmatrix;		/* for debugging *///float	e, f, x, y, w, z;depend = inapplicables(chmatrix,notu,nchars,inap);//invmatrix=TransposeLong(chmatrix,notu+clades,nchars);//invmatrix=lmatrix(nchars,notu+clades);undec=inap+unknown;if (depend>0)	{	dependents=inaplist(chmatrix,notu,nchars,inap,depend);	indmatrix=IndependentsMatrix(chmatrix, dependents, depend, notu, nchars, inap, unknown);		ictype=ivector(depend);	instate=ivector(depend);	clearivector(instate,depend,2);		istatetypes=imatrix(depend,2);	for (a=0; a<depend; ++a)	for (b=0; b<2; ++b)	istatetypes[a][b]=b;		indmatrix=parsimony(indmatrix,tree,istatetypes,instate,ictype,clades,notu,depend,outgroup,inap,unknown);	iinvmatrix=transposelong(indmatrix,notu+clades,depend);		for (c=0; c<depend; ++c)	{		ch=dependents[c];		for (sp1=notu; sp1<clades+notu; ++sp1)	{			if (indmatrix[sp1][c]==0)				chmatrix[sp1][ch]=inap;			else if (indmatrix[sp1][c]==1)			chmatrix[sp1][ch]=undec;			else if (indmatrix[sp1][c]==unknown)	chmatrix[sp1][ch]=unknown;/*			invmatrix[ch][sp1]=chmatrix[sp1][ch];	*/			}		}	}	//for (sp1=0; sp1<notu; ++sp1)	for (ch=0; ch<nchars; ++ch)	invmatrix[ch][sp1]=chmatrix[sp1][ch];mxst=maxiarray(nstate,nchars);stpres=ivector((10*mxst)+4);oldstpres=ivector((10*mxst)+4);/* clear ancestral conditions */maxtaxa = 2*notu;for (node=0; node<clades; ++node)	{	/* if a dependent character, then ancestral nodes lacking independent char are inap */	if (depend>0)	{		a=0;		for (ch=0; ch<nchars; ++ch)	{			if (ch!=dependents[a])					/*invmatrix[ch][node+notu]=*/chmatrix[node+notu][ch]=undec;			else	++a;			}		}	/* if an independent character, then all ancestral nodes are undecided */	else	{		for (ch=0; ch<nchars; ++ch)			/*invmatrix[ch][node+notu]=*/chmatrix[node+notu][ch]=undec;		}	}for (ch=0; ch<nchars; ++ch)	{	mnst=miniarray(statetypes[ch],nstate[ch]);	if (mnst<0)	mnst=0;	mxst=maxiarray(statetypes[ch],nstate[ch]);			/*** Find Shared States between Sister Taxa ***/	for (node=clades-1; node>=0; --node)	{		clearivector(stpres,mxst+4,0);		anc = notu+node;		if (chmatrix[anc][ch]!=inap)	{			b=0;			/* find the states present in the node */			stpres=cladestatespt(chmatrix, tree, stpres, node, notu, ch, mxst, mnst, inap, unknown, undec,1);			/* if all species in clade have the same state, then node has that state 	*/			/* exception - if both descendants are ambiguous clades, then we might be	*/			/*	able to distinguish between them if there are multistate characters		*/			c=pluralstate(stpres,mxst+2);			if (stpres[c]==tree[node][0] && (c>=0 && c<mxst+3))		{				b=1;				/*invmatrix[ch][anc]=*/chmatrix[anc][ch]=chmatrix[tree[node][1]][ch];				}				/* if a bifurcating clade and one undecided node */			else if (tree[node][0]==2)	{				/* if one descendant has unknown but the other is coded, then node gets the state of the descendant */				if (stpres[mxst+1]==1 && (stpres[mxst+2]==0 && stpres[mxst+3]==0))	{					/* this can be rewritten for polytomies by looking for plurality and subtracting inaps & undec */					for (c=0; c<=mxst; ++c)	{						if (stpres[c]==1)	{							/*invmatrix[ch][anc]=*/chmatrix[anc][ch]=c;							c=mxst+1;							b=1;							}						}					}								/* if one taxon is inapplicable but the other scored, then score it */				/*    as the scored taxon											*/				else if (stpres[mxst+2]==1)	{					sp1=tree[node][1];					sp2=tree[node][2];					if (chmatrix[sp1][ch]==inap)						/*invmatrix[ch][anc]=*/chmatrix[anc][ch]=chmatrix[sp2][ch];					else						/*invmatrix[ch][anc]=*/chmatrix[anc][ch]=chmatrix[sp1][ch];					b=1;					}				/* if a binary character... */				else if (nstate[ch]==2 && stpres[mxst+3]==1)	{					/* if there is an ambiguous daughter clade, then it must have 0 & 1 		*/					/* if so, then if the outgroup has X, both node and daughter node given X	*/					if (stpres[0]==1)		s=0;					else if (stpres[1]==1)	s=1;					/*invmatrix[ch][anc]=*/chmatrix[anc][ch]=s;										/* rescore ambiguous daughter clade */					if (chmatrix[tree[node][1]][ch]==undec)						/*invmatrix[ch][tree[node][1]]=*/chmatrix[tree[node][1]][ch]=s;					else						/*invmatrix[ch][tree[node][2]]=*/chmatrix[tree[node][2]][ch]=s;					b=1;					}	/* end binary routine */				/* if an unordered multistate... */				else if (ctype[ch]==1 && stpres[mxst+3]>0)	{					/* find states within uncertain nodes */					for (d=1; d<=tree[node][0]; ++d)	{						sp1=tree[node][d];						/* collapse states from daughter nodes descendants & look to see if we get a plurality */						if (chmatrix[sp1][ch]==undec)							stpres=cladestates(chmatrix, tree, stpres, sp1-notu, notu, ch, mxst, mnst, inap, unknown, undec);						}					/* see if one state is more common than the others; if so, then it is primitive */					s=t=1;					for (c=0; c<=mxst; ++c)	{						/* new most common state */						if (stpres[c]>s)	{							s=stpres[c];							u=c;							t=-1;							}						else if (stpres[c]==s)	t=1;						}	/* end search to see if one character is most common */					/* if there is no tie, then code ancestor and rescore ambiguous descendant clades */					if (t<1)	{						b=1;						/*invmatrix[ch][anc]=*/chmatrix[anc][ch]=u;						for (d=1; d<=tree[node][0]; ++d)	{							sp1=tree[node][d];							/* if descendant clade (sp1) is ambiguous, see if any of its descendants have state u */							if (chmatrix[sp1][ch]==undec)	{								for (c=1; c<=tree[sp1-notu][0] && chmatrix[sp1][ch]==undec; ++c)	{									sp2=tree[sp1-notu][c];									/* if so, then set the descendant clade (sp1) to state u*/									if (chmatrix[sp2][ch]==u)	/*invmatrix[ch][sp1]=*/chmatrix[sp1][ch]=u;									}	/* end search of granddaughter species */								}	/* end search of clade with undecided state */							}	/* end search of descendants for undecided clade */						}	/* end routine when there is a most common state within an ambiguous clade */					}	/* end unordered multistate routine */				/* ordered multistates */				else if (nstate[ch]>2 && stpres[mxst+3]>0)	{					/* find states within uncertain nodes */					for (d=1; d<=tree[node][0]; ++d)	{						sp1=tree[node][d];						/* collapse states from daughter nodes descendants & look to see if we get a plurality */						if (chmatrix[sp1][ch]==undec)							stpres=cladestates(chmatrix, tree, stpres, sp1-notu, notu, ch, mxst, mnst, inap, unknown, undec);						}	/* end collapsing of ambiguous daughter nodes */					}	/* end routine for continuous character */				}	/* end routine for a bifurcating node */			/* if clade is not resolved, try some more razzle dazzle */			/* this is the old routine - put ordered multistate routine above and delete */			}	/* end comparison of nodes in which ancestors are applicable */		}		/* End Search of Node */			/* END FIRST PASS  - now, optimize from the bottom if necessary */	/* use outgroup to optimize basal node */	if (chmatrix[notu][ch]==undec && chmatrix[notu][ch]!=inap)	{		if (chmatrix[outgroup][ch]!=inap && chmatrix[outgroup][ch]!=unknown)			/*invmatrix[ch][notu]=*/chmatrix[notu][ch]=chmatrix[outgroup][ch];		}	/* continue only if there still are ambiguous ancestral conditions */	a=0;	/* count ambiguous ancestral values */	for (sp1=notu; sp1<notu+clades && a==0; ++sp1)	{		if (chmatrix[sp1][ch]==undec)	a=1;		}			/*** Use Successive Outgroups to Polarize Indeterminate Characters ***/	if (a==1)	{		for (node=0; node<clades; ++node)	{			clearivector(stpres,mxst+4,0);			stpres=cladestatespt(chmatrix, tree, stpres, node, notu, ch, mxst, mnst, inap, unknown, undec,1);			/* skip clades that do not have ambiguous descendants */			d=matchstate(stpres,mxst+3);			while (d!=1 && node<clades)	{				++node;				clearivector(stpres,mxst+4,0);				stpres=cladestatespt(chmatrix, tree, stpres, node, notu, ch, mxst, mnst, inap, unknown, undec,1);				d=matchstate(stpres,mxst+3);				}							if (node>=clades)	break;			anc = notu+node;			/* NOTE TO SELF:  MAKE THIS RECURSIVE!!!! */			/* once a clade with ambiguous descendants is found, break them down */			for (s=1; s<=tree[node][0]; ++s)	{				sp1=tree[node][s];				/* if an ambiguous node is found, then do something about it! */				if (chmatrix[sp1][ch]==undec)	{					clearivector(oldstpres,mxst+4,0);					b=found=0;					/* found will become 1 when ambiguous node is optimized */					while (found==0)	{						++b;						clearivector(stpres,mxst+4,0);						/* find states present within ambiguous node */						stpres=cladestatespt(chmatrix, tree, stpres, sp1-notu, notu, ch, mxst, mnst, inap, unknown, undec,b);												/* make sure that we are not repeating ourselves endlessly.... */						d=compareivector(stpres,oldstpres,mxst+4);						if (d==0)	break; /* d=0 means that we are repeating ourselves */												/* see if the ancestral state matches one of the ingroup states */						c=matchstate(stpres,chmatrix[anc][ch]);						/* if nodal state exists within clade, then assign it to ambiguous node */						if (c==1)	{							/*invmatrix[ch][sp1]=*/chmatrix[sp1][ch]=chmatrix[anc][ch];							found=1;							}	/* end case where outgroup condition exists within clade */						/* if c=-1, then the outgroup did not match anything in the ingroup */						else	{							/* find the most common state */							c=pluralstate(stpres,mxst);							/* if there is no plural state, then collapse any daughter nodes */							/* else if c is a state, then assign it to ambiguous node */							if (c>=mnst && c<=mxst)	{								/*invmatrix[ch][sp1]=*/chmatrix[sp1][ch]=c;								found=1;								}	/* end case where we find the most common state */							}	/* end case where the outgroup does not match any taxon */						oldstpres=equalivector(oldstpres,stpres,mxst+4);						}	/* end attempt to optimize without going further up the tree */					}	/* end routine for optimizing ambiguous node */				}	/* end search for ambiguous daughter taxa */			}	/* end search of node */		}	/* End base-up optimization */	}	/* End Main pass */	/* use outgroup to optimize basal node */for (ch=0; ch<nchars && a==0; ++ch)	{	if (chmatrix[notu][ch]==undec && chmatrix[notu][ch]!=inap)	{		if (chmatrix[outgroup][ch]!=inap && chmatrix[outgroup][ch]!=unknown)			/*invmatrix[ch][notu]=*/chmatrix[notu][ch]=chmatrix[outgroup][ch];		}	}/* make sure that there are minimum uncertain ancestral reconstructions - they should be there only if all descendants are unknown *//*a=0;for (sp1=notu; sp1<(notu+clades) && a==0; ++sp1)	for (ch=0; ch<nchars && a==0; ++ch)		if (chmatrix[sp1][ch]==undec)	a=1;	*/a=findinlmatrix(chmatrix, notu, nchars, undec, notu, notu+clades);/* if there are uncertainties, assign the value of the least apomorphic species to the node */if (a>0)	{	bl=ivector(notu+clades);	for (ch=0; ch<nchars; ++ch)	{		for (node=0; node<clades; ++node)	{			anc=node+notu;			/* skip nodes that are unresolved or irrelevant */			while (node<clades && (chmatrix[anc][ch]==undec || (chmatrix[anc][ch]==unknown || chmatrix[anc][ch]==inap)))	{				++node;				++anc;				}			if (node>=clades)	break;			/* see if descendant states matches ancestral state */			for (b=1; b<=tree[node][0]; ++b)	{				sp1=tree[node][b];				while (b<=tree[node][0] && (chmatrix[sp1][ch]==undec || (chmatrix[sp1][ch]==unknown || chmatrix[sp1][ch]==inap)))	{					++b;					if (b<=tree[node][0])	sp1=tree[node][b];					}				if (b>tree[node][0])	break;				if (chmatrix[anc][ch]!=chmatrix[sp1][ch])					++bl[sp1];				}			}		}	/* now, use descendants with shortest branches as ancestral models */	for (ch=0; ch<nchars; ++ch)	{		for (node=(clades-1); node>=0; --node)	{			anc=node+notu;			if (chmatrix[anc=node+notu][ch]==undec)	{				/* find the descendant with the longest branches */				sp1=tree[node][1];				for (b=2; b<=tree[node][0]; ++b)	{					sp2=tree[node][b];					while (b<=tree[node][0] && (chmatrix[sp2][ch]==undec || (chmatrix[sp2][ch]==unknown || chmatrix[sp2][ch]==inap)))	{						++b;						if (b<=tree[node][0])	sp2=tree[node][b];						}					if (b>tree[node][0])	break;										/* assign shortest branches state to node		*/					/* if tie, then assign from species over clade	*/					if (bl[sp2]<bl[sp1])								sp1=sp2;					if (bl[sp2]==bl[sp1] && (sp1>=notu && sp2<=notu))	sp1=sp2;					}				/*invmatrix[ch][anc]=*/chmatrix[anc][ch]=chmatrix[sp1][ch];				}			}		}	free_ivector(bl);	}if (depend>0)	{	free_ivector(dependents);	free_lmatrix(indmatrix,notu,depend);	free_lmatrix(iinvmatrix,depend,notu);	free_ivector(ictype);	free_ivector(instate);	free_imatrix(istatetypes,depend,2);	}free_ivector(stpres);free_ivector(oldstpres);//free_lmatrix(invmatrix,notu+clades,nchars);return chmatrix;}/* Routine for optimizing states onto sp1 tree using simplistic parsimony but with some taxa pre-tabbed as ancestors/* Requires:/*		 1) chmatrix (matrix of charactesr)/*		 2) tree (matrix giving the taxa belonging to each node, with other nodes/*		 	given as #otus + Node#.  Thus, the basal node for 18 taxa is 18 (0..17,18)./*		 4) statetypes (matrix giving ??)/*		 5) nstates (array giving # states per character)/*		 6) ctype (array where 0=ordered, 1=unordered, etc....)/*		 7) clades (number of clades in the tree)/*		 8) otus (number of observed taxa)/*		 9) outgroup (taxon number of outgroup taxon; usually 0)/*		10) inap (code for inapplicable characters - note that these are treated differently than unknowns)/*		11) unknown (code for unknown states)/*		11) ANC (Array where 1 = ancestral [identical to node] and 0 = not ancestral)/********************************************************************************************************************************************************************/long** parsimonyanc(long **chmatrix, long **tree, int maxst, int* nstate, int* ctype, int clades, int otus, int chars, int outgroup, int inap, int unknown, int* ANC){int		a, b, c, d, anc, prnode, granc, ch, sp, sp1, node, ttltu, found, scored;int		**obsst, *htu, *adjst;int		*charcol, *spnode;int		e, f;ttltu=clades+otus;obsst=imatrix(clades,maxst+3);		/* this matrix will give the observed states within each node	*/adjst=ivector(maxst+3);					/* maxst+1 is for unknown; maxst+2 is for inapPLICABLE			*/htu=ivector(clades);					/* this will tell the ancestral clade for each node 			*/charcol=ivector(ttltu);					/* the column of states for each character at each TU			*/spnode=ivector(otus);					/* node to which each species belong; for debugging 			*//* list the ancestral nodes for each node */for (a=0; a<clades; ++a)	{	for (b=1; b<=tree[a][0]; ++b)	{		sp1=tree[a][b];		if (sp1>otus)	htu[sp1-otus]=a;		else			spnode[sp1]=a;		}	} for (ch=0; ch<chars; ++ch)	{	/* do not waste time on invariant characters */	for (ch=ch; nstate[ch]<2 && ch<chars; ++ch)	{		for (sp1=0; (chmatrix[sp1][ch]==inap || chmatrix[sp1][ch]==unknown); ++sp1);		c=chmatrix[sp1][ch];	/* find state that everyone shares */		for (sp1=otus; sp1<ttltu; ++sp1) chmatrix[sp1][ch]=c;		}	/*	clear character column array	*/	for (sp1=0; sp1<ttltu; ++sp1)	{		if (sp1<otus)	charcol[sp1]=chmatrix[sp1][ch];		if (sp1>=otus)	charcol[sp1]=chmatrix[sp1][ch]=unknown;		}	for (node=0; node<clades; ++node)	{		anc=node+otus;		for (c=0; c<=maxst+3; ++c)	obsst[node][c]=0;		/* find the states of observed taxa within nodes 				*/		/* if ancestor is designated, assign its states to the ancestor */		for (a=1; a<=tree[node][0]; ++a)	{			sp1=tree[node][a];			if (sp1<otus)	{				if (ANC[sp1]==1)	charcol[anc]=chmatrix[anc][ch]=chmatrix[sp1][ch];				c=chmatrix[sp1][ch];				if (c==unknown)		++obsst[node][maxst+1];				else if (c==inap)	++obsst[node][maxst+2];				else if (c<=maxst)	++obsst[node][c];				else	{					printf("Sp. %d is out of range for Char %d with state %d\n",sp1,ch,c);					}				}			}		}	/* finish listing observed states of otus within nodes */		/*** Start from the Top and Determine Shared States among Sister Taxa ****/	for (node=clades-1; node>0; --node)	{		anc=node+otus;		/* taxon number of ancestor */		prnode=htu[node];	/* find ancestral node */		/* skip nodes who's conditions are known */		for (c=0; c<=maxst; ++c)	adjst[c]=0;		if (chmatrix[anc][ch]==unknown)	{			/* find if all species have the same state */			if (obsst[node][maxst+1]==tree[node][0])	charcol[anc]=chmatrix[anc][ch]=unknown;			else if ((obsst[node][maxst+1]+obsst[node][maxst+2])==tree[node][0])													charcol[anc]=chmatrix[anc][ch]=inap;			else	{				found=scored=0;	/* find species not coded as gaps or unknowns */				for (c=0; c<=maxst; ++c)	scored=scored+obsst[node][c];				/* ancestral state can be defined only if 2+ taxa have states */				if (scored>1)	{					for (c=0; c<=maxst; ++c)	{						/* if more than half the species have the state, give it to the ancestor */						if (obsst[node][c]>scored/2)	{							charcol[anc]=chmatrix[anc][ch]=c;							++obsst[prnode][c];	/* add state to "observed" states of ancestral node */							c=maxst+2;							found=1;							}						}				/* not sp1 clear cut case  - look at ancestor or descendant nodes! */					if (found==0)	{						/* find the distribution of states node and species linked to lower node */						for (c=0; c<=maxst; ++c)							adjst[c]=obsst[prnode][c]+obsst[node][c];						/* now see if the majority belong to any state */						a=b=d=scored=0;						for (c=0; c<=maxst; ++c)	scored=scored+adjst[c];						for (c=0; c<=maxst; ++c)	{							if (adjst[c]>a)	{								a=adjst[d=c];								b=1;								}							else if (adjst[c]==a)	++b;														}						/* if no majority, go with the plurality */						if (found==0 && b==1)	{							charcol[anc]=chmatrix[anc][ch]=d;							++obsst[prnode][d];							found=1;							}						}	/* end search for majority state */					/* if still no solution, dump the observed states into the ancestral observed states */					if (found==0)	{						for (c=0; c<=maxst; ++c)	obsst[prnode][c]=obsst[prnode][c]+obsst[node][c];						}					}				}	/* end examination of node */			}		else	{			++obsst[prnode][chmatrix[anc][ch]];			}		}	/* end downward pass */		/*** Use Outgroup to Polarize Indeterminate Characters at Base of Tree ***/	if (chmatrix[otus][ch]==unknown)	{		/* first see if the information already is in the node */		/* we could not test it above because there is no lower node to which to refer */		found=a=b=d=scored=0;		for (c=0; c<=maxst; ++c)	{			if (obsst[0][c]>a)	{				a=obsst[0][d=c];				b=1;				}			else if (obsst[0][c]==a)	++b;			}		if (b==1)	{			charcol[otus]=chmatrix[otus][ch]=d;			found=1;			}		/* if nothing found, then see if any match the outgroup */		if (found==0)	{			for (c=0; c<=maxst; ++c)	{				if (obsst[0][c]==chmatrix[outgroup][ch])	{					charcol[otus]=chmatrix[otus][ch]=c;					c=maxst;					found=1;					}				}			}		/* if still stuck, chose the one closest to the outgroup */		if (found==0 && b>1)	{			a=maxst;			for (c=0; c<=maxst; ++c)	{				/* different routine for ordered and unordered */				if (ctype[ch]==1)	{					if (obsst[0][c]>0 && abs(chmatrix[otus][ch]-c)<a)	{						a=abs(chmatrix[otus][ch]-c);						d=c;						b=1;						}					else if (obsst[0][c]>0 && abs(chmatrix[otus][ch]-c)==a)	++b;					}				else if (ctype[ch]==0)	{					e=f=0;					for (c=0; c<=maxst; ++c)	{						if (obsst[node][c]>0)	{							e=e+c;							f=f+1;							}						}					e=e/f;					}				}			}	/* end search for closest state */		}/*** Use Successive Outgroups to Polarize Indeterminate Characters ***/	for (node=1; node<clades; ++node)	{			for (node=node; chmatrix[node+otus][ch]!=unknown && node<clades; ++node);		if (node>=clades)	break;				anc=node+otus;		/* taxon number of ancestor */		prnode=htu[node];	/* find ancestral node */		granc=prnode+otus;				/* only do this if necessary */		if (chmatrix[anc][ch]==unknown && chmatrix[granc][ch]!=unknown)	{			/* first - check to see if ancestral node matches one of the observed states within this node */			found=0;			for (c=0; c<=maxst; ++c)	{				if (chmatrix[granc][ch]==c && obsst[node][c]>0)	{					charcol[anc]=chmatrix[anc][ch]=c;					found=1;					c=maxst;					}				}			/* no dice?  chose the one closest to the outgroup */			if (found==0)	{				a=maxst;				for (c=0; c<=maxst; ++c)	{					if (obsst[node][c]>0 && abs(chmatrix[granc][ch]-c)<a)	{						a=abs(chmatrix[granc][ch]-c);						d=c;						b=1;						}					else if (obsst[node][c]>0 && abs(chmatrix[granc][ch]-c)==a)	++b;					}				if (b==1)					charcol[anc]=chmatrix[anc][ch]=d;				else if (b==2)	{					/* in case of tie, if ordered retain former condition */					if (ctype[ch]==0)	charcol[anc]=chmatrix[anc][ch]=chmatrix[granc][ch];					/* if unordered, it really does not matter */					else if (ctype[ch]==1)						charcol[anc]=chmatrix[anc][ch]=d;					}				}			}	/* end attempt to find ancestral condition */				/* if nothing found, then choose one of the states and run with it */				}	/* end optimization from bottom up *//*** Start at Node 1 - Node 0 is polarized by the Outgroup */			/* final sweep - work from top down to make sure all unknown clades have nothing but unknowns attached */	}	/* end optimization of character */	free_ivector(adjst);free_ivector(htu);free_imatrix(obsst,clades,maxst+3);free_ivector(charcol);free_ivector(spnode);return chmatrix;}/* BranchChanges: tells whether a character changes on a branch/*/* Requires: /*	chmatrix: taxon X character matrix of character states/*	tree: matrix giving tree, with first element giving # of branches and next X giving otu/htu # for branch/*	ctype: array giving the type of each character (0: unordered; 1: ordered)/*	notu: number of taxa/*	nchars: number of characters/*	inap: code for inapplicable characters/*	unknown: code for unknown state/*/* Returns:/*	BC: branch X character matrix telling whether a character changes (1) or not (0) on a branch***************************************************************************************/int** BranchChanges(long **chmatrix, long **tree, int nchars, int clades, int notu, int inap, int unknown){int	c, d, sp, anc, ch;int	**BC;BC=imatrix(clades+notu,nchars);for (sp=0; sp<clades+notu; ++sp)	for (ch=0; ch<nchars; ++ch)	BC[sp][ch]=-5;for (c=0; c<clades; ++c)	{	anc=c+notu;	for (d=1; d<=tree[c][0]; ++d)	{		sp=tree[c][d];		for (ch=0; ch<nchars; ++ch)	{			if (chmatrix[anc][ch]!=chmatrix[sp][ch])	{				if ((chmatrix[anc][ch]!=inap && chmatrix[anc][ch]!=unknown) && (chmatrix[sp][ch]!=inap && chmatrix[sp][ch]!=unknown))	{					BC[sp][ch]=chmatrix[sp][ch];					}				}			}		}	}return BC;}	/* BranchLengths: finds the number of steps per branch for a tree to yield a matrix/*/* Requires: /*	chmatrix: taxon X character matrix of character states/*	tree: matrix giving tree, with first element giving # of branches and next X giving otu/htu # for branch/*	ctype: array giving the type of each character (0: unordered; 1: ordered)/*	notu: number of taxa/*	nchars: number of characters/*	clades: number of clades/*	inap: code for inapplicable characters/*	unknown: code for unknown state/*/* Returns:/*	bl: array giving the number of changes per branch***************************************************************************************/int* BranchLengths(long **chmatrix, long **tree, int* ctype, int nchars, int clades, int notu, int inap, int unknown){int	c, d, sp, anc, ch, steps;int	*bl, *CC;bl = ivector(clades+notu);CC = ivector(nchars);steps=0;for (c=0; c<clades; ++c)	{	anc=c+notu;	for (d=1; d<=tree[c][0]; ++d)	{		sp=tree[c][d];		bl[sp]=0;		for (ch=0; ch<nchars; ++ch)	{			while ((chmatrix[anc][ch]==inap || chmatrix[anc][ch]==unknown) && ch<nchars)				++ch;			if (ch>=nchars)	break;			if (chmatrix[anc][ch]!=chmatrix[sp][ch] && (chmatrix[sp][ch]!=inap && chmatrix[sp][ch]!=unknown))	{				if (ctype[ch]==1)		{					++bl[sp];					++CC[ch];					}				else if (ctype[ch]==0)	{					bl[sp]=bl[sp]+abs(chmatrix[sp][ch]-chmatrix[anc][ch]);					CC[ch]=CC[ch]+abs(chmatrix[sp][ch]-chmatrix[anc][ch]);					}				}			}		steps=steps+bl[sp];		}	}free_ivector(CC);return bl;}/* ExhaustionCurve: yields a branch X 2 matrix giving the number of changes and the number of realized states/*/* Requires: /*	chmatrix: taxon X character matrix of character states/*	BC: matrix telling what changes on each branch/*	bl: array giving the type of each character (0: unordered; 1: ordered)/*	tree: matrix giving tree, with first element giving # of branches and next X giving otu/htu # for branch/*	clades: number of clades/*	notu: number of taxa/*	nchars: number of characters/*/* Returns:/*	EC: branch X 4 Exhaustion curve/*		EC[br][SP=0]: cumulative branches/*		EC[br][TL=1]: cumulative steps/*		EC[br][CH=2]: realized characters/*		EC[br][ST=3]: realized character states***************************************************************************************/int **ExhaustionCurve(long **chmatrix, int **BC, int *bl, long *FA, long **tree, int *nstates, int clades, int notu, int nchars){int	a, c, d, sp, ch, S, F, i, br, mxst, states, nch, found;int	*chrealized;int **EC, **chobserved;int SP=0,TL=1,CH=2,ST=3;	/* SP: species; TL: branch length; CH: realized chars; ST: realized states */nch=states=mxst=br=d=0;for (c=0; c<clades+notu; ++c)	if (bl[c]>0)	++d;/* find highest state to allocate memory */mxst=1+maxiarray(nstates,nchars);/* allocate memory */EC=imatrix(d,4);for (a=0; a<d; ++a)	for (c=0; c<4; ++c)	EC[a][c]=-1;chrealized = ivector(nchars);chobserved = imatrix(nchars,mxst);/* find the oldest and youngest taxa for adding taxa over time */S=minlarray(FA,notu);F=maxlarray(FA,notu);/* find the already realized states */for (ch=0; ch<nchars; ++ch)	{	for (a=0; a<mxst; ++a)	chobserved[ch][a]=-1;	if (chmatrix[notu][ch]>=0 && chmatrix[notu][ch]<=mxst)	{		chobserved[ch][0]=chmatrix[notu][ch];		chrealized[ch]=1;		}	else	chrealized[ch]=0;	}br=0;	/* br counts the number of non-zero length branches as zeros are not included */for (i=S; i<=F; ++i)	{	/* find species / branches originating in time i */	for (c=0; c<clades; ++c)	{		for (d=1; d<=tree[c][0]; ++d)	{			sp=tree[c][d];			if (FA[sp]==i && bl[sp]>0)	{				EC[br][SP]=sp;				if (br==0)	EC[br][TL]=bl[sp];				else		EC[br][TL]=EC[br-1][TL]+bl[sp];				for (ch=0; ch<nchars; ++ch)	{					/* find characters that change */					if (BC[sp][ch]>=0)	{						found=0;						for (a=0; a<chrealized[ch]; ++a)	{							/* check whether "new" state actually is new */							if (BC[sp][ch]==chobserved[ch][a])	{								found=1;			/* indicates we have found it before */								a=chrealized[ch];								}							}						/* if new, then chalk it up as realized */						if (found==0)	{							chobserved[ch][chrealized[ch]]=BC[sp][ch];							if (chrealized[ch]==1)	++nch;							++chrealized[ch];							++states;							}						}					}				EC[br][CH]=nch;				EC[br][ST]=states;				++br;				}			}		}	}free_ivector(chrealized);free_imatrix(chobserved,nchars,mxst);return EC;}/* ExhaustionCurve: yields a branch X 2 matrix giving the number of changes and the number of realized states/*/* Requires: /*	chmatrix: taxon X character matrix of character states/*	BC: matrix telling what changes on each branch/*	bl: array giving the type of each character (0: unordered; 1: ordered)/*	tree: matrix giving tree, with first element giving # of branches and next X giving otu/htu # for branch/*	clades: number of clades/*	notu: number of taxa/*	nchars: number of characters/*/* Returns:/*	EC: branch X 4 Exhaustion curve/*		ECB[br][SP=0]: cumulative branches/*		ECB[br][TL=1]: cumulative steps/*		ECB[br][CH=2]: realized characters/*		ECB[br][ST=3]: realized character states***************************************************************************************/int **ExhaustionCurveBoot(long **chmatrix, int **BC, int *bl, long *FA, long **tree, int *nstates, int clades, int notu, int nchars){int	a, c, rep, sp, ch, S, F, i, j, k, br, states, nch, found;int	mxst, mxd, tu;int	*chrealized, *diversity, *ancestor, *length;int **standing, **EC, **ECB, **chobserved;int SP=0,TL=1,CH=2,ST=3;	/* SP: species; TL: branch length; CH: realized chars; ST: realized states */double	y;/* find the oldest and youngest taxa for adding taxa over time */S=minlarray(FA,notu);F=maxlarray(FA,notu);/* assign taxa to bins */diversity=ivector(F+1);for (a=0; a<clades+notu; ++a)	if (bl[a]>0)	++diversity[FA[a]];mxd=maxiarray(diversity,F+1);standing=imatrix(F+1,mxd+1);clearivector(diversity,F+1,0);for (a=0; a<clades+notu; ++a)	{	if (bl[a]>0)	{		standing[FA[a]][diversity[FA[a]]]=a;		++diversity[FA[a]];		}	}/* finish assigning taxa to bins */mxst=tu=0;for (c=0; c<clades+notu; ++c)	if (bl[c]>0)	++tu;/* find highest state to allocate memory */mxst=1+maxiarray(nstates,nchars);/* allocate memory */EC=imatrix(tu,4);ECB=imatrix(tu,4);		/* ECB will be the temporary arrays, which will be an average of the bootstraps */for (a=0; a<tu; ++a)	for (c=0; c<4; ++c)	EC[a][c]=-1;chrealized = ivector(nchars);chobserved = imatrix(nchars,mxst);ancestor=listancestor(tree,clades,notu);length=ivector(tu);for (rep=0; rep<100; ++rep)	{	/* find the already realized states */	for (ch=0; ch<nchars; ++ch)	{		for (a=0; a<mxst; ++a)	chobserved[ch][a]=-1;		if (chmatrix[notu][ch]>=0 && chmatrix[notu][ch]<=mxst)	{			chobserved[ch][0]=chmatrix[notu][ch];			chrealized[ch]=1;			}		else	chrealized[ch]=0;		}	br=nch=states=br=0;	/* br counts the number of non-zero length branches as zeros are not included */	clearivector(length,tu,0);	for (i=S; i<=F; ++i)	{		standing[i]=scrambleiarray(standing[i],diversity[i]);		/* now, enforce the phylogenetic order */		for (j=diversity[i]-2; j>=0; --j)	{			sp=standing[i][j];			a=ancestor[sp];			/* if a appears in interval i, too, then make sure it is higher on the list */			if (FA[a]==i)	{				for (k=j; k<diversity[i]; ++k)	{					/* if ancestor was behind sp, then flip-flop */					if (standing[i][k]==a)	{						standing[i][k]=sp;						standing[i][j]=a;						/* if a's ancestor appears in interval i, then reset j to k; otherwise, keep moving */						if (FA[ancestor[a]]==i)	j=k;						k=diversity[i];						}	/* finish flip-flop */					}	/* finish search for ancestor */				}	/* end routine for contemporaneous ancestor-descendants */			}	/* end re-ordering */		for (c=0; c<diversity[i]; ++c)	{			sp=standing[i][c];			/* these will be added over all 100 bootstrap runs - they then will be averaged out */			if (br==0)	length[br]=bl[sp];			else		length[br]=length[br-1]+bl[sp];			ECB[br][TL]=ECB[br][TL]+length[br];			for (ch=0; ch<nchars; ++ch)	{				/* find characters that change */				if (BC[sp][ch]>=0)	{					found=0;					for (a=0; a<chrealized[ch]; ++a)	{						/* check whether "new" state actually is new */						if (BC[sp][ch]==chobserved[ch][a])	{							found=1;			/* indicates we have found it before */							a=chrealized[ch];							}						}					/* if new, then chalk it up as realized */					if (found==0)	{						chobserved[ch][chrealized[ch]]=BC[sp][ch];						if (chrealized[ch]==1)	++nch;						++chrealized[ch];						++states;						}					}	/* end test for whether change generates a new character */ 				}	/* end test for new states */			/* these will be added over all 100 bootstrap runs - they then will be averaged out */			ECB[br][CH]=ECB[br][CH]+nch;			ECB[br][ST]=ECB[br][ST]+states;			++br;			}	/* end interval i */				}	/* end individual trial */	}	/* end bootstrap trials */for (a=0; a<br; ++a)	{	y=ECB[a][TL];	y=y/100;	ECB[a][TL]=ECB[a][TL]/100;	if (y-ECB[a][TL]>=0.5)	++ECB[a][TL];	EC[a][TL]=ECB[a][TL];		y=ECB[a][CH];	y=y/100;	ECB[a][CH]=ECB[a][CH]/100;	if (y-ECB[a][CH]>=0.5)	++ECB[a][CH];	EC[a][CH]=ECB[a][CH];		y=ECB[a][ST];	y=y/100;	ECB[a][ST]=ECB[a][ST]/100;	if (y-ECB[a][ST]>=0.5)	++ECB[a][ST];	EC[a][ST]=ECB[a][ST];	}free_ivector(chrealized);free_ivector(length);free_ivector(ancestor);free_imatrix(chobserved,nchars,mxst);free_imatrix(standing,F+1,mxd+1);free_ivector(diversity);free_imatrix(ECB,tu,4);return EC;}/* IndependentsMatrix: yields an auxillary matrix giving presence/absence of independent character for characters with inapplicables.  /*/* Requires: /*	chmatrix: taxon X character matrix of character states/*	dependents: array giving the character number of dependent states/*	depend: number of dependent states/*	tree: matrix giving tree, with first element giving # of branches and next X giving otu/htu # for branch/*	notu: number of taxa/*	nchars: number of characters/*	inap: code for inapplicable/*	unknown: code for unknown/*/* Returns:/*	indmatrix: a matrix of independent correlates of the dependent characters*********************************************************************************************************************************************/long **IndependentsMatrix(long **chmatrix, int *dependents, int depend, int notu, int nchars, int inap, int unknown){int	ch, sp, d=0;long **indmatrix;indmatrix=lmatrix(notu*2,depend);for (ch=0; ch<nchars && d<depend; ++ch)	{	while (ch!=dependents[d] && ch<nchars)	++ch;	if (ch>=nchars)	break;		for (sp=0; sp<notu; ++sp)	{		if (chmatrix[sp][ch]==inap)			indmatrix[sp][d]=0;		else if (chmatrix[sp][ch]==unknown)	indmatrix[sp][d]=unknown;		else								indmatrix[sp][d]=1;		}	++d;	}return indmatrix;}/* cladestate: moddified array giving the states present in a clade & at least one daughter clade  /*/* Requires: /*	chmatrix: taxon X character matrix of character states/*	tree: matrix giving tree, with first element giving # of branches and next X giving otu/htu # for branch/*	stpres: array giving the states present in a clade/*	node: node number/*	notu: number of taxa/*	ch: character number/*	mxst: highest state for the character/*	mnst: lowest state for the character/*	inap: code for inapplicable/*	unknown: code for unknown/*	undec: code for a clade with uncertain state/*/* Returns:/*	stpres: moddified array giving the states present in a clade & at least one daughter clade*********************************************************************************************************************************************/int *cladestates(long **chmatrix, long **tree, int *stpres, int node, int notu, int ch, int mxst, int mnst, int inap, int unknown, int undec){int	a, c, sp;for (a=1; a<=tree[node][0]; ++a)	{	sp=tree[node][a];	/* routine if character scored */	if (chmatrix[sp][ch]>=mnst && chmatrix[sp][ch]<=mxst)	++stpres[c=chmatrix[sp][ch]];	else if (chmatrix[sp][ch]==unknown)						++stpres[c=mxst+1];	else if (chmatrix[sp][ch]==inap)						++stpres[c=mxst+2];	else if (chmatrix[sp][ch]==undec)		stpres=cladestates(chmatrix, tree, stpres, sp-notu, notu, ch, mxst, mnst, inap, unknown, undec);	}if (stpres[c=mxst+3]>0)	--stpres[c=mxst+3];return stpres;}/* cladestatespt: moddified array giving the states present in a clade & at least one daughter clade  /*/* Requires: /*	chmatrix: taxon X character matrix of character states/*	tree: matrix giving tree, with first element giving # of branches and next X giving otu/htu # for branch/*	stpres: array giving the states present in a clade/*	node: node number/*	notu: number of taxa/*	ch: character number/*	mxst: highest state for the character/*	mnst: lowest state for the character/*	inap: code for inapplicable/*	unknown: code for unknown/*	undec: code for a clade with uncertain state/*	depth: how many nodes "up" it should go breaking down ambiguous clades/*/* Returns:/*	stpres: moddified array giving the states present in a clade & at least one daughter clade*********************************************************************************************************************************************/int *cladestatespt(long **chmatrix, long **tree, int *stpres, int node, int notu, int ch, int mxst, int mnst, int inap, int unknown, int undec, int depth){int	a, c, sp;for (a=1; a<=tree[node][0]; ++a)	{	sp=tree[node][a];	/* routine if character scored */	if (chmatrix[sp][ch]>=mnst && chmatrix[sp][ch]<=mxst)	++stpres[c=chmatrix[sp][ch]];	else if (chmatrix[sp][ch]==unknown)						++stpres[c=mxst+1];	else if (chmatrix[sp][ch]==inap)						++stpres[c=mxst+2];	else if (chmatrix[sp][ch]==undec)	{		if (depth==1)										++stpres[c=mxst+3];		else if (depth>=1)	{			stpres=cladestatespt(chmatrix, tree, stpres, sp-notu, notu, ch, mxst, mnst, inap, unknown, undec, depth-1);			}		}	}return stpres;}/* pluralstate: finds the most common state in an array  /*/* Requires: /*	stpres: array giving the states present in a clade/*	mxst: highest state for the character/*/* Returns:/*	u: the most common state; returns -1 if there is no single most common state*********************************************************************************************************************************************/int pluralstate(int *stpres,int mxst){int	c, s, t, u;s=t=1;for (c=0; c<=mxst; ++c)	{	/* new most common state */	if (stpres[c]>s)	{		s=stpres[c];		u=c;		t=-1;		}	else if (stpres[c]==s)	t=1;	}	if (t==-1)	return u;else	{	u=-1;	return u;	}}/* matchstate: determines whether a state is present in a collection of states  /*/* Requires: /*	stpres: array giving the states present in a clade/*	state: state to be matched/*/* Returns:/*	u: returns 0 if there is no match, 1 if there is a match*********************************************************************************************************************************************/int matchstate(int *stpres,int state){int	u=0;if (stpres[state]>=1)	u=1;return u;}/* Parsimony: finds the minimum number of steps needed for a tree to yield a matrix/*/* Requires: /*	chmatrix: taxon X character matrix of character states/*	tree: matrix giving tree, with first element giving # of branches and next X giving otu/htu # for branch/*	statetypes: character X states matrix giving states of each character/*	nstate: array giving the number of states for each character/*	ctype: array giving the type of each character (0: unordered; 1: ordered)/*	notu: number of taxa/*	nchars: number of characters/*	outgroup: taxon that is the outgroup/*	inap: code for inapplicable characters/*	unknown: code for unknown state/*/* Returns:/*	chmatrix: matrix modified to include ancestral conditions***************************************************************************************/long** inferancpars(long **chmatrix, long **tree, int** statetypes, int* nstate, int* ctype, int clades, int notu, int nchars, int outgroup, int inap, int unknown){int		a, b, c, d, s, t, u, depend, anc, ch, sp1, sp2, node, maxtaxa, undec, mnst, mxst, found;int		*dependents,*ictype, *instate, **istatetypes, *bl, *stpres, *oldstpres/*,/ stpres[25], oldstpres[25]*/;long	**indmatrix, **iinvmatrix;		/* for debugging *///float	e, f, x, y, w, z;long	**ancmatrix;depend = inapplicables(chmatrix,notu,nchars,inap);ancmatrix=lmatrix(clades,nchars);undec=inap+unknown;if (depend>0)	{	dependents=inaplist(chmatrix,notu,nchars,inap,depend);	indmatrix=IndependentsMatrix(chmatrix, dependents, depend, notu, nchars, inap, unknown);		ictype=ivector(depend);	instate=ivector(depend);	clearivector(instate,depend,2);		istatetypes=imatrix(depend,2);	for (a=0; a<depend; ++a)	for (b=0; b<2; ++b)	istatetypes[a][b]=b;		indmatrix=parsimony(indmatrix,tree,istatetypes,instate,ictype,clades,notu,depend,outgroup,inap,unknown);	iinvmatrix=transposelong(indmatrix,notu+clades,depend);		for (c=0; c<depend; ++c)	{		ch=dependents[c];		for (node=0; node<clades; ++node)	{			sp1=node;			if (indmatrix[sp1][c]==0)				ancmatrix[node][ch]=inap;			else if (indmatrix[sp1][c]==1)			ancmatrix[node][ch]=undec;			else if (indmatrix[sp1][c]==unknown)	ancmatrix[node][ch]=unknown;/*			invmatrix[ch][sp1]=ancmatrix[node][ch];	*/			}		}	}	//for (sp1=0; sp1<notu; ++sp1)	for (ch=0; ch<nchars; ++ch)	invmatrix[ch][sp1]=ancmatrix[node][ch];mxst=maxiarray(nstate,nchars);stpres=ivector((10*mxst)+4);oldstpres=ivector((10*mxst)+4);/* clear ancestral conditions */maxtaxa = 2*notu;for (node=0; node<clades; ++node)	{	/* if a dependent character, then ancestral nodes lacking independent char are inap */	if (depend>0)	{		a=0;		for (ch=0; ch<nchars; ++ch)	{			if (ch!=dependents[a])					/*invmatrix[ch][node+notu]=*/ancmatrix[node][ch]=undec;			else	++a;			}		}	/* if an independent character, then all ancestral nodes are undecided */	else	{		for (ch=0; ch<nchars; ++ch)			/*invmatrix[ch][node+notu]=*/ancmatrix[node][ch]=undec;		}	}for (ch=0; ch<nchars; ++ch)	{	mnst=miniarray(statetypes[ch],nstate[ch]);	if (mnst<0)	mnst=0;	mxst=maxiarray(statetypes[ch],nstate[ch]);			/*** Find Shared States between Sister Taxa ***/	for (node=clades-1; node>=0; --node)	{		clearivector(stpres,mxst+4,0);		anc = notu+node;		if (ancmatrix[node][ch]!=inap)	{			b=0;			/* find the states present in the node */			stpres=cladestatespt(chmatrix, tree, stpres, node, notu, ch, mxst, mnst, inap, unknown, undec,1);			/* if all species in clade have the same state, then node has that state 	*/			/* exception - if both descendants are ambiguous clades, then we might be	*/			/*	able to distinguish between them if there are multistate characters		*/			c=pluralstate(stpres,mxst+2);			if (stpres[c]==tree[node][0] && (c>=0 && c<mxst+3))		{				b=1;				/*invmatrix[ch][anc]=*/ancmatrix[node][ch]=chmatrix[tree[node][1]][ch];				}				/* if a bifurcating clade and one undecided node */			else if (tree[node][0]==2)	{				/* if one descendant has unknown but the other is coded, then node gets the state of the descendant */				if (stpres[mxst+1]==1 && (stpres[mxst+2]==0 && stpres[mxst+3]==0))	{					/* this can be rewritten for polytomies by looking for plurality and subtracting inaps & undec */					for (c=0; c<=mxst; ++c)	{						if (stpres[c]==1)	{							/*invmatrix[ch][anc]=*/ancmatrix[node][ch]=c;							c=mxst+1;							b=1;							}						}					}								/* if one taxon is inapplicable but the other scored, then score it */				/*    as the scored taxon											*/				else if (stpres[mxst+2]==1)	{					sp1=tree[node][1];					sp2=tree[node][2];					if (chmatrix[sp1][ch]==inap)						/*invmatrix[ch][anc]=*/ancmatrix[node][ch]=chmatrix[sp2][ch];					else						/*invmatrix[ch][anc]=*/ancmatrix[node][ch]=chmatrix[sp1][ch];					b=1;					}				/* if a binary character... */				else if (nstate[ch]==2 && stpres[mxst+3]==1)	{					/* if there is an ambiguous daughter clade, then it must have 0 & 1 		*/					/* if so, then if the outgroup has X, both node and daughter node given X	*/					if (stpres[0]==1)		s=0;					else if (stpres[1]==1)	s=1;					/*invmatrix[ch][anc]=*/ancmatrix[node][ch]=s;										/* rescore ambiguous daughter clade */					if (chmatrix[tree[node][1]][ch]==undec)						/*invmatrix[ch][tree[node][1]]=*/chmatrix[tree[node][1]][ch]=s;					else						/*invmatrix[ch][tree[node][2]]=*/chmatrix[tree[node][2]][ch]=s;					b=1;					}	/* end binary routine */				/* if an unordered multistate... */				else if (ctype[ch]==1 && stpres[mxst+3]>0)	{					/* find states within uncertain nodes */					for (d=1; d<=tree[node][0]; ++d)	{						sp1=tree[node][d];						/* collapse states from daughter nodes descendants & look to see if we get a plurality */						if (chmatrix[sp1][ch]==undec)							stpres=cladestates(chmatrix, tree, stpres, sp1-notu, notu, ch, mxst, mnst, inap, unknown, undec);						}					/* see if one state is more common than the others; if so, then it is primitive */					s=t=1;					for (c=0; c<=mxst; ++c)	{						/* new most common state */						if (stpres[c]>s)	{							s=stpres[c];							u=c;							t=-1;							}						else if (stpres[c]==s)	t=1;						}	/* end search to see if one character is most common */					/* if there is no tie, then code ancestor and rescore ambiguous descendant clades */					if (t<1)	{						b=1;						/*invmatrix[ch][anc]=*/ancmatrix[node][ch]=u;						for (d=1; d<=tree[node][0]; ++d)	{							sp1=tree[node][d];							/* if descendant clade (sp1) is ambiguous, see if any of its descendants have state u */							if (chmatrix[sp1][ch]==undec)	{								for (c=1; c<=tree[sp1-notu][0] && chmatrix[sp1][ch]==undec; ++c)	{									sp2=tree[sp1-notu][c];									/* if so, then set the descendant clade (sp1) to state u*/									if (chmatrix[sp2][ch]==u)	/*invmatrix[ch][sp1]=*/chmatrix[sp1][ch]=u;									}	/* end search of granddaughter species */								}	/* end search of clade with undecided state */							}	/* end search of descendants for undecided clade */						}	/* end routine when there is a most common state within an ambiguous clade */					}	/* end unordered multistate routine */				/* ordered multistates */				else if (nstate[ch]>2 && stpres[mxst+3]>0)	{					/* find states within uncertain nodes */					for (d=1; d<=tree[node][0]; ++d)	{						sp1=tree[node][d];						/* collapse states from daughter nodes descendants & look to see if we get a plurality */						if (chmatrix[sp1][ch]==undec)							stpres=cladestates(chmatrix, tree, stpres, sp1-notu, notu, ch, mxst, mnst, inap, unknown, undec);						}	/* end collapsing of ambiguous daughter nodes */					}	/* end routine for continuous character */				}	/* end routine for a bifurcating node */			/* if clade is not resolved, try some more razzle dazzle */			/* this is the old routine - put ordered multistate routine above and delete */			}	/* end comparison of nodes in which ancestors are applicable */		}		/* End Search of Node */			/* END FIRST PASS  - now, optimize from the bottom if necessary */	/* use outgroup to optimize basal node */	if (chmatrix[notu][ch]==undec && chmatrix[notu][ch]!=inap)	{		if (chmatrix[outgroup][ch]!=inap && chmatrix[outgroup][ch]!=unknown)			/*invmatrix[ch][notu]=*/chmatrix[notu][ch]=chmatrix[outgroup][ch];		}	/* continue only if there still are ambiguous ancestral conditions */	a=0;	/* count ambiguous ancestral values */	for (sp1=notu; sp1<notu+clades && a==0; ++sp1)	{		if (chmatrix[sp1][ch]==undec)	a=1;		}			/*** Use Successive Outgroups to Polarize Indeterminate Characters ***/	if (a==1)	{		for (node=0; node<clades; ++node)	{			clearivector(stpres,mxst+4,0);			stpres=cladestatespt(chmatrix, tree, stpres, node, notu, ch, mxst, mnst, inap, unknown, undec,1);			/* skip clades that do not have ambiguous descendants */			d=matchstate(stpres,mxst+3);			while (d!=1 && node<clades)	{				++node;				clearivector(stpres,mxst+4,0);				stpres=cladestatespt(chmatrix, tree, stpres, node, notu, ch, mxst, mnst, inap, unknown, undec,1);				d=matchstate(stpres,mxst+3);				}							if (node>=clades)	break;			anc = notu+node;			/* NOTE TO SELF:  MAKE THIS RECURSIVE!!!! */			/* once a clade with ambiguous descendants is found, break them down */			for (s=1; s<=tree[node][0]; ++s)	{				sp1=tree[node][s];				/* if an ambiguous node is found, then do something about it! */				if (chmatrix[sp1][ch]==undec)	{					clearivector(oldstpres,mxst+4,0);					b=found=0;					/* found will become 1 when ambiguous node is optimized */					while (found==0)	{						++b;						clearivector(stpres,mxst+4,0);						/* find states present within ambiguous node */						stpres=cladestatespt(chmatrix, tree, stpres, sp1-notu, notu, ch, mxst, mnst, inap, unknown, undec,b);												/* make sure that we are not repeating ourselves endlessly.... */						d=compareivector(stpres,oldstpres,mxst+4);						if (d==0)	break; /* d=0 means that we are repeating ourselves */												/* see if the ancestral state matches one of the ingroup states */						c=matchstate(stpres,ancmatrix[node][ch]);						/* if nodal state exists within clade, then assign it to ambiguous node */						if (c==1)	{							/*invmatrix[ch][sp1]=*/chmatrix[sp1][ch]=ancmatrix[node][ch];							found=1;							}	/* end case where outgroup condition exists within clade */						/* if c=-1, then the outgroup did not match anything in the ingroup */						else	{							/* find the most common state */							c=pluralstate(stpres,mxst);							/* if there is no plural state, then collapse any daughter nodes */							/* else if c is a state, then assign it to ambiguous node */							if (c>=mnst && c<=mxst)	{								/*invmatrix[ch][sp1]=*/chmatrix[sp1][ch]=c;								found=1;								}	/* end case where we find the most common state */							}	/* end case where the outgroup does not match any taxon */						oldstpres=equalivector(oldstpres,stpres,mxst+4);						}	/* end attempt to optimize without going further up the tree */					}	/* end routine for optimizing ambiguous node */				}	/* end search for ambiguous daughter taxa */			}	/* end search of node */		}	/* End base-up optimization */	}	/* End Main pass */	/* use outgroup to optimize basal node */for (ch=0; ch<nchars && a==0; ++ch)	{	if (chmatrix[notu][ch]==undec && chmatrix[notu][ch]!=inap)	{		if (chmatrix[outgroup][ch]!=inap && chmatrix[outgroup][ch]!=unknown)			/*invmatrix[ch][notu]=*/chmatrix[notu][ch]=chmatrix[outgroup][ch];		}	}/* make sure that there are minimum uncertain ancestral reconstructions - they should be there only if all descendants are unknown *//*a=0;for (sp1=notu; sp1<(notu+clades) && a==0; ++sp1)	for (ch=0; ch<nchars && a==0; ++ch)		if (chmatrix[sp1][ch]==undec)	a=1;	*/a=findinlmatrix(chmatrix, notu, nchars, undec, notu, notu+clades);/* if there are uncertainties, assign the value of the least apomorphic species to the node */if (a>0)	{	bl=ivector(notu+clades);	for (ch=0; ch<nchars; ++ch)	{		for (node=0; node<clades; ++node)	{			anc=node+notu;			/* skip nodes that are unresolved or irrelevant */			while (node<clades && (ancmatrix[node][ch]==undec || (ancmatrix[node][ch]==unknown || ancmatrix[node][ch]==inap)))	{				++node;				++anc;				}			if (node>=clades)	break;			/* see if descendant states matches ancestral state */			for (b=1; b<=tree[node][0]; ++b)	{				sp1=tree[node][b];				while (b<=tree[node][0] && (chmatrix[sp1][ch]==undec || (chmatrix[sp1][ch]==unknown || chmatrix[sp1][ch]==inap)))	{					++b;					if (b<=tree[node][0])	sp1=tree[node][b];					}				if (b>tree[node][0])	break;				if (ancmatrix[node][ch]!=chmatrix[sp1][ch])					++bl[sp1];				}			}		}	/* now, use descendants with shortest branches as ancestral models */	for (ch=0; ch<nchars; ++ch)	{		for (node=(clades-1); node>=0; --node)	{			anc=node+notu;			if (chmatrix[anc=node+notu][ch]==undec)	{				/* find the descendant with the longest branches */				sp1=tree[node][1];				for (b=2; b<=tree[node][0]; ++b)	{					sp2=tree[node][b];					while (b<=tree[node][0] && (chmatrix[sp2][ch]==undec || (chmatrix[sp2][ch]==unknown || chmatrix[sp2][ch]==inap)))	{						++b;						if (b<=tree[node][0])	sp2=tree[node][b];						}					if (b>tree[node][0])	break;										/* assign shortest branches state to node		*/					/* if tie, then assign from species over clade	*/					if (bl[sp2]<bl[sp1])								sp1=sp2;					if (bl[sp2]==bl[sp1] && (sp1>=notu && sp2<=notu))	sp1=sp2;					}				/*invmatrix[ch][anc]=*/ancmatrix[node][ch]=chmatrix[sp1][ch];				}			}		}	free_ivector(bl);	}if (depend>0)	{	free_ivector(dependents);	free_lmatrix(indmatrix,notu,depend);	free_lmatrix(iinvmatrix,depend,notu);	free_ivector(ictype);	free_ivector(instate);	free_imatrix(istatetypes,depend,2);	}free_ivector(stpres);free_ivector(oldstpres);//free_lmatrix(invmatrix,notu+clades,nchars);return ancmatrix;}/* Parsimony: finds the minimum number of steps needed for a tree to yield a matrix/*/* Requires: /*	chmatrix: taxon X character matrix of character states/*	tree: matrix giving tree, with first element giving # of branches and next X giving otu/htu # for branch/*	statetypes: character X states matrix giving states of each character/*	nstate: array giving the number of states for each character/*	ctype: array giving the type of each character (0: unordered; 1: ordered)/*	notu: number of taxa/*	nchars: number of characters/*	outgroup: taxon that is the outgroup/*	inap: code for inapplicable characters/*	unknown: code for unknown state/*/* Returns:/*	chmatrix: matrix modified to include ancestral conditions***************************************************************************************/long *inferancstateknown(long *chvector, long **tree, int mxst, int ctype, int clades, int notu, int inap, int unknown, int *ancestors, int **stpmtrx){int		a, b, c, d, s, nd, sp, sc, undec, fnd, aman, anc;//float	e, f, x, y, w, z;int		*cldtr, *cldanc;long	**cldstr, **cldsto;long	*ancstate;/*depend = inapplicables(chvector,notu,nchars,inap);*/cldanc=ivector(clades);ancstate=lvector(clades);undec=inap+unknown;clearlvector(ancstate,clades,undec);cldstr=lmatrix(clades,mxst+1);		/* richness of states within a clade (i.e., #taxa with that state	*/cldsto=lmatrix(clades,mxst+1);		/* order of states by richness within a clade						*/clearlmatrix(cldsto,clades,mxst+1,-1);cldtr=ivector(clades);				/* total richness within clade relevant for inferring condition		*/for (nd=clades-1; nd>=0; --nd)	{	if (nd==240)	{		a=1;		b=1;		c=1;		d=1;		}	aman=fnd=0;	for (a=1; a<=tree[nd][0]; ++a)	{		sp=tree[nd][a];		if (sp<notu && ancestors[sp]==1)	{			ancstate[nd]=chvector[sp];			fnd=1;						/* stick routine in here to look for descendant clades with unknown ancestral morphotypes	*/			/* if s matches one of those morphotypes, then make the clade's morphotype match that		*/			}		else if (sp>notu)	{			cldanc[sp-notu]=nd;			if (ancstate[sp-notu]==undec)	aman=1;			}		}	/* SORT cldsto AS YOU GO - IT WILL MAKE THINGS EASIER!!!! */	/* if none of the species are designated as ancestral, then look for commonality */	if (fnd==0)	{		for (a=1; a<=tree[nd][0]; ++a)	{			sp=tree[nd][a];			if (sp<notu)	{				s=chvector[sp];				/* disregard gaps & unknowns */				if (s>=0 && s<=mxst)	{					++cldstr[nd][s];		/* this array for each clade shows the states present within the clade */					/* if this is a new state, then put it in line */					if (cldstr[nd][s]==1)	{						cldsto[nd][cldtr[nd]]=s;						++cldtr[nd];						}					/* if we have 2+ taxa with state s, then sort as we go */					else if (cldtr[nd]>1)	{						/* c will be where s is in cldsto[nd] */						for (b=0; cldsto[nd][b]!=s; ++b)	c=b;						/* this simply pushes s up cldsto past any s with fewer species */						--c;						/* cldstr[nd][cldsto[nd][c]] give #species with state rank c */						while (c>0 && cldstr[nd][cldsto[nd][c]]<cldstr[nd][s])	{							cldsto[nd][c+1]=cldsto[nd][c];							--c;							}						cldsto[nd][c]=s;						}					}				}			/* routine for daughter clades */			else	{				cldanc[sc=sp-notu]=nd;				s=ancstate[sc];				/* if node is resolved, then just add its state */				if (s!=undec && (s!=inap && s!=unknown))	{					++cldstr[nd][s];					/* if 2+ finds, then sort it upwards */					if (cldstr[nd][s]>1 && cldtr[nd]>1)	{						d=-1;						/* find s's position in cldsto[nd] */						for (b=0; d==-1 && b<cldtr[nd]; ++b)	if (s==cldsto[nd][b])	d=b;						--d;						/* if the clade nd has 2+ taxa with state, move s up the rank order line */ 						while(d>=0 && cldstr[nd][cldsto[nd][d]]<cldstr[nd][s])	{							cldsto[nd][d+1]=cldsto[nd][d];							--d;							}						/* d will be one less than s's place in line */						cldsto[nd][d+1]=s;						}					/* if first find, then just add it to the end */					else if (cldstr[nd][s]==1)	{						cldsto[nd][cldtr[nd]]=s;						++cldtr[nd];						}					}				/* if not, then dump all of its states into this array */				else if (s==undec)	{					for (b=0; b<cldtr[sc]; ++b)	{						c=cldsto[sc][b];						cldstr[nd][c]+=cldstr[sc][c];						/* if this is a new state for the clade, make note of it */						if (cldstr[nd][c]==cldstr[sc][c])	{							if (cldstr[nd][c]==1)	cldsto[nd][cldtr[nd]]=c;							else	{								d=cldtr[nd]-1;								/* move all states with lower richness than c in clade nd below c */								while (d>=0 && cldstr[nd][cldsto[nd][d]]<cldstr[nd][c])	{									cldsto[nd][d+1]=cldsto[nd][d];									--d;									}								cldsto[nd][d+1]=c;								}							++cldtr[nd];	/* increment state richness within nd */							}	/* end loop for new character */						else	{							/* find where in cldsto[nd] c resides */							d=0;							while (cldsto[nd][d]!=c)	++d;							--d;							/* if the clade nd has 2+ taxa with state, move s up the rank order line */ 							while(d>=0 && cldstr[nd][cldsto[nd][d]]<cldstr[nd][c])	{								cldsto[nd][d+1]=cldsto[nd][d];								--d;								}							/* d will be one less than c's place in line */							cldsto[nd][d+1]=c;							}	/* end routine for simply increasing richness of state within nd */						}	/* end dump of descendant states into ancestral clade nd */ 					}	/* end routine for daughter clade with unknown condition */				}	/* routine for daughter clades */			}	/* end routine for nodes without a noted ancestor */		/* sort cldstr by cldsto to get the rank order richness of each morphotype within a clade *//*		cldsto=sort_declongrowbylongrow(cldsto,cldstr,nd,nd,mxst);	*//*		cldsto[nd]=sort_declongbylong(cldsto[nd],cldstr[nd],mxst);*/		s=cldsto[nd][0];		d=0;		for (a=0; a<cldtr[nd]; ++a)	d+=cldstr[nd][cldsto[nd][a]];				/* if one state represents the majority, the assign that state to the node */		if (cldtr[nd]==1 || cldstr[nd][s]>(d/2))	ancstate[nd]=s;		}	/* if we resolve this node and we there is an unresolved daughter clade (sc for scion), then do this */	if (ancstate[nd]!=undec && aman==1)	{		for (a=1; a<=tree[nd][0]; ++a)	{			sp=tree[nd][a];			/* check whether a descendant is a clade with an unknown ancestral condition */			if (sp>notu && ancstate[sp-notu]==undec)	{				sc=sp-notu;				/* scion clade */				for (b=0; b<cldtr[sc]; ++b)	{					if (ancstate[nd]==cldsto[sc][b])	{						ancstate[sc]=ancstate[nd];						b=cldtr[sc];		/* end loop now */						}					}	/* end search of conditions within clade sc */				}	/* end test for unresolved scion clade */			}	/*  */		}	/* end test for unresolved scion clades within a clade */		}	for (nd=0; nd<clades; ++nd)	{	/* find clades with unresolved ancestral states */	if (ancstate[nd]==undec)	{		anc=cldanc[nd];		/* if nd's ancestor has a known state, see if it matches one within */		fnd=0;		if ((c=ancstate[anc])!=undec)	{			for (a=0; a<cldtr[nd]; ++a)	{				if (ancstate[anc]==cldsto[nd][a])	{					ancstate[nd]=ancstate[anc];					a=cldtr[nd];					fnd=1;					}				}			}		/* if there is a state with a plurality, make it the ancestral node */ 		if (fnd==0 && cldstr[nd][cldsto[nd][0]]>cldstr[nd][cldsto[nd][1]])	{			ancstate[nd]=cldsto[nd][0];			fnd=0;			}//		else if 		if (fnd==0)	ancstate[nd]=ancstate[anc];		}	}free_lvector(ancstate);free_ivector(cldtr);free_lmatrix(cldsto,clades,mxst);free_lmatrix(cldstr,clades,mxst);return ancstate;}
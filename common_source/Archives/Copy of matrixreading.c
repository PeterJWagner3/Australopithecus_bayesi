#define matrixreading#include "matrixreading.h"#include "memory.h"#include <stdlib.h>#include <stdio.h>#include <time.h>#include <math.h>#include <string.h>/* Calculates the number of states for each character given a matrix./*/* Requires:/*	omat: taxon X character matrix of character states/*	notu: number of taxa/*	nchars: number of characters/*	UNKNOWN: code for unknown states/*	GAP: code for inapplicable characters/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *numberstates(long **omat, int notu, int nchars, int UNKNOWN, int GAP){int	a, b, ch, sp, st;int *nstates, *unst;nstates=ivector(nchars);/* find the maximum state number */st=0;for (ch=0; ch<nchars; ++ch)	{	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]>st && (omat[sp][ch]!=GAP && omat[sp][ch]!=UNKNOWN))			st=omat[sp][ch];		}	}unst=ivector(st+1);/* determine how species each state  has */for (ch=0; ch<nchars; ++ch)	{	st=0;	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]!=UNKNOWN && omat[sp][ch]!=GAP)	{			b=0;			for (a=0; a<st; ++a)	{				if (omat[sp][ch]==unst[a])	{					b=1;					a=st;					}				}			if (b==0)	{				unst[st]=omat[sp][ch];				++st;				}			}		}	nstates[ch]=st;	}free_ivector(unst);return nstates;}/* Calculates the number of species with derived conditions./*/* Requires:/*	omat: taxon X character matrix of character states/*	notu: number of taxa/*	nchars: number of characters/*	UNKNOWN: code for unknown states/*	GAP: code for inapplicable characters/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *autapomorphies(long **omat, int notu, int nchars, int UNKNOWN, int GAP){int	ch, st, sp, max, stmax, out;int *autap, *tallied;autap=ivector(nchars);max=0;for (ch=0; ch<nchars; ++ch)	{	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]>max && (omat[sp][ch]!=GAP && omat[sp][ch]!=UNKNOWN))			max=omat[sp][ch];		}	}tallied=ivector(max);/* determine how many states each species has */for (ch=0; ch<nchars; ++ch)	{	for (st=0; st<=max; ++st)		tallied[st]=0; 	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]!=UNKNOWN && omat[sp][ch]!=GAP)	{			st=omat[sp][ch];			++tallied[st];			}		}	autap[ch]=stmax=0;	for (st=0; st<=max; ++st)	{		if (tallied[st]>stmax)	{			out=st;			stmax=tallied[st];			}		}	for (st=0; st<=max; ++st)	if (st!=out)	autap[ch]=autap[ch]+tallied[st];	}free_ivector(tallied);return autap;}
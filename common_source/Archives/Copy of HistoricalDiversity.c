#define historicaldiversity#include "historicaldiversity.h"#define memory#include "memory.h"#define minmax#include "minmax.h"#define matrixanalysis#include "matrixanalysis.h"#define matrixchange#include "matrixchange.h"#define sort#include "sort.h"/* richnesstally - counts the number of taxa present in each interval/* Requires:/*		ranges - a notu x 2 matrix giving first and last appearances;/*			ranges[x][0] - first appearance of taxon x;/*			ranges[x][1] - last appearance of taxon x;/*		notu - number of taxa./*/* Returns:/*		S - an array giving the number of taxa per interval (S is standard notation for richness)*************************************************************************************/long *richnesstally(long **ranges, int notu){int	d, sp, onset, end;long *S;/*onset=minlarray(fa,notu);end=maxlarray(la,notu);	*/onset=minlmatrixcol(ranges,notu,0);end=maxlmatrixcol(ranges,notu,1);S=lvector(end+1);for (sp=0; sp<notu; ++sp)	{	for (d=ranges[sp][0]; d<=ranges[sp][1]; ++d)	{		++S[d];		}	}return S;}/* rangethru - counts the number of taxa before and after each interval*************************************************************************************/double *rangethru(long *fa, long *la, int notu){int	d, sp, onset, end;double *rt;onset=minlarray(fa,notu);end=maxlarray(la,notu);rt=dvector(end+1);for (sp=0; sp<notu; ++sp)	{	for (d=fa[sp]+1; d<la[sp]; ++d)	{		++rt[d];		}	}return rt;}/* extant - creates matrix showing when taxa were present*************************************************************************************/long **extant(long **ranges, int notu){int t, sp, onset, end, mxd;long *S, **present;onset=minlmatrixcol(ranges,notu,0);end=maxlmatrixcol(ranges,notu,1);S=richnesstally(ranges,notu);mxd=-1*MAXRAND;for (t=onset; t<=end; ++t)	if (S[t]>mxd)	mxd=S[t];present=lmatrix(end+1,mxd+1);for (sp=0; sp<notu; ++sp)	{	for (t=ranges[sp][0]; t<=ranges[sp][1]; ++t)	{		present[t][++present[t][0]]=sp;		}	}free_lvector(S);return present;}/* standing - create a vector of the extant taxa in an interval*************************************************************************************/long *standing(long **ranges, int notu, int S, int st){int t, sp;long *present;present=lvector(S);t=0;for (sp=0; sp<notu; ++sp)	{	if (ranges[sp][0]>=st && ranges[sp][1]<=st)	{		present[t]=sp;		++t;		}	}return present;}/* FreqRat - estimates sampling intensity based on singletons, doubletons, tripletons*************************************************************************************/double FreqRat(long *fa, long *la, int notu){int	sp, onset, end;double	*range;double	rat;onset=minlarray(fa,notu);end=maxlarray(la,notu);range=dvector(2+(end-onset));range[1]=range[2]=range[3]=0.0f;for (sp=0; sp<notu; ++sp)	{	range[1+(la[sp]-fa[sp])]=1+range[1+(la[sp]-fa[sp])];	}if (range[1]<1)	range[1]=1;if (range[3]<1 || ((end-onset)<2))	rat = 0;else	rat=(range[2]*range[2])/(range[1]*range[3]);free_dvector(range);return rat;}/* SameFAs - counts the number of different first appearances*************************************************************************************/int samefas(long *fa, int notu){int	sp;long	*f;int	shared=1;f=lvector(notu);equallvector(f,fa,notu);f=lshellsort_dec(f,notu);for (sp=1; sp<notu; ++sp)	{	if (f[sp]!=f[sp-1])	++shared;	}free_lvector(f);return shared;}/**************************************************************************************/double **gapprescalc(double *gaps, double *rthru, int stg){int	st;double p, q, r;double mS,lbS,ubS,l1S,u1S,mlR,lbR,ubR,l1R,u1R;double **results;results=dmatrix(stg,6);for (st=0; st<stg; ++st)	{	/* only bother if 10+ taxa range through */	while (rthru[st]<10 && st<stg)	++st;	if (st>=stg)	break;		p=rthru[st]-gaps[st];	q=gaps[st];	mlR=1-(gaps[st]/rthru[st]);	l1S=u1S=lbS=ubS=mS=(p*log(mlR)) + (q*log(1-mlR));		for (r=mlR; lbS>(mS-1) && r>0; r=r-0.005)	{		lbS=(p*log(r)) + (q*log(1-r));		if (l1S==mS && lbS<=(mS-1))	{			l1S=lbS;			l1R=r;			}		lbR=r+0.005;		}		for (r=mlR; ubS>(mS-1) && r<1; r=r+0.005)	{		ubS=(p*log(r)) + (q*log(1-r));		if (u1S==mS && ubS<=(mS-1))	{			u1S=ubS;			u1R=r;			}		ubR=r-0.005;		}	results[st][0]=mlR;	results[st][1]=mS;	results[st][2]=lbR;	results[st][3]=lbS;	results[st][4]=ubR;	results[st][5]=ubS;	}return results;}/**************************************************************************************/double *gapextinction(double *gaps, double *stgaps, double *rng, int stg, int notu){int		n, bins;double	sumrng=0, sumgps=0;double	m;double	/*rS, */eS;//, meS, zeS;double	mR;//, mM;double	*X;for (n=1; n<stg; ++n)	{	if (gaps[n]>0)	{		bins=n+1;		sumgps=sumgps+(n*gaps[n]);		}	}for (n=0; n<notu; ++n)	if (rng[n]>2)	sumrng=sumrng+(rng[n]-2);mR=1-(sumgps/sumrng);for (m=0.5; m<1; m=m+0.005)	{	eS=0;	for (n=1; n<bins; ++n)	{		eS=eS+gaps[n]*n*log(m*mR);		}	}return X;}/* expectedpropsampled - calculate the expected sampled proportion given sampling & extinction.Requires:	mu - extinction rate	r - preservation rateReturns:	1-miss = expected proportion.  *************************************************************************************/double completeness(double mu, double r){int 	i;double	invr, cas, rem=1, miss=0;invr=(1-r);		/* probability of not being sampled */cas=mu;			/* proportion lasting only one unit	*/rem=rem-cas;	/* proportion lasting two+ units 	*//* calculate the proportion that we will not sample */for (i=1; i<=100 && (invr*cas)>0.00000001; ++i)	{	miss=miss+(invr*cas);	/* lm*rem is proportion that live i units */	cas=mu*rem;				/* proportion going extinct at i+1 units given extinction lm */	rem=rem-cas;			/* proportion living ³i+1 units */	invr=invr*(1-r);		/* probability of not being sampled i+1 units given sampling r */	}return (1-miss);}/* expectedpropsampled - calculate the expected sampled proportion given sampling & extinction.Requires:	lm - extinction rate	r - preservation rateReturns:	1-miss = expected proportion.  *************************************************************************************/double expectedpropsampled(double lm, double r){int 	i;double	invr, cas, rem=1, miss=0;invr=(1-r);		/* probability of not being sampled */cas=lm;			/* proportion lasting only one unit	*/rem=rem-cas;	/* proportion lasting two+ units 	*//* calculate the proportion that we will not sample */for (i=1; i<=100 && (invr*cas)>0.00000001; ++i)	{	miss=miss+(invr*cas);	/* lm*rem is proportion that live i units */	cas=lm*rem;				/* proportion going extinct at i+1 units given extinction lm */	rem=rem-cas;			/* proportion living ³i+1 units */	invr=invr*(1-r);		/* probability of not being sampled i+1 units given sampling r */	}return (1-miss);}/* rarified - returns an array of length s subsampled from an array of length NRequires:	sample - an array of occurrences/specimens, with cell giving taxon number	N - number of occurrences/specimens	s - the subsample size;*************************************************************************************/unsigned long *rarified(unsigned long *sample, int N, int s){int	i;unsigned long *dummy;//unsigned long *sub;dummy=ulvector(N);equalulvector(dummy,sample,N);for (i=0; i<s; ++i)	{		}}/* chao2 - estimate richness based on Chao 1984: Scandinavian Journal of Statistics 11:265 - 270Requires:	abundance - an array of taxon abundances	ntaxa - the number of sampled taxaReturns:	S = estimated richness.  *************************************************************************************/int chao2(int *abundance, int ntaxa){int	i, q1=0, q2=0;int S;double x;for (i=0; i<ntaxa; ++i)	{	if (abundance[i]==1)		++q1;	else if (abundance[i]==2)	++q2;	}x=ntaxa+(((double) (q1*q1))/((double) (2*(q2+1)))) - (((double)(q1*q2))/((double) (2*(q2+1)*(q2+1))));S=x;if ((x-S)>0.5)	++S;return S;}/* chao2 biased corrected- estimate richness based on Chao & Lee 1992: Journal of the American Statistical Association 87:210 - 217Requires:	abundance - an array of taxon abundances	ntaxa - the number of sampled taxa	finds - number of localities / specimensReturns:	S = estimated richness.  *************************************************************************************/int chao2bc(int *abundance, int ntaxa, int finds){int	i, q1=0, q2=0;int S;double x;for (i=0; i<ntaxa; ++i)	{	if (abundance[i]==1)		++q1;	else if (abundance[i]==2)	++q2;	}//x=ntaxa+((double) (finds-1)/(((double) (finds-1))*((double)*(q1*(q1-1)))/(2*(q2+1))));S=x;if ((x-S)>0.5)	++S;return S;}/* first order jacknife estimate of richnessRequires:	abundance - an array of taxon abundances	ntaxa - the number of sampled taxaReturns:	S = estimated richness.  *************************************************************************************/int jack1(int *abundance, int ntaxa){int i, ss=0;int S;double m,n, q1=0.0f;ss=sumivector(abundance,ntaxa);for (i=0; i<ntaxa; ++i)	if (abundance[i]==1)	++q1;m=ss;n = ntaxa + q1*((m-1)/m);S=n;if ((n-S)>=0.5)	++S;return S;}/* second order jacknife estimate of richnessRequires:	abundance - an array of taxon abundances	ntaxa - the number of sampled taxaReturns:	S = estimated richness.  *************************************************************************************/int jack2(int *abundance, int ntaxa){int i, ss=0;int S;double m,n, q1=0.0f, q2=0.0f;ss=sumivector(abundance,ntaxa);for (i=0; i<ntaxa; ++i)	{	if (abundance[i]==1)		++q1;	else if (abundance[i]==2)	++q2;	}m=ss;n = ntaxa + (q1*(((2*m)-3)/m)) - q2*(((m-2)*(m-2))/(m*(m-1)));S=n;if ((n-S)>=0.5)	++S;return S;}/* third order jacknife estimate of richnessRequires:	abundance - an array of taxon abundances	ntaxa - the number of sampled taxaReturns:	S = estimated richness.  *************************************************************************************/int jack3(int *abundance, int ntaxa){int i, ss=0;int S;double m,n, q1=0.0f, q2=0.0f, q3=0.0f;ss=sumivector(abundance,ntaxa);for (i=0; i<ntaxa; ++i)	{	if (abundance[i]==1)		++q1;	else if (abundance[i]==2)	++q2;	else if (abundance[i]==3)	++q3;	}m=ss;n = ntaxa + (q1*(((3*m)-6)/m)) - q2*((3*(m*m)-(15*m)+19)/(m*(m-1))) + q3*(pow(m-3,3)/(m*(m-1)*(m-2)));S=n;if ((n-S)>=0.5)	++S;return S;}/* fourth order jacknife estimate of richnessRequires:	abundance - an array of taxon abundances	ntaxa - the number of sampled taxaReturns:	S = estimated richness.  *************************************************************************************/int jack4(int *abundance, int ntaxa){int i, ss=0;int S;double m,n, q1=0.0f, q2=0.0f, q3=0.0f, q4=0.0f;ss=sumivector(abundance,ntaxa);for (i=0; i<ntaxa; ++i)	{	if (abundance[i]==1)		++q1;	else if (abundance[i]==2)	++q2;	else if (abundance[i]==3)	++q3;	else if (abundance[i]==3)	++q4;	}m=ss;n = ntaxa + (q1*(((4*m)-10)/m)) - q2*((6*(m*m)-(36*m)+55)/(m*(m-1))) + q3*(((4*pow(m,3))-(42*pow(m,2))+(148*m)-175))/(m*(m-1)*(m-2)) - q4*pow((m-4),4)/(m*(m-1)*(m-2)*(m-3));S=n;if ((n-S)>=0.5)	++S;return S;}/* fourth order jacknife estimate of richnessRequires:	abundance - an array of taxon abundances	ntaxa - the number of sampled taxaReturns:	S = estimated richness.  *************************************************************************************/int jack5(int *abundance, int ntaxa){int i, ss=0;int S;double m,n, q1=0.0f, q2=0.0f, q3=0.0f, q4=0.0f, q5=0.0f;ss=sumivector(abundance,ntaxa);for (i=0; i<ntaxa; ++i)	{	if (abundance[i]==1)		++q1;	else if (abundance[i]==2)	++q2;	else if (abundance[i]==3)	++q3;	else if (abundance[i]==3)	++q4;	else if (abundance[i]==3)	++q5;	}m=ss;n = ntaxa + (q1*(((5*m)-15)/m)) - q2*((10*(m*m)-(70*m)+125)/(m*(m-1)))+ q3*(((10*pow(m,3))-(120*pow(m,2))+(485*m)-660))/(m*(m-1)*(m-2))- q4*pow((m-4),4)/(m*(m-1)*(m-2)*(m-3))+ q5*pow((m-5),5)/(m*(m-1)*(m-2)*(m-3)*(m-4));S=n;if ((n-S)>=0.5)	++S;return S;}
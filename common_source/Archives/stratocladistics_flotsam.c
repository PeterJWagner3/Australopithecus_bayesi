		/* pair cc can be younger than only one other pair; if younger than two more, then it is incompatible	*/		b=0;		if (keyst2!=-1)	{			for (a=0; a<p && b<2; ++a)				/* tally state pairs with first appearances older than our "swing" pair	*/				if (a!=cc && prfl[a][0]<prfl[cc][0])		++b;			if (b>1)	strcmp[0]=strcmp[1]=0;	/* gap in character state tree	*/			else	{				/* tally state pairs with first appearances after the last appearance of our "swing" pair	*/				b=0;				for (a=0; a<p && b<1; ++a)	{					if (a!=cc && prfl[a][0]>(1+prfl[cc][1]))	{						/* make sure that there is not another state that does not bridge the gap	*/						for (d=0; d<p; ++d)	{							b=1;							/* the next condition will be met only if there are three states paired with keyst1	*/							if (d!=a && pairs[d][0]==keyst1 && pairs[d][1]!=keyst2)	{								/* if an intermediate state bridges the gap, then make it compatible again	*/								if (prfl[d][0]<=(prfl[cc][1]+1) && (prfl[d][1]+1)>=prfl[a][0])	b=0;								}	/* end look for filling of gap between first and last appearances	*/							}	/* end look for filling of gap between first and last appearances	*/						}	/* end case where there is a gap in ranges	*/					}				if (b>0)	strcmp[0]=0;		/* gap in character state tree	*/				}			}		/* case where two characters do not have a linking state pair: e.g., 00, 10, 21, 31	*/		else	{			/* tally state pairs with first appearances after the last appearance of our "swing" pair	*/			b=0;			for (a=0; a<(p-1) && b<1; ++a)	{				/* make sure that there is not another state that does not bridge the gap	*/				for (d=a+1; d<p; ++d)	{					b=1;					/* the next condition will be met only if there are three states paired with keyst1	*/					if (d!=a && pairs[d][0]==keyst1 && pairs[d][1]!=keyst2)	{						/* if an intermediate state bridges the gap, then make it compatible again	*/						if (prfl[d][0]<=(prfl[a][1]+1) && (prfl[d][1]+1)>=prfl[a][0])	b=0;						}	/* end look for filling of gap between first and last appearances	*/					}	/* end look for filling of gap between first and last appearances	*/				}	/* end case where there is a gap in ranges	*/			if (b>0)	strcmp[0]=0;		/* gap in character state tree	*/			}		++st1;		}	/* case for multistates: but I might not need this anymore	*/	if (strcmp[0]==1 && (states[ch1]>2 && states[ch2]>2))	{		st2=0;		for (c=0; c<sc2; ++c)	{			clearlmatrix(pairs,states[ch1]+states[ch2],2,-1);			while (combos[0][st2]<2)	++st2;			if (st2>=states[ch2])		break;			keyst2=st2;			keyst1=-1;			/* now, find the other matches for character 1	*/			p=0;			for (sp=0; sp<notu; ++sp)	{				if (matrix[sp][ch2]==keyst2 && (matrix[sp][ch1]!=UNKNOWN && matrix[sp][ch1]!=INAP))	{					b=0;					/* make sure that this pair has not been found yet	*/					for (d=0; d<=p && b==0; ++d)	if (matrix[sp][ch1]==pairs[d][0])	b=1;						if (b==0)	{						pairs[p][0]=matrix[sp][ch1];						pairs[p][1]=keyst2;						prfl[p][0]=pairrng[matrix[sp][ch1]*states[ch2]+keyst2][0];						prfl[p][1]=pairrng[matrix[sp][ch1]*states[ch2]+keyst2][1];						++p;						}					}	/* end search for additional 1st char state pairs	*/				}			for (st1=0; st1<states[ch1] && keyst1==-1; ++st1)	{				if (combos[1][st1]>1)	{					for (sp=0; sp<notu; ++sp)	{						if (matrix[sp][ch1]==keyst1 && (matrix[sp][ch2]!=UNKNOWN && matrix[sp][ch2]!=INAP))	{							b=0;							/* make sure that we don't add pairs twice	*/ 							for (d=0; d<p && b==0; ++d)								if (matrix[sp][ch2]==pairs[d][1])	b=1;							if (b==0)	{								pairs[p][0]=keyst1;								pairs[p][1]=matrix[sp][ch2];								prfl[p][0]=pairrng[(keyst1*states[ch2])+matrix[sp][ch2]][0];								prfl[p][1]=pairrng[(keyst1*states[ch2])+matrix[sp][ch2]][1];								++p;								}	/* end pair	*/							}	/* end case where we've found part of the pair	*/						}	/*	end search for pairs	*/					/* find the "swing" pair: for 00, 10, 11, this would be 10: it must be either intermediate (00->10->11) or ancestral (00<-10->11)	*/					/*		thus, only one state pair can be older																						*/					for (cc=0; cc<p && (pairs[cc][0]!=st1 || pairs[cc][1]!=keyst2); cc=cc)	++cc;					if (cc<p)	keyst1=st1;					}	/* end search for key state	*/				}						/* pair cc can be younger than only one other pair; if younger than two more, then it is incompatible	*/			b=0;			if (keyst1!=-1)	{				for (a=0; a<p && b<2; ++a)	{					/* tally state pairs with first appearances older than our "swing" pair	*/				/* tally state pairs with first appearances older than our "swing" pair	*/					if (a!=cc && prfl[a][0]<prfl[cc][0])		++b;					}				if (b>1)	strcmp[0]=strcmp[1]=0;	/* gap in character state tree	*/				else	{					/* tally look for gaps between characters that must be linked	*/					b=0;					for (a=0; a<p-1 && b<1; ++a)	{						if (a!=cc && prfl[a][0]>(1+prfl[cc][1]))	{							/* make sure that there is not another state that does not bridge the gap	*/							for (d=a+1; d<p; ++d)	{								b=1;								/* the next condition will be met only if there are three states paired with keyst2	*/								if (d!=a && pairs[d][0]==keyst2 && pairs[d][1]!=keyst1)	{									/* if an intermediate state bridges the gap, then make it compatible again	*/									if (prfl[d][0]<=(prfl[cc][1]+1) && (prfl[d][1]+1)>=prfl[a][0])	b=0;									}								}							}						}					if (b>0)	strcmp[0]=0;		/* gap in character state tree	*/					}				}	/* only bother if there is a swing pair	*/			else	{				/* tally look for gaps between characters that must be linked	*/				b=0;				for (a=0; a<p && b<1; ++a)	{					/* make sure that there is not another state that does not bridge the gap	*/					for (d=0; d<p; ++d)	{						b=1;						/* the next condition will be met only if there are three states paired with keyst2	*/						if (d!=a && pairs[d][0]==keyst2 && pairs[d][1]!=keyst1)	{							/* if an intermediate state bridges the gap, then make it compatible again	*/							if (prfl[d][0]<=(prfl[a][1]+1) && (prfl[d][1]+1)>=prfl[a][0])	b=0;							}						}					}				if (b>0)	strcmp[0]=0;		/* gap in character state tree	*/				}			}
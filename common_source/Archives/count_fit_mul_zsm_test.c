double *count_fit_mul_zsm_test(int *empdist, int ntaxa, int nspec){int i=0, j=0;					/* LOOP VARIABLE															*/int	 mt, tt, mtb;				/* loop busters	*/int theospc=5*nspec;			/* theoretical number of total specimens									*/double m=0.0f;					/* m for loop																*/double mi=0.25f;				/* m increment																*/double imi=0.25f;				/* initial m increment each loop											*/double lmi[2];					/* previous m increment														*/double min=0.75f;				/* initial m to use in each search (begins as ntaxa)						*/long double mmx=0.999999f;		/* maximum m to consider													*/long double mmn=0.000001f;		/* minimum m																*/double lti[2];					/* last two theta incrementers												*/double iti;						/* initial slope increment at each m										*/double theta=0.000f;			/* LOOP theta 																*/double tin=10.000f;				/* initial theta															*/double tmin=0.01f;				/* min theta slope															*/double ti=10.000f;				/* how much to increment theta in each loop									*/double mti=0.0001f;				/* minimum theta increment													*/double ts[11];					/* previous modal decay log likelihoods (cell number = num previous).		*/double ms[3];					/* previous m log likelihoods (cell number = num previous).					*/double *btp;					/* BEST decay for hypothesized theta at given S - return array format 		*/double bmp[2];					/* BEST m parameters - return array											*/double pbms;					/* previous best support for m												*/double pbts=-1*DBL_MAX;			/* previous best support for theta											*/double *expind;				/* expected number of species with 0Émax individuals						*/double *expsamp;			/* expected number of species with 0Émax finds								*/double *obsrvd;				/* observed number of species with 0Émax finds								*/double x,y,z;					/* dummy															*/FILE	*fopen();	FILE 	*outfile;btp=dvector(3);for (i=0; i<3; i++) btp[i]=-1.0*DBL_MAX;for (i=0; i<3; ++i)	ts[i]= -1.0*DBL_MAX;/* we need arrays giving both the number of taxa with x finds and all x finds with 1+ species */obsrvd=idhistogram(empdist,ntaxa);tin=chao2(empdist,ntaxa);tin*=0.3;ti=iti=tin/4;mti=0.0001*iti;lti[0]=tin;lti[1]=0.0f;	outfile=fopen("zerosumtest.txt","w");fprintf(outfile,"theta\tÆtheta\tm\tÆm\tlnL\ttime\n");/* adjust true m until that fails to improve likelihood	*/mtb=tt=0;for (theta = tin; ((theta>=tmin && fabs(ti)>mti) || pbts == -1*DBL_MAX); theta += ti) {		/*Debugging line */	if (theta<=tmin) printf("\nDANGER: theta=%f, m=%f ",theta, m);	/* increment starting at 0.1 since we are almost never going to find slopes of 2+	*/	for (i=0; i<3; i++) ms[i] = -1.0*DBL_MAX;	bmp[0]=bmp[1]= -1.0*DBL_MAX;	lmi[0]=lmi[1]=0.0f;	mi=imi;		pbms=-1*DBL_MAX;	min=0.9999999f;	mi=imi=-2;	mt=0;	/* find the best theta for this m */	for (m=mmx; ((mi!=0 && (m>=mmn && m<=mmx))  && (pbms==-1*DBL_MAX || bmp[0]>pbms +SUPINC)); m+=mi)	{		obsrvd[0]=0;		expind=zerosum(theta,m,theospc);				x=sumdvector(expind,theospc);		if (x>=ntaxa)	{			for (j=1; expind[j]>0 && j<theospc; j=j)	++j;			expsamp=expfindsfromexpindprop(expind,j,nspec);			free_dvector(expind);			ms[0]=lnmultinomsuff(obsrvd,expsamp,empdist[0]+1);				free_dvector(expsamp);			}		else	{			ms[0]=-1*DBL_MAX;			free_dvector(expind);			}		i=time((time_t *)NULL);		fprintf(outfile,"%7.6f\t%7.6f\t%7.6f\t%7.6f\t%7.6f\t%d\n",theta,ti,m,mi,ms[0],i);		fclose(outfile);		outfile=fopen("zerosumtest.txt","a");		/* if this m is better than the last */		if (ms[0] >= bmp[0] && ms[0]>-1*DBL_MAX) {							/* IF BETTER THAN BEST FIT */			pbms = bmp[0];								/* save last best ssq for m */			bmp[0]=ms[0];								/* STORE FIT */			bmp[1]=m;									/* STORE SLOPE */						/* while we are getting better on the initial increment, just ride with it			*/			if (fabs(mi)==fabs(imi))	{				lmi[1]=lmi[0];				lmi[0]=mi;				if (mi==imi)						mi=(mmn-mmx)/2;				else if (m+mi<mmn || m+mi>mmx)		mi/=-2;				}			/* if we have a later improvement, wander halfway back to the last improvement 	*/			/* (remember, we always start at the most likely slope up to that point			*/			else	{				lmi[1]=lmi[0];				lmi[0]=mi;				mi/=2;				if (m+mi<mmn || m+mi>mmx)				mi/=-1;				}			}		/* optimal m is overshot */		else {			m=bmp[1];				/* step back to best m	 */					/* if we start off going downhill, then go the other way */						if (mi==imi)						mi*=-1;			else if (fabs(mi)==fabs(lmi[0]))	{				lmi[1]=lmi[0];				lmi[0]=mi;				mi/=2;				if (m+mi>mmx || m+mi<mmn)	{					if (fabs(mi)==fabs(lmi[0]))	mi/=-2;					else						mi/=-1;					}				}			else if (mi==lmi[0]/2)	{				lmi[1]=lmi[0];				lmi[0]=mi;				mi*=-1;				if (m+mi>mmx || m+mi<mmn)		mi/=-2;				}			else if (mi==imi && m==min)	{				lmi[1]=lmi[0];				lmi[0]=mi;				mi*=-1;				if (m+mi>mmx || m+mi<mmn)		mi/=-2;				}			/* if this increment is opposite of the last, then cut it in half */			else if (fabs(mi)==fabs(lmi[0]))	{				lmi[1]=lmi[0];				lmi[0]=mi;				/* go towards the one with the higher likelihood */				if (ms[1]>ms[0])				mi/=-2;				else							mi/=2;				if (m+mi>mmx || m+mi<mmn)		mi/=-1;				}			/* if this increment is less then the last, then */			else if (fabs(mi)<fabs(lmi[0]))	{				lmi[1]=lmi[0];				lmi[0]=mi;				mi*=-1;				if (m+mi>mmx || m+mi<mmn)		mi/=-2;				}			}				if ((ms[0]>=ms[1] && ms[0]<(ms[1]+SUPINC)) && (ms[1]>=ms[2] && ms[1]<(ms[2]+SUPINC)))				mi=0;				/* if we basically are running into improvement up to the min/max, then just take the min/max	*///		else if ((bmp[1]==mmx || bmp[1]==mmn) && (bmp[0]<(ms[0]+0.1) && (bmp[0]<(ms[1]+0.1) && bmp[0]<(ms[2]+0.1))))		else if ((bmp[1]==mmx || bmp[1]==mmn) && fabs(mi)<fabs(imi)/32)			mi=0;					/* if it is trying to get past the maximum, then kill it	*/		else if ((bmp[1]==mmx && (bmp[0]<btp[0] && btp[1]>mmx)) && (bmp[0]>ms[0] && (bmp[0]>ms[1] && bmp[0]>ms[2])))			mi=0;		/* if log likelihood is hopelessly low for this theta, then skip to the next	*/		else if (bmp[0]<1.25*btp[0] && (mt>=mtb && mtb>5))			mi=0;				ms[2] = ms[1];		ms[1] = ms[0];		++mt;		}	/* end search for m */	ts[0]=bmp[0];	if (ts[0] >= btp[0] && ts[0]>-1*DBL_MAX) {							/* IF BETTER THAN BEST FIT */		pbts = btp[0];								/* save last best ssq for theta */		btp[0] = ts[0];								/* STORE FIT */		btp[1] = bmp[1];							/* STORE m */		btp[2] = theta;								/* STORE m */				mtb=mt;										/* number of tries to find the best m	*/		/* while we are getting better on the initial increment, just ride with it			*/		if (fabs(ti)==fabs(iti))	{			lti[1]=lti[0];			lti[0]=ti;			if (theta+ti<tmin)				ti/=-2;						/* to avoid local optima, at least on intial search */			else if (btp[0] <= (pbts + SUPINC))	{				/* return to prior theta	*/				if (theta==(tin+iti))	{					theta=tin;					ti*=-1;					pbts-=1.0f;					}				else if (theta==(tin-iti))	{					theta=tin;					ti/=2;					pbts-=1.0f;					}				}	/* end case where we had trivial improvement within one step of initial theta */			}		/* if we have a later improvement, wander halfway back to the last improvement 	*/		/* (remember, we always start at the most likely slope up to that point			*/		else	{			lti[1]=lti[0];			lti[0]=ti;			ti/=2;			if (theta+ti<tmin)				ti/=-1;			}		}	/* end case where likelihood has improved	*/					/* If likelihood has not increased, then reset and change the increment  value	*/	else	{		/* if we went from x -> -x, then we want to cut the increment in half */		lti[1]=lti[0];		lti[0]=ti;		if (fabs(ti)==fabs(iti))	{			/* if the first increment does not help, then reverse direction	*/			if (theta==tin+iti)				ti*=-1;			/* if an increment after the first stops helping, then go half way	*/			else							ti/=2;			if (theta+ti<tmin)				ti/=-2;			}		else	{			if (fabs(lti[0])==fabs(lti[1]))	ti/=2;			else							ti*=-1;			if (theta+ti<tmin)				ti/=-2;			}/*			if (ti==-1*lti[0] || ti==iti)	{			if (ti==iti)	{				/* determine whether ts[0] or ts[2] is the second best - move towards that	/				if (ts[0]>ts[2])	ti/=2;				else				ti/=-2;				}			else	{				/* determine whether ts[0] or ts[1] is the second best - move towards that	/				if (ts[0]>ts[1])	ti/=2;				else				ti/=-2;				}			}		/* if we just divided in half, then we want to reverse the increment /		else if (ti==-1*iti || (2*ti==lti[0] || -2*ti==lti[0]))	{			/* if theta+x/2 got closer than theta-x, back up and go to theta+x/4	/			if (fabs(ti)==fabs(lti[0]))	ti/=2;			else						ti*=-1;			} */		theta=btp[2];		}			/* start the next m at the best m so far *//*	if (btp[1]>0.5)	imi=(mmx-btp[1])/2;	*//*	else			imi=(btp[1]-mmn)/2;	*//*	min=btp[1];		*/	/* make sure that imi is not too small */	if (fabs(imi)<0.0001)	{		if (imi<0)						imi=-0.0001;		else							imi=0.0001;		}	/* make sure that imi does not take m out of bounds */	if (min+imi>mmx || min+imi<mmn)		imi*=-1;	/* make sure that ti does not take theta below 1.0 */	if (theta+ti<= tmin)	{		if (fabs(lti[0])==fabs(ti))			ti/=-2;		else								ti/=-1;		}	if (ts[0]>-1*DBL_MAX)	{		for (i=10; i>0; --i)	 ts[i] = ts[i-1];				/* Store last 2 attempts to identify	*/		++tt;		}	if (tt>5)	{		y=maxdarray(ts,6);		z=mindarray(ts,6);		if (y-z<0.1)	ti=0.0f;		}		if (btp[0] < (pbts + SUPINC) && fabs(ti)<((fabs(iti)/20)))	ti=0.0f;	}	/* end search for theta */free_dvector(obsrvd);return btp;}
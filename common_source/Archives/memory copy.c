#define memory#include "memory.h"#include <stdlib.h>#include <stdio.h>#include <time.h>#include <math.h>#include <string.h>/* Integer allocations/* written by M. Kosnik 2000.02.10/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//* vector/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *ivector(int length){int i;    int *v = (int*)malloc(length * sizeof (int));if (!v) {	printf("allocation error in ivector");	}/* initialize to 0 */for (i=0 ; i<length ; i++) {	v[i]=0;	}/* return pointer to array */return v;		}void free_ivector(int *v){	free((void *) v);	return;		}/* matrix/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int **imatrix(int nrows, int ncolumns){int i, j;int **m;/* allocate pointers to rows */m = (int **)malloc(nrows * sizeof (int*));/* m = new int*[nrows]						*/if (!m) printf("allocation error in imatrix - primary");/* allocate rows and set pointers to them */for (i=0 ; i<nrows ; i++) {	m[i] = (int *) malloc (ncolumns * sizeof (int));	/* m[i] = new int[ncolumns];				*/	if (!m[i]) {		printf("allocation error in imatrix - row %d", i);		exit(0);		}	}for (i=0; i<nrows; ++i)	for (j=0; j<ncolumns; ++j)		m[i][j]=0;/* return pointer to array of pointers to rows */return m;		}void free_imatrix(int **m, int nrows, int ncolumns){	int i;		for (i=0 ; i<nrows ; i++)		free((void *) m[i]);	free((void *) m);		return;}/* double allocations/* written by M. Kosnik 2000.02.10/* modfied by P. Wagner 2002.01.24/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//* vector/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */double *dvector(int length){	int i;	double *v = (double*)malloc(length * sizeof (double));		if (!v) {		printf("allocation error in dvector");		}		/* initialize to 0 */	for (i=0 ; i<length ; i++) {		v[i]=0.0f;	}		/* return pointer to array */	return v;		}void free_dvector(double *v){	free((void *) v);	return;		}/* matrix/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */double **dmatrix(int nrows, int ncolumns){int i, j;double **m;/* allocate pointers to rows */m = (double **)malloc(nrows * sizeof (double*));if (!m) printf("allocation error in dmatrix - primary");		/* allocate rows and set pointers to them */for (i=0 ; i<nrows ; i++) {	m[i] = (double *) malloc (ncolumns * sizeof (double));	if (!m[i]) {		printf("allocation error in dmatrix - row %d", i);		exit(0);		}	}		/* set all cells to 0.0 */	for (i=0; i<nrows; ++i)		for (j=0; j<ncolumns; ++j)			m[i][j]=0.f;	/* return pointer to array of pointers to rows */	return m;		}void free_dmatrix(double **m, int nrows, int ncolumns){	int i;		for (i=0 ; i<nrows ; i++)		free((void *) m[i]);	free((void *) m);		return;}/* Long allocations/* Modified from M. Kosnik 2001.01.14/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//* vector/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */long *lvector(long length){	long i;		long *v = (long*)malloc(length * sizeof (long));	if (!v) printf("allocation error in lvector");		/* initialize to 0 */	for (i=0 ; i<length ; i++) {		v[i]=0;	}		/* return pointer to array */	return v;}void free_lvector(long *v){	free((void *) v);	return;		}/* matrix/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */long **lmatrix(int nrows, int ncolumns){int i,j;long **m;/* allocate pointers to rows */m = (long **)malloc(nrows * sizeof (long*));if (!m) printf("allocation error in lmatrix - primary");		/* allocate rows and set pointers to them */for (i=0 ; i<nrows ; i++) {	m[i] = (long *) malloc (ncolumns * sizeof (long));	if (!m[i]) {		printf("allocation error in lmatrix - row %d", i);		exit(0);		}	}for (i=0; i<nrows; ++i)	for (j=0; j<ncolumns; ++j)	m[i][j]=0;	/* return pointer to array of pointers to rows */return m;		}void free_lmatrix(long **m, int nrows, int ncolumns){	int i;		for (i=0 ; i<nrows ; i++)		free((void *) m[i]);	free((void *) m);		return;}/* Unsigned long allocations/* written by M. Kosnik 2000.02.10/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//* vector/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long *ulvector(long length){	long i;		unsigned long *v = (unsigned long*)malloc(length * sizeof (unsigned long));	if (!v) printf("allocation error in ulvector");		/* initialize to 0 */	for (i=0 ; i<length ; i++) {		v[i]=0;	}		/* return pointer to array */	return v;}void free_ulvector(unsigned long *v){	free((void *) v);	return;		}/* matrix/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long **ulmatrix(int nrows, int ncolumns){int i,j;unsigned long **m;/* allocate pointers to rows */m = (unsigned long **)malloc(nrows * sizeof (unsigned long*));if (!m) printf("allocation error in ulmatrix - primary");/* allocate rows and set pointers to them */for (i=0 ; i<nrows ; i++) {	m[i] = (unsigned long *) malloc (ncolumns * sizeof (unsigned long));	if (!m[i]) {		printf("allocation error in ulmatrix - row %d", i);		exit(0);		}	}	/* return pointer to array of pointers to rows */	for (i=0; i<nrows; ++i)	for (j=0; j<ncolumns; ++j)	m[i][j]=0;	return m;		}void free_ulmatrix(unsigned long **m, int nrows, int ncolumns){	int i;		for (i=0 ; i<nrows ; i++)		free((void *) m[i]);	free((void *) m);		return;}/* float allocations/* written by M. Kosnik 2000.02.10/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//* vector/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */float *fvector(int length){	int i;                float *v = (float*)malloc(length * sizeof (float));	if (!v) printf("allocation error in fvector");		/* initialize to 0 */	for (i=0 ; i<length ; i++) {		v[i]=0.f;	}		/* return pointer to array */	return v;		}void free_fvector(float *v){	free((void *) v);	return;		}/* matrix/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */float **fmatrix(int nrows, int ncolumns){	int i,j;	float **m;	/* allocate pointers to rows */	m = (float**)malloc(nrows * sizeof (float*));	if (!m) printf("allocation error in fmatrix - primary");		/* allocate rows and set pointers to them */	for (i=0 ; i<nrows ; i++) {		m[i] = (float *) malloc (ncolumns * sizeof (float));		if (!m[i]) printf("allocation error in fmatrix - row %d", i);	}	/* initialize to 0 */	for (i=0 ; i<nrows ; i++) {		for (j=0 ; j<ncolumns ; j++) {			m[i][j]=0.f;		}	}	/* return pointer to array of pointers to rows */	return m;		}void free_fmatrix(float **m, int nrows, int ncolumns){	int i;		for (i=0 ; i<nrows ; i++)		free((void *) m[i]);	free((void *) m);		return;}char *cvector(int length){	int i;            char *v = (char *)malloc(length*sizeof(char));	if (!v) printf("allocation error in cvector");		/* initialize to 0 */	for (i=0 ; i<length ; i++) {		v[i]=' ';	}		/* return pointer to array */	return v;		}void free_cvector(char *v){	free((void *) v);	return;		}/* matrix/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */char **cmatrix(int nrows, int ncolumns){	int i,j;	char **m;	/* allocate pointers to rows */	m = (char**)malloc(nrows * sizeof (char*));	if (!m) printf("allocation error in cmatrix - primary");		/* allocate rows and set pointers to them */	for (i=0 ; i<nrows ; i++) {		m[i] = (char *) malloc (ncolumns * sizeof (char));		if (!m[i]) printf("allocation error in cmatrix - row %d", i);	}	/* initialize to 0 */	for (i=0 ; i<nrows ; i++) {		for (j=0 ; j<ncolumns ; j++) {			m[i][j]=' ';		}	}	/* return pointer to array of pointers to rows */	return m;		}void free_cmatrix(char **m, int nrows, int ncolumns){	int i;		for (i=0 ; i<nrows ; i++)		free((void *) m[i]);	free((void *) m);		return;}/* vector/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *ibigvector(int length){int i;    int *v = (int*)malloc(length * sizeof (unsigned long));if (!v) printf("allocation error in ibigvector");/* initialize to 0 */for (i=0 ; i<length ; i++) {	v[i]=0;	}/* return pointer to array */return v;		}/* vector/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */double *dbigvector(int length){int i;double *v = (double*)malloc(length * sizeof (unsigned long));if (!v) printf("allocation error in dbigvector");/* initialize to 0 */for (i=0 ; i<length ; i++) {	v[i]=0.0f;	}/* return pointer to array */return v;		}/* fcube: creates a 3D matrix of float/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */float ***fcube(int length, int width, int height){int i, j, k;float ***f_cube = new float ** [length];if (!f_cube) cout << "allocation error in f_cube - length";/* allocate rows and set pointers to them */for (i=0 ; i<length ; i++) {	f_cube[i] = new float * [width];	if (!f_cube[i]) cout << "allocation error in f_cube - width " << i;	}for (i=0 ; i<length ; i++) {	for (j=0 ; j<width ; j++) {		f_cube[i][j]=new float [height];		if (!f_cube[i][j]) cout << "allocation error in f_cube - height " << i << " x  " << j;		}	}for (i=0 ; i<length ; i++) {	for (j=0 ; j<width ; j++) {		for (k=0; k<height ; k++) f_cube[i][j][k]==0.0f;		}	}return f_cube;}/* dcube: creates a 3D matrix of double/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */double ***dcube(int length, int width, int height){int i, j, k;double ***d_cube = new float ** [length];if (!d_cube) cout << "allocation error in d_cube - length";/* allocate rows and set pointers to them */for (i=0 ; i<length ; i++) {	d_cube[i] = new double * [width];	if (!d_cube[i]) cout << "allocation error in d_cube - width " << i;	}for (i=0 ; i<length ; i++) {	for (j=0 ; j<width ; j++) {		d_cube[i][j]=new double [height];		if (!d_cube[i][j]) cout << "allocation error in d_cube - height " << i << " x  " << j;		}	}for (i=0 ; i<length ; i++) {	for (j=0 ; j<width ; j++) {		for (k=0; k<height ; k++) d_cube[i][j][k]=0.0f;		}	}return d_cube;}/* icube: creates a 3D matrix of integers/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int ***icube(int length, int width, int height){int i, j, k;int ***i_cube = new int ** [length];if (!i_cube) cout << "allocation error in i_cube - length";/* allocate rows and set pointers to them */for (i=0 ; i<length ; i++) {	i_cube[i] = new int * [width];	if (!i_cube[i]) cout << "allocation error in i_cube - width " << i;	}for (i=0 ; i<length ; i++) {	for (j=0 ; j<width ; j++) {		i_cube[i][j]=new int [height];		if (!i_cube[i][j]) cout << "allocation error in i_cube - height " << i << " x  " << j;		}	}for (i=0 ; i<length ; i++) {	for (j=0 ; j<width ; j++) {		for (k=0; k<height ; k++) i_cube[i][j][k]=0;		}	}return i_cube;}/* lcube: creates a 3D matrix of long/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */long ***lcube(int length, int width, int height){int i, j, k;long ***l_cube = new long ** [length];if (!l_cube) cout << "allocation error in l_cube - length";/* allocate rows and set pointers to them */for (i=0 ; i<length ; i++) {	l_cube[i] = new long * [width];	if (!l_cube[i]) cout << "allocation error in l_cube - width " << i;	}for (i=0 ; i<length ; i++) {	for (j=0 ; j<width ; j++) {		l_cube[i][j]=new long [height];		if (!l_cube[i][j]) cout << "allocation error in l_cube - height " << i << " x  " << j;		}	}for (i=0 ; i<length ; i++) {	for (j=0 ; j<width ; j++) {		for (k=0; k<height ; k++) l_cube[i][j][k]=0;		}	}return l_cube;}/* ulcube: creates a 3D matrix of unsigned long/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long ***ulcube(int length, int width, int height){int i, j, k;unsigned long ***ul_cube = new unsigned long ** [length];if (!ul_cube) cout << "allocation error in ul_cube - length";/* allocate rows and set pointers to them */for (i=0 ; i<length ; i++) {	ul_cube[i] = new unsigned long * [width];	if (!ul_cube[i]) cout << "allocation error in ul_cube - width " << i;	}for (i=0 ; i<length ; i++) {	for (j=0 ; j<width ; j++) {		ul_cube[i][j]=new unsigned long [height];		if (!ul_cube[i][j]) cout << "allocation error in ul_cube - height " << i << " x  " << j;		}	}for (i=0 ; i<length ; i++) {	for (j=0 ; j<width ; j++) {		for (k=0; k<height ; k++) ul_cube[i][j][k]=0;		}	}return ul_cube;}void free_cube(float ***f_cube, int length, int width){	int i, j;		for (i=0 ; i<length ; i++) {		for (j=0 ; j<width ; j++) 			{			delete [] f_cube[i][j];			f_cube[i][j]=0;			}	}	for (i=0 ; i<length ; i++) 		{		delete [] f_cube[i];		f_cube[i]=0;		}	delete [] f_cube;	f_cube=0;		return;}void free_fcube(float ***f_cube, int length, int width){int i, j;for (i=0 ; i<length ; i++) {	for (j=0 ; j<width ; j++) 		{		delete [] f_cube[i][j];		f_cube[i][j]=0;		}	}for (i=0 ; i<length ; i++) 	{	delete [] f_cube[i];	f_cube[i]=0;	}delete [] f_cube;f_cube=0;return;}void free_dcube(double ***d_cube, int length, int width){int i, j;for (i=0 ; i<length ; i++) {	for (j=0 ; j<width ; j++) 		{		delete [] d_cube[i][j];		d_cube[i][j]=0;		}	}for (i=0 ; i<length ; i++) 	{	delete [] d_cube[i];	d_cube[i]=0;	}delete [] d_cube;d_cube=0;return;}void free_icube(int ***i_cube, int length, int width){int i, j;for (i=0 ; i<length ; i++) {	for (j=0 ; j<width ; j++) 		{		delete [] i_cube[i][j];		i_cube[i][j]=0;		}	}for (i=0 ; i<length ; i++) 	{	delete [] i_cube[i];	i_cube[i]=0;	}delete [] i_cube;i_cube=0;return;}void free_lcube(long ***l_cube, int length, int width){int i, j;for (i=0 ; i<length ; i++) {	for (j=0 ; j<width ; j++) 		{		delete [] l_cube[i][j];		l_cube[i][j]=0;		}	}for (i=0 ; i<length ; i++) 	{	delete [] l_cube[i];	l_cube[i]=0;	}delete [] l_cube;l_cube=0;return;}void free_ulcube(unsigned long ***ul_cube, int length, int width){int i, j;for (i=0 ; i<length ; i++) {	for (j=0 ; j<width ; j++) 		{		delete [] ul_cube[i][j];		ul_cube[i][j]=0;		}	}for (i=0 ; i<length ; i++) 	{	delete [] ul_cube[i];	ul_cube[i]=0;	}delete [] ul_cube;ul_cube=0;return;}
#define probability#include "probability.h"#include "matrixanalysis.h"#include "memory.h"#include <math.h>#include <stdlib.h>#include <stdio.h>#include <string.h>#include <time.h>#define	e	2.718281828#define	pi	3.141592654/* calculate an array that can be used to generate a Poisson distribution *//* it provides an array of integers summing to precision, where each cell n gives		the P[²n | rate, time] * precision; a random number number from 1Éprecision		now can be used to randomly generate an outcome given that Poisson probability;		in random=1000, then simply find the first cell in which result[n]>1000; n then		is the outcome./*		Requires: rate/*				  time/*				  n (number of successes);/*		Returns: P, the probability of n given r and t******************************************************************************/int *PoissonRand(double rate, double time, double precision){int	a, b;double	x, y, sum=0;int	*result;b=y=0;x=1;while (x>=(1/precision) || sum<(precision/2))	{	x=pow(e,(-1*rate*time)) * pow((rate*time),b) / fact(b);	sum=sum+(x*precision);	++b;	}result=ivector(b);/*(int *)malloc(b*sizeof(int));*/y=0;for (a=0; a<b; ++a)	{	x=pow(e,(-1*rate*time)) * pow((rate*time),a) / fact(a);	y=y+(x*(precision*precision)/sum);	result[a]=y;	if (y-result[a]>0.5)	++result[a];	}return result;}/* Poisson - calculated the Poisson probability of n events over t given an/*			expectation of r*t/*		Requires: r (rate)/*				  t ("time")/*				  n (number of successes);/*		Returns: P, the probability of n given r and t******************************************************************************/double Poisson(double r, double t, double n){double	P;P = pow(e,(-1*r*t)) * pow((r*t),n) / fact(n);return P;}/* lnPoisson - calculated the poisson probability of n events over t given an/*			expectation of r*t/*		Requires: r (rate)/*				  t ("time")/*				  n (number of successes);/*		Returns: P, the probability of n given r and t******************************************************************************/double lnPoisson(double r, double t, double n){int		i;double	x=0, lnP=0;for (i=2; i<=n; ++i)	x=x+log(i);lnP = (-1*r*t) + n*log(r*t) - x;return lnP;}/* lnPoisson_vector - calculated the poisson probability of a vector of length s given /*			n[0És] events expectation of exp[0És]/*		Requires: exp: (vector of expectations, e.g., rate x time)/*				  n: vector of observations (e.g., number of successes);/*				  mxf: maximum length of both vectors;/*		Returns: P, the probability of n given r and t******************************************************************************/double lnPoisson_vector(double *exp, double *n, int mxf){int		f, i;double	x, y=-1.0f, z=-1*pow(10,-5), lnP=0;for (f=0; f<=mxf; ++f)	{/*	while ((y>z && n[f]==0) && f<mxf)	++f;/* this skips through f's that produce probabilities so low that it won't affect anything */	while (n[f]==0 && f<=mxf)	{		if (exp[f]==0)	exp[f]=pow(10,-323);	/* this is the minimum number it can calculate 			*/		lnP+=(-1*exp[f]);						/* log Poisson prob. when there are 0 finds is -1 x rate	*/		++f;		}	if (f>mxf)	break;							/* if the above while loop goes too far, then quit 			*/	if (exp[f]==0)	exp[f]=pow(10,-323);		/* this is the minimum number it can calculate 				*/	x=0.0f;	for (i=2; i<=n[f]; ++i)	x=x+log(i);	lnP=lnP+(y=(-1*exp[f])+n[f]*log(exp[f])-x);	}for (f=f; y<z; ++f)	lnP=lnP+(y=(-1*exp[f]));return lnP;}/* lnPoisson_vector - calculated the poisson probability of a vector of lenght s given /*		  P=([exp^n] x [e^-exp])/n!		lnP=(n x exp) - exp - ln (n!)/*			n[0És] events expectation of exp[0És]/*		Requires: exp: (vector of expectations, e.g., rate x time)/*				  n: vector of observations (e.g., number of successes);/*				  mxf: maximum length of both vectors;/*		Returns: P, the probability of n given r and t******************************************************************************/double lnPoisson_vector_part(double *exp, double *n, int mxf, int start){int		f, i;double	x, y=-1.0f, z=-1*pow(10,-5), lnP=0;for (f=start; f<=mxf; ++f)	{/*	while ((y>z && n[f]==0) && f<mxf)	++f;/* this skips through f's that produce probabilities so low that it won't affect anything */	while (n[f]==0 && f<=mxf)	{		if (exp[f]==0)	exp[f]=pow(10,-323);	/* this is the minimum number it can calculate 			*/		lnP+=(-1*exp[f]);						/* log Poisson prob. when there are 0 finds is -1 x rate	*/		++f;		}	if (f>mxf)	break;							/* if the above while loop goes too far, then quit 			*/	if (exp[f]==0)	exp[f]=pow(10,-323);		/* this is the minimum number it can calculate 				*/	x=0.0f;										for (i=2; i<=n[f]; ++i)	x=x+log(i);			/* calculate the factorial portion of the Poisson by summing the logs */	lnP+=(y=((-1*exp[f])+n[f]*log(exp[f])-x)); 	/* log Poisson equation */	}/* this adds the probablity after we've made our last observation: 0's are somewhat improbable, after all	*/for (f=f; y<z && f<2*mxf; ++f)	lnP+=(y=(-1*exp[f]));return lnP;}/* binomexact - calculated the exact binomial probability of n events over t possible events/*			given an expectation of x*t/*		Requires: n: successes/*				  t: possible successes/*				  x: probability of success;/*		Returns: p, the probability of n given r and t	NOTE: We use logs because they are much easier numbers with which to work.  ******************************************************************************/double binomexact(int n, int t, double x){int		i, m;double	lnc=0.0000000f, lp=0.0f, p=0.0f, y=0.0f;m=n;if (m>(t-n))	m=t-n;/* calculate combinations in logarithms */for (i=(t-m)+1; i<=t; ++i)		lnc=lnc+log(i);for (i=2; i<=m; ++i)			lnc=lnc-log(i);/* find log of probability */y=1-x;lp=lnc+((double)n)*log(x)+((double)(t-n)*log(y));p=pow(e,lp);return p;}/* lnmultinomsuff - calculates the log of the sufficient statistic for multinomial probability/*	Requires: /*		obs: vector of observed values where obs[i] gives the number of times i is observed;/*		exp: vector of expected proportion of times we expect to observe i/*		n: number of entities sampled (i.e., the sum of obs);/*	Returns: l/*		lp, the log probability of obs given exp and n	NOTE: We use logs because they are much easier numbers with which to work.  ******************************************************************************/double lnmultinomsuff(double *obs, double *exp, int n){int		i, j=0;double	lp=0.0f;for (i=0; i<n; ++i)	if (((int) obs[i])>0)	j=i;	/* find the maximum observed value			*/for (i=0; i<=j; ++i)	{					/* don't bother after you pass the maximum	*/	while (obs[i]==0)	++i;	if (exp[i]==0)	exp[i]=pow(10,-323);		/* this is the minimum number it can calculate 				*/	lp+=obs[i]*log(exp[i]);	}return lp;}/* chidist - calculates the probability of a sum of squared deviations from expectation/*			given degrees of freedom/*	Requires: n: successes/*		ssq: sum of squared deviations from expectation/*		df: degrees of freedom;/*	Returns: X, the probability of ssq given df******************************************************************************/double chidist(double ssq, int df){double n, X=0.0f;n = df;X = (0.5*pow(e,(-1*ssq)/2)*pow((ssq/2),(n-1)))/gamma(n/2);return X;}/* Calculate Gamma(a)	Requires:		a: a real number (but must be evenly divisible by 0.5)	Returns:		g: the gamma function ******************************************************************************/double gamma(double a){int	n, b;double	g;n=a;if ((a-n)<0.5)	g=b=fact(a-1);else	g=(pow(2,-2*n)*fact(2*n)*pow(pi,0.5))/fact(n);return g;}/* Calculate gammaprob	Requires:		y: observed value (e.g., sum of squared deviations for Chi-square);		a: the alpha parameter (e.g., half the degrees of freedom in a Chi-square);		b: the lambda/beta paramter (e.g., 0.5 for a chi-square distribution);	Returns:		p: the probability of y given a & b ******************************************************************************/double gammaprob(double y, double a, double b){int	up;double	h, g, x, p, lh, fx;g=gamma(a);p=(b*pow(e,(-1*b*y)))*pow(b*y,a-1);lh=0.0;up=h=1.0;x=0;while (h>0.0001 && up==1)	{	fx=fx+(h= b*exp(-1*b*x) * pow(b*x,a-1));	if (h>lh)	up=1;	else		up-0;	lh=h;	x=x+0.0001;	}p=p/fx;return p;}/* Calculate a factorial for interger d ******************************************************************************/int fact(int d){int	a, result;double	x, y;if (d<=1)	result=1;else	{	x=0;	for (a=2; a<=d; ++a)		x=x+log(a);		y=pow(e,x);	result=y;	if ((y-result)>0.5)	++result;	}return result;}/* Pathsback - calculates the number of paths that lead back to the original state/*			given steps states./*		Requires: steps (number of changes)/*				  states (number of states)/*		Returns: paths******************************************************************************/int paths_back(int steps, int states){int	i, paths;paths=0;for (i=2; i<=steps; ++i)	{	paths=paths+pow(-1,i)*pow((states-1),i-1);	}paths=abs(paths);return paths;}/* Combin - calculates the number of combinations/*		Requires: N (total number of possibilities)/*				  n (number of successes)/*		Returns: C, the number of combinations of n within N/* C = N! / (n! * [N-n]!)/* Because factorials quickly become unwieldy, it is caluclated here by summing/*		logs:  lnC = ·ln(N) - (·ln(n) + ·ln(N-n)long combin(int n, int N){int		i, C;double	x, y, z;if (n==0 || N==1)	C=1;else {	x=y=z=0;	for (i=1; i<=N; ++i)		x=x+log(i);	for (i=1; i<=n; ++i)		y=y+log(i);	for (i=1; i<=(N-n); ++i)	z=z+log(i);	x=x-(y+z);	x=pow(e,x);	C=x;	if ((x-C)>0.5)	++C;	}return C;}******************************************************************************//* mean: calculates the average given an array of length n;/*	requires:/*		data: a vector of double/*		N: the number of datapoints to be averaged/*/*	returns:/*		ave: the mean (average)******************************************************************************/double mean(double *data, int N){double	ave, rN=0.0f;rN=N;ave=darraytotal(data,N);ave=ave/rN;return ave;}/* variance: calculates the variance given an array of length n;/*	requires:/*		data: a vector of double/*		N: the number of datapoints to be averaged/*/*	returns:/*		S2: the variance******************************************************************************/double variance(double *data, int N){int		a;double	ave, S2=0.0f, rN=N;ave=mean(data,N);for (a=0; a<N; ++a)	S2=S2+((data[a]-ave)*(data[a]-ave));S2=S2/(rN-1);return S2;}/* stand_dev: calculates the standard deviation given an array of length n;/*	requires:/*		data: a vector of double/*		N: the number of datapoints to be averaged/*/*	returns:/*		S: the standard deviation******************************************************************************/double stand_dev(double *data, int N){double	S;S=variance(data,N);S=pow(S,0.5);return S;}/* sumsqdiffs - find the sum of squared differences between two vectors	Requires:		v1 - array of observed;		v2 - array of expected;		n - number of data points (length of arrays);	Returns:		ssq - sum of squared differences between v1 and v2******************************************************************************/double dsumsqdiffs (double *v1, double *v2, int n){int i;double ssq=0.0000f;for (i=0; i<n; ++i)	{	ssq+=(v1[i]-v2[i])*(v1[i]-v2[i]);	}return ssq;}/* normheight - find height of normal curve at x, given mean and standard deviation	Requires:		x - a point on the ordinate;		mean - the mean on the ordinate;		sd - the standard deviation;	returns:		ht - the height of the curve.******************************************************************************/double normheight (double x, double mean, double sd){double	y, ht;y=(x-mean)/sd;y*=y;y/=-2;ht = exp(y)/(sd*pow(2*pi,0.5));return ht;}/* nerf - calculate error function for determining area under a normal curverequires: x - distance from the mean in standard deviationsreturns: r******************************************************************************/double nerf(double x){int			i;double		d, y=1.0f, lnd=0.00000f;double long	lnr=0.00000000f, r=0.00000f;for (i=1; y>=0.001; i=i+2)	{/*	d*=i;	r+=pow(x,i)/((double) d);	*/	lnd+=log((double) i);	lnr= i*log(x)-lnd;	d=pow(e,lnd);	r+=(y=pow(e,lnr));	}return r;}/* nerf - calculate error function for determining area under a normal curve	Requires: 		x - 1st datum		y - 2nd	datum		mean - the mean		sd - standard deviation	Returns:		area - the area under a normal curve between x and y******************************************************************************/double normareabetween(double x, double y, double mean, double sd){double	w, z, xa, xer, ya, yer;double	area;if (x>y)	{	z=x;	x=y;	y=z;	}z=(x-y)/10000;for (w=x; w<=y; w+=z)	{		}/* if both are to the left of the mean */if (x<mean && y<=mean)	{	xa=normheight(0,(mean-x)/sd,1);	xer=nerf((mean-x)/sd);	xa*=xer;	ya=normheight(0,(mean-y)/sd,1);	yer=nerf((mean-y)/sd);	ya*=yer;		area=xa-ya;	}/* if x is to the left of the mean and y is to the right of the mean */else if (x<mean && y>mean)	{	xa=normheight(0,(mean-x)/sd,1);	xer=nerf((mean-x)/sd);	xa*=xer;	ya=normheight(0,(y-mean)/sd,1);	yer=nerf((y-mean)/sd);	ya*=yer;		area=ya+xa;	}/* if x is to the right of the mean and y is to the right of the mean */else if (x>=mean && y>mean)	{	xa=normheight(0,x-mean,1);	xer=nerf(x-mean);	xa*=xer;	ya=normheight(0,(y-mean)/sd,1);	yer=nerf((y-mean)/sd);	ya*=yer;		area=ya-xa;	}return area;}/***************************************************************************returns natural log of gamma function for value xx>0	written by T. Olszewski 2003/***************************************************************************/double gammln(double xx){double x,y,tmp,ser;static double cof[6]={76.18009172947146,-86.50532032941677,24.01409824083091,-1.2317395724550155,0.1208650973866179e-2,-0.5395239384953e-5};int j;y=x=xx;tmp=x+5.5;tmp -= (x+0.5)*log(tmp);ser=1.000000000190015;for (j=0;j<=5;j++) ser += cof[j]/++y;return -tmp+log(2.5066282746310005*ser/x);}
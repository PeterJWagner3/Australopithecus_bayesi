double *count_fit_mul_zsm(int *empdist, int ntaxa, int nspec){int i=0, j=0;				/* LOOP VARIABLE															*//*int	r=0;					/* richness (calculated from distribution									*/int theospc=5*nspec;double m=0.0f;				/* m for loop																*/double mi=0.25f;			/* m increment																*/double imi=0.25f;			/* initial m increment each loop											*/double lmi[2];				/* previous m increment														*/double min=0.75f;			/* initial m to use in each search (begins as ntaxa)						*/long double mmx=0.999999f;	/* maximum m to consider													*/long double mmn=0.000001f;	/* minimum m																*/double lti[2];				/* last two theta incrementers												*/double iti;					/* initial slope increment at each m										*/double theta=0.000f;		/* LOOP theta 																*/double tmin=0.000001f;			/* min theta slope															*/double tin=10.000f;			/* initial theta															*/double ti=10.000f;			/* how much to increment theta in each loop									*/double mti=0.0001f;			/* minimum theta increment													*/double ts[3];				/* previous modal decay log likelihoods (cell number = num previous).		*/double ms[3];				/* previous m log likelihoods (cell number = num previous).					*/double *btp;				/* BEST decay for hypothesized theta at given S - return array format 		*/double bmp[2];				/* BEST m parameters - return array											*/double pbms;				/* previous best support for m												*/double pbts=-1*DBL_MAX;		/* previous best support for theta											*//*double *expect;				/* expected number of species with 0Émax finds								*/double *expind;				/* expected number of species with 0Émax individuals						*/double *expsamp;			/* expected number of species with 0Émax finds								*/double *obsrvd;				/* observed number of species with 0Émax finds								*/double x;					/* summing variable															*/FILE	*fopen();	btp=dvector(3);for (i=0; i<3; i++) btp[i]=-1.0*DBL_MAX;for (i=0; i<3; ++i)	ts[i]= -1.0*DBL_MAX;/* we need arrays giving both the number of taxa with x finds and all x finds with 1+ species */obsrvd=idhistogram(empdist,ntaxa);tin=chao2(empdist,ntaxa);tin*=0.3;ti=iti=tin/4;mti=0.0001*iti;/*tin=3.30f;	*/lti[0]=tin;lti[1]=0.0f;	/*min=(mmx+mmn)/2;		/* it seems that m's on either side of 0.85 repeat each other....	*//*imi=(1-min)/2;	*/imi=mmx-min;/* adjust true m until that fails to improve likelihood	*/for (theta = tin; ((theta>=tmin && fabs(ti)>mti) || pbts == -1*DBL_MAX); theta += ti) {		/*Debugging line */	if (theta<=tmin) printf("\nDANGER: theta=%f, m=%f ",theta, m);	/* increment starting at 0.1 since we are almost never going to find slopes of 2+	*/	for (i=0; i<3; i++) ms[i] = -1.0*DBL_MAX;	bmp[0]=bmp[1]= -1.0*DBL_MAX;	lmi[0]=lmi[1]=0.0f;	mi=imi;		pbms=-1*DBL_MAX;	/* find the best theta for this m */	for (m=mmx; ((mi!=0 && (m>=mmn && m<=mmx))  && (pbms==-1*DBL_MAX || bmp[0]>pbms +SUPINC)); m+=mi)	{		obsrvd[0]=0;		expind=zerosum(theta,m,theospc);				x=sumdvector(expind,theospc);				for (j=1; expind[j]>0 && j<theospc; j=j)	++j;		/*		debug=fopen("Test.txt","w");		for (i=0; i<j; ++i)	fprintf(debug,"%25.24f\n",expind[i]);		fclose(debug);	/**/		if (x>=ntaxa)	{			expsamp=expfindsfromexpindprop(expind,j,nspec);			free_dvector(expind);			ms[0]=lnmultinomsuff(obsrvd,expsamp,nspec);				free_dvector(expsamp);			}		else	{			ms[0]=-1*DBL_MAX;			free_dvector(expind);			}		/* if this m is better than the last */		if (ms[0] >= bmp[0]) {						/* IF BETTER THAN BEST FIT */			pbms = bmp[0];							/* save last best ssq for m */			bmp[0]=ms[0];							/* STORE FIT */			bmp[1]=m;								/* STORE SLOPE */						/* while we are getting better on the initial increment, just ride with it			*/			if (fabs(mi)==fabs(imi))	{				lmi[1]=lmi[0];				lmi[0]=mi;				if (m+mi<mmn || m+mi>mmx)				mi/=-2;				}			/* if we have a later improvement, wander halfway back to the last improvement 	*/			/* (remember, we always start at the most likely slope up to that point			*/			else	{				lmi[1]=lmi[0];				lmi[0]=mi;				mi/=2;				if (m+mi<mmn || m+mi>mmx)				mi/=-1;				}			}		/* optimal m is overshot */		else {			m=bmp[1];				/* step back to best m	 */					/* if we start off going downhill, then go the other way */						if (mi==imi)						mi*=-1;			else if (fabs(mi)==fabs(lmi[0]))	{				lmi[1]=lmi[0];				lmi[0]=mi;				mi/=2;				if (m+mi>mmx || m+mi<mmn)	{					if (fabs(mi)==fabs(lmi[0]))	mi/=-2;					else						mi/=-1;					}				}			else if (mi==lmi[0]/2)	{				lmi[1]=lmi[0];				lmi[0]=mi;				mi*=-1;				if (m+mi>mmx || m+mi<mmn)		mi/=-2;				}			else if (mi==imi && m==min)	{				lmi[1]=lmi[0];				lmi[0]=mi;				mi*=-1;				if (m+mi>mmx || m+mi<mmn)		mi/=-2;				}			/* if this increment is opposite of the last, then cut it in half */			else if (fabs(mi)==fabs(lmi[0]))	{				lmi[1]=lmi[0];				lmi[0]=mi;				/* go towards the one with the higher likelihood */				if (ms[1]>ms[0])				mi/=-2;				else							mi/=2;				if (m+mi>mmx || m+mi<mmn)		mi/=-1;				}			/* if this increment is less then the last, then */			else if (fabs(mi)<fabs(lmi[0]))	{				lmi[1]=lmi[0];				lmi[0]=mi;				mi*=-1;				if (m+mi>mmx || m+mi<mmn)		mi/=-2;				}			}				if ((ms[0]>=ms[1] && ms[0]<(ms[1]+SUPINC)) && (ms[1]>=ms[2] && ms[1]<(ms[2]+SUPINC)))				mi=0;				/* if we basically are running into improvement up to the min/max, then just take the min/max	*/		else if ((bmp[1]==mmx || bmp[1]==mmn) && (bmp[0]<(ms[0]+0.1) && (bmp[0]<(ms[1]+0.1) && bmp[0]<(ms[2]+0.1))))			mi=0;					/* if it is trying to get past the maximum, then kill it	*/		else if ((bmp[1]==mmx && (bmp[0]<btp[0] && btp[1]>mmx)) && (bmp[0]>ms[0] && (bmp[0]>ms[1] && bmp[0]>ms[2])))			mi=0;		/* if log likelihood is hopelessly low for this theta, then skip to the next	*/		else if (bmp[0]<1.25*btp[0])			mi=0;				ms[2] = ms[1];		ms[1] = ms[0];				if (ms[0]==-1*DBL_MAX && (ms[0]==ms[1] && ms[0]==ms[2]))			mi=0;		}	/* end search for m */	ts[0]=bmp[0];	if (bmp[0] >= btp[0]) {						/* IF BETTER THAN BEST FIT */		pbts = btp[0];							/* save last best ssq for theta */		btp[0] = bmp[0];						/* STORE FIT */		btp[1] = bmp[1];						/* STORE m */		btp[2] = theta;							/* STORE m */				/* while we are getting better on the initial increment, just ride with it			*/		if (fabs(ti)==fabs(iti))	{			lti[1]=lti[0];			lti[0]=ti;			if (theta+ti<tmin)				ti/=2;						/* to avoid local optima, at least on intial search */			else if (btp[0] <= (pbts + SUPINC))	{				/* return to prior theta	*/				if (theta==(tin+iti))	{					theta=tin;					ti*=-1;					pbts-=1.0f;					}				else if (theta==(tin-iti))	{					theta=tin;					ti/=2;					pbts-=1.0f;					}				}	/* end case where we had trivial improvement within one step of initial theta */			}		/* if we have a later improvement, wander halfway back to the last improvement 	*/		/* (remember, we always start at the most likely slope up to that point			*/		else	{			lti[1]=lti[0];			lti[0]=ti;			ti/=2;			if (theta+ti<tmin)				ti/=-1;			}		}	/* end case where likelihood has improved	*/					/* If likelihood has not increased, then reset and change the increment  value	*/	else	{		/* if we went from x -> -x, then we want to cut the increment in half */		lti[1]=lti[0];		lti[0]=ti;		if (fabs(ti)==fabs(iti))	{			/* if the first increment does not help, then reverse direction	*/			if (theta==tin+iti)				ti*=-1;			/* if an increment after the first stops helping, then go half way	*/			else							ti/=2;			if (theta+ti<tmin)				ti/=-2;			}		else	{			if (fabs(lti[0])==fabs(lti[1]))	ti/=2;			else							ti*=-1;			if (theta+ti<tmin)				ti/=-2;			}/*			if (ti==-1*lti[0] || ti==iti)	{			if (ti==iti)	{				/* determine whether ts[0] or ts[2] is the second best - move towards that	/				if (ts[0]>ts[2])	ti/=2;				else				ti/=-2;				}			else	{				/* determine whether ts[0] or ts[1] is the second best - move towards that	/				if (ts[0]>ts[1])	ti/=2;				else				ti/=-2;				}			}		/* if we just divided in half, then we want to reverse the increment /		else if (ti==-1*iti || (2*ti==lti[0] || -2*ti==lti[0]))	{			/* if theta+x/2 got closer than theta-x, back up and go to theta+x/4	/			if (fabs(ti)==fabs(lti[0]))	ti/=2;			else						ti*=-1;			} */		theta=btp[2];		}			/* start the next m at the best m so far *//*	if (btp[1]>0.5)	imi=(mmx-btp[1])/2;	*//*	else			imi=(btp[1]-mmn)/2;	*//*	min=btp[1];		*/	/* make sure that imi is not too small */	if (fabs(imi)<0.0001)	{		if (imi<0)						imi=-0.0001;		else							imi=0.0001;		}	/* make sure that imi does not take m out of bounds */	if (min+imi>mmx || min+imi<mmn)		imi*=-1;	/* make sure that ti does not take theta below 1.0 */	if (theta+ti<= tmin)	{		if (fabs(lti[0])==fabs(ti))			ti/=-2;		else								ti/=-1;		}	ts[2] = ts[1];									/* Store last 2 attempts to identify	*/	ts[1] = ts[0];									/* when the peak is past 				*/		if (btp[0] < (pbts + SUPINC) && fabs(ti)<((fabs(iti)/20)))	ti=0.0f;	}	/* end search for theta */tin=btp[2];ti=iti=tin/4;mti=0.0001*iti;mmn=0.0001f;mmx=0.85;lti[0]=tin;lti[1]=0.0f;	min=(mmx+mmn)/2;		/* it seems that m's on either side of 0.85 repeat each other....	*/imi=mmx-min;for (theta = tin; ((theta>=tmin && fabs(ti)>mti) || pbts == -1*DBL_MAX); theta += ti) {		/*Debugging line */	if (theta<=tmin) printf("\nDANGER: theta=%f, m=%f ",theta, m);	/* increment starting at 0.1 since we are almost never going to find slopes of 2+	*/	for (i=0; i<3; i++) ms[i] = -1.0*DBL_MAX;	bmp[0]=bmp[1]= -1.0*DBL_MAX;	lmi[0]=lmi[1]=0.0f;	mi=imi;		pbms=-1*DBL_MAX;	/* find the best theta for this m */	for (m=min; ((mi!=0 && (m>=mmn && m<=mmx))  && (pbms==-1*DBL_MAX || bmp[0]>pbms +SUPINC)); m+=mi)	{		obsrvd[0]=0;		expind=zerosum(theta,m,theospc);				x=sumdvector(expind,theospc);				for (j=1; expind[j]>0 && j<theospc; j=j)	++j;				if (x>=ntaxa)	{			expsamp=expfindsfromexpindprop(expind,j,nspec);			free_dvector(expind);			ms[0]=lnmultinomsuff(obsrvd,expsamp,nspec);				free_dvector(expsamp);			}		else	{			ms[0]=-1*DBL_MAX;			free_dvector(expind);			}		/* if this m is better than the last */		if (ms[0] >= bmp[0]) {							/* IF BETTER THAN BEST FIT */			pbms = bmp[0];								/* save last best ssq for m */			bmp[0]=ms[0];							/* STORE FIT */			bmp[1]=m;									/* STORE SLOPE */						/* while we are getting better on the initial increment, just ride with it			*/			if (fabs(mi)==fabs(imi))	{				lmi[1]=lmi[0];				lmi[0]=mi;				if (m+mi<mmn || m+mi>mmx)				mi/=-2;				}			/* if we have a later improvement, wander halfway back to the last improvement 	*/			/* (remember, we always start at the most likely slope up to that point			*/			else	{				lmi[1]=lmi[0];				lmi[0]=mi;				mi/=2;				if (m+mi<mmn || m+mi>mmx)				mi/=-1;				}			}		/* optimal m is overshot */		else {			m=bmp[1];				/* step back to best m	 */					/* if we start off going downhill, then go the other way */						if (mi==imi)						mi*=-1;			else if (fabs(mi)==fabs(lmi[0]))	{				lmi[1]=lmi[0];				lmi[0]=mi;				mi/=2;				if (m+mi>mmx || m+mi<mmn)	{					if (fabs(mi)==fabs(lmi[0]))	mi/=-2;					else						mi/=-1;					}				}			else if (mi==lmi[0]/2)	{				lmi[1]=lmi[0];				lmi[0]=mi;				mi*=-1;				if (m+mi>mmx || m+mi<mmn)		mi/=-2;				}			else if (mi==imi && m==min)	{				lmi[1]=lmi[0];				lmi[0]=mi;				mi*=-1;				if (m+mi>mmx || m+mi<mmn)		mi/=-2;				}			/* if this increment is opposite of the last, then cut it in half */			else if (fabs(mi)==fabs(lmi[0]))	{				lmi[1]=lmi[0];				lmi[0]=mi;				/* go towards the one with the higher likelihood */				if (ms[1]>ms[0])				mi/=-2;				else							mi/=2;				if (m+mi>mmx || m+mi<mmn)		mi/=-1;				}			/* if this increment is less then the last, then */			else if (fabs(mi)<fabs(lmi[0]))	{				lmi[1]=lmi[0];				lmi[0]=mi;				mi*=-1;				if (m+mi>mmx || m+mi<mmn)		mi/=-2;				}			}				if ((ms[0]>=ms[1] && ms[0]<(ms[1]+SUPINC)) && (ms[1]>=ms[2] && ms[1]<(ms[2]+SUPINC)))				mi=0;				/* if we basically are running into improvement up to the min/max, then just take the min/max	*/		else if ((bmp[1]==mmx || bmp[1]==mmn) && (bmp[0]<(ms[0]+0.1) && (bmp[0]<(ms[1]+0.1) && bmp[0]<(ms[2]+0.1))))			mi=0;					/* if it is trying to get past the maximum, then kill it	*/		else if ((bmp[1]==mmx && (bmp[0]<btp[0] && btp[1]>mmx)) && (bmp[0]>ms[0] && (bmp[0]>ms[1] && bmp[0]>ms[2])))			mi=0;		/* if log likelihood is hopelessly low for this theta, then skip to the next	*/		else if (bmp[0]<1.25*btp[0])			mi=0;				ms[2] = ms[1];		ms[1] = ms[0];				if (ms[0]==-1*DBL_MAX && (ms[0]==ms[1] && ms[0]==ms[2]))			mi=0;		}	/* end search for m */	ts[0]=bmp[0];	if (bmp[0] >= btp[0]) {							/* IF BETTER THAN BEST FIT */		pbts = btp[0];								/* save last best ssq for theta */		btp[0] = ts[0];								/* STORE FIT */		btp[1] = bmp[1];							/* STORE m */		btp[2] = theta;								/* STORE m */				/* while we are getting better on the initial increment, just ride with it			*/		if (fabs(ti)==fabs(iti))	{			lti[1]=lti[0];			lti[0]=ti;			if (theta+ti<tmin)				ti/=-2;						/* to avoid local optima, at least on intial search */			else if (btp[0] <= (pbts + SUPINC))	{				/* return to prior theta	*/				if (theta==(tin+iti))	{					theta=tin;					ti*=-1;					pbts-=1.0f;					}				else if (theta==(tin-iti))	{					theta=tin;					ti/=2;					pbts-=1.0f;					}				}	/* end case where we had trivial improvement within one step of initial theta */			}		/* if we have a later improvement, wander halfway back to the last improvement 	*/		/* (remember, we always start at the most likely slope up to that point			*/		else	{			lti[1]=lti[0];			lti[0]=ti;			ti/=2;			if (theta+ti<tmin)				ti/=-1;			}		}	/* end case where likelihood has improved	*/					/* If likelihood has not increased, then reset and change the increment  value	*/	else	{		/* if we went from x -> -x, then we want to cut the increment in half */		lti[1]=lti[0];		lti[0]=ti;		if (fabs(ti)==fabs(iti))	{			/* if the first increment does not help, then reverse direction	*/			if (theta==tin+iti)				ti*=-1;			/* if an increment after the first stops helping, then go half way	*/			else							ti/=2;			if (theta+ti<tmin)				ti/=-2;			}		else	{			if (fabs(lti[0])==fabs(lti[1]))	ti/=2;			else							ti*=-1;			if (theta+ti<tmin)				ti/=-2;			}/*			if (ti==-1*lti[0] || ti==iti)	{			if (ti==iti)	{				/* determine whether ts[0] or ts[2] is the second best - move towards that	/				if (ts[0]>ts[2])	ti/=2;				else				ti/=-2;				}			else	{				/* determine whether ts[0] or ts[1] is the second best - move towards that	/				if (ts[0]>ts[1])	ti/=2;				else				ti/=-2;				}			}		/* if we just divided in half, then we want to reverse the increment /		else if (ti==-1*iti || (2*ti==lti[0] || -2*ti==lti[0]))	{			/* if theta+x/2 got closer than theta-x, back up and go to theta+x/4	/			if (fabs(ti)==fabs(lti[0]))	ti/=2;			else						ti*=-1;			} */		theta=btp[2];		}			/* start the next m at the best m so far *//*	if (btp[1]>0.5)	imi=(mmx-btp[1])/2;	*//*	else			imi=(btp[1]-mmn)/2;	*//*	min=btp[1];		*/	/* make sure that imi is not too small */	if (fabs(imi)<0.0001)	{		if (imi<0)						imi=-0.0001;		else							imi=0.0001;		}	/* make sure that imi does not take m out of bounds */	if (min+imi>mmx || min+imi<mmn)		imi*=-1;	/* make sure that ti does not take theta below 1.0 */	if (theta+ti<= tmin)	{		if (fabs(lti[0])==fabs(ti))			ti/=-2;		else								ti/=-1;		}	ts[2] = ts[1];									/* Store last 2 attempts to identify	*/	ts[1] = ts[0];									/* when the peak is past 				*/	if (btp[0] < (pbts + SUPINC) && fabs(ti)<((fabs(iti)/20)))	ti=0.0f;	}	/* end search for theta */free_dvector(obsrvd);return btp;}